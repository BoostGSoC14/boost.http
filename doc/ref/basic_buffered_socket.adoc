[[basic_buffered_socket]]
==== `basic_buffered_socket`

[source,cpp]
----
#include <boost/http/buffered_socket.hpp>
----

This template can be used to easily define classes fulfilling the strict
<<server_socket_concept,`ServerSocket` concept>> and
<<client_socket_concept,`ClientSocket` concept>>. These classes exposes the
`HTTP/1.1` wire format (i.e. a builtin/standalone HTTP server) into an
easy-to-use API.

The underlying I/O object is expected to have the following properties:

* It is stream-oriented (i.e. no message boundaries; read or write operations
  may transfer fewer bytes than requested...).
* It fulfills the ASIO's `AsyncReadStream` requirement.
* It fulfills the ASIO's `AsyncWriteStream` requirement.
* It is backed by a reliable transport or session-layer “connection” with
  in-order delivery of octets (i.e. any 8-bit sequence of data).

[NOTE]
--
This class doesn't restrict the message, method, path and reason phrase types.
Therefore, the following members are *not* defined:

* `message_type`
* `request_type`
* `response_type`
--

WARNING: The API from this class is implemented in terms of composed
operations. As such, you MUST *NOT* initiate any async read operation while
there is another read operation in progress and you MUST *NOT* initiate any
async write operation while there is another write operation in progress. If you
cannot guarantee the ordering of the operations, you should use some queueing
socket (e.g.
http://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp[
AxioMQ's `basic_queue_socket`]).

TIP: You cannot detect the lack of network inactivity properly under this
layer. If you need to implement timeouts, you should do so under the lower
layer.

===== Template parameters

`Socket`::

  The underlying communication channel type. It MUST fulfill the requirements
  for ASIO's `AsyncReadStream` and ASIO's `AsyncWriteStream`.

`Settings`::

  Traits passed to the underlying `Socket`. It defaults to _unspecified_.

`N`::

  The internal buffer size. It defaults to
  `BOOST_HTTP_SOCKET_DEFAULT_BUFFER_SIZE`

===== Member types

`typedef Socket next_layer_type`::

  The type of the underlying communication channel.

`typedef typename next_layer_type::executor_type executor_type`::

  The type of the executor associated with the object.

===== Member functions

`basic_buffered_socket(boost::asio::io_context &io_context)`::

  Constructor. _io_context_ is passed to the constructor from the underlying
  stream.

`template<class... Args> basic_buffered_socket(Args&&... args)`::

  Constructor. _args_ are forwarded to the constructor from the underlying
  stream.

`next_layer_type &next_layer()`::

  Returns a reference to the underlying stream.

`const next_layer_type &next_layer() const`::

  Returns a reference to the underlying stream.

`void open()`::

  Change socket state to open.
+
NOTE: See `is_open()`
+
WARNING: You MUST cancel current ongoing operations and wait for their
completion handlers to be called before call this function. Otherwise, undefined
behaviour is invoked.

`boost::asio::const_buffer upgrade_head() const`::

  Return the buffer representing the first few bytes of the upgraded stream (may
  be empty).

`void lock_client_to_http10()`::

  Lock HTTP to `HTTP/1.0` version if socket is used as a client socket.

`template<class Message, class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,void(system::error_code, std::size_t)) async_read_chunkext(Message &message, typename Message::headers_type &chunkext, CompletionToken &&token)`::

  See documentation in <<basic_socket,`basic_socket`>>.

`template<class Message, class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_chunkext(const Message &message, const typename Message::headers_type &chunkext, CompletionToken &&token)`::

  See documentation in <<basic_socket,`basic_socket`>>.

====== `Socket` concept

See the <<socket_concept,`Socket` concept>>.

* `executor_type get_executor()`
* `bool is_open() const`
* `read_state read_state() const`
* `write_state write_state() const`
* `template<class Message, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_read_some(Message &message, CompletionToken &&token)`
* `template<class Message, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_read_trailers(Message &message, CompletionToken &&token)`
* `template<class Message, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write(const Message &message, CompletionToken &&token)`
* `template<class Message, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_trailers(const Message &message, CompletionToken &&token)`
* `template<class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_end_of_message(CompletionToken &&token)`

====== `ServerSocket` concept

See the <<server_socket_concept,`ServerSocket` concept>>.

* `bool write_response_native_stream() const`
* `template<class Request, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_read_request(Request &request, CompletionToken &&token)`
* `template<class Response, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_response(const Response &response, CompletionToken &&token)`
* `template<class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_response_continue(CompletionToken &&token)`
* `template<class Response, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_response_metadata(const Response &response,
                                CompletionToken &&token)`

====== `ClientSocket` concept

See the <<client_socket_concept,`ClientSocket` concept>>.

* `template<class Request, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_request(const Request &request, CompletionToken &&token)`
* `template<class Request, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_write_request_metadata(const Request &request, CompletionToken &&token)`
* `template<class Response, class CompletionToken>
  BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                                void(boost::system::error_code))
  async_read_response(Response &response, CompletionToken &&token)`
