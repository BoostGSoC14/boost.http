[[basic_poly_socket_base]]
==== `basic_poly_socket_base`

[source,cpp]
----
#include <boost/http/poly_socket_base.hpp>
----

`basic_poly_socket_base` is the base class for all classes in the hierarchy
defined for runtime-based polymorphic HTTP producers. It is an abstract class
that only contains functionality useful for simultaneously both channel ends
(client and server).

References for objects of this class are expected to fulfill the
<<socket_concept,`Socket` concept>>.

This class has no state to ease multiple inheritance and it is virtual-inherited
by <<basic_poly_server_socket,`basic_poly_server_socket`>> and
<<basic_poly_client_socket,`basic_poly_client_socket`>>.

The design for the hierarchy started with this class was a little inspired by
_{cpp}'s iostream_ and
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3525.pdf[N3525:
Polymorphic Allocators].

[plantuml,poly_socket_hierarchy,title="`poly_socket_base` hierarchy"]
----
interface poly_socket_base
interface poly_server_socket
interface poly_client_socket
interface poly_socket

poly_socket_base <|-- poly_server_socket : virtual
poly_socket_base <|-- poly_client_socket : virtual
poly_server_socket <|-- poly_socket
poly_client_socket <|-- poly_socket

poly_server_socket <|-- server_socket_adaptor
poly_client_socket <|-- client_socket_adaptor
poly_socket <|-- socket_adaptor

class "ServerSocket + ClientSocket" as RendezvousSocket

socket_adaptor *- RendezvousSocket
server_socket_adaptor *- ServerSocket
client_socket_adaptor *- ClientSocket
----

===== Template parameters

`Message`::

  The message type.

===== Member types

These are the types chosen _set in stone_ to guarantee ABI stability across
binaries (including possible plugins).

`typedef boost::asio::executor executor_type`::

  The executor type.

`typedef Message message_type`::

  The message type usable within this class's operations.

`typedef asio::experimental::poly_handler<void(boost::system::error_code)> handler_type`::

  The type for asynchronous operation completion handlers.

===== Member functions

====== Overwritable functions

These are the functions that subclasses need to implement in order to lose the
`abstract class` property.

`virtual executor_type get_executor() = 0`::

  This function presents no differences (besides mandatory virtual) from the one
  with the same name found on the <<socket_concept,`Socket` concept>>.

`virtual bool is_open() const = 0`::

  This function presents no differences (besides mandatory virtual) from the one
  with the same name found on the <<socket_concept,`Socket` concept>>.

`virtual read_state read_state() const = 0`::

  This function presents no differences (besides mandatory virtual) from the one
  with the same name found on the <<socket_concept,`Socket` concept>>.

`virtual write_state write_state() const = 0`::

  This function presents no differences (besides mandatory virtual) from the one
  with the same name found on the <<socket_concept,`Socket` concept>>.

`virtual void async_read_some(message_type &message, handler_type handler) = 0`::

  The only difference between this function (besides mandatory virtual) and the
  one with the same name found on the <<socket_concept,`Socket` concept>> is the
  lack of support for completion tokens and the use of a type erased handler
  instead.

`virtual void async_read_trailers(message_type &message, handler_type handler) = 0`::

  The only difference between this function (besides mandatory virtual) and the
  one with the same name found on the <<socket_concept,`Socket` concept>> is the
  lack of support for completion tokens and the use of a type erased handler
  instead.

`virtual void async_write(const message_type &message, handler_type handler) = 0`::

  The only difference between this function (besides mandatory virtual) and the
  one with the same name found on the <<socket_concept,`Socket` concept>> is the
  lack of support for completion tokens and the use of a type erased handler
  instead.

`virtual void async_write_trailers(const message_type &message, handler_type handler) = 0`::

  The only difference between this function (besides mandatory virtual) and the
  one with the same name found on the <<socket_concept,`Socket` concept>> is the
  lack of support for completion tokens and the use of a type erased handler
  instead.

`virtual void async_write_end_of_message(handler_type handler) = 0`::

  The only difference between this function (besides mandatory virtual) and the
  one with the same name found on the <<socket_concept,`Socket` concept>> is the
  lack of support for completion tokens and the use of a type erased handler
  instead.

`virtual ~basic_poly_socket_base() = 0`::

  Destructor. Inline definition done with `= default`.

====== Wrappers to fulfill the ASIO extensible model

These functions rewrite usual function calls in terms of the ABI stable
interface. They also enable the ASIO extensible model within this hierarchy.

`template<class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_some(message_type &message, CompletionToken &&token)`::

  Handle the token and dispatch the operation to the ABI stable
  `async_read_some`.

`template<class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_trailers(message_type &message, CompletionToken &&token)`::

  Handle the token and dispatch the operation to the ABI stable
  `async_read_trailers`.

`template<class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write(const message_type &message, CompletionToken &&token)`::

  Handle the token and dispatch the operation to the ABI stable
  `async_write`.

`template<class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_trailers(const message_type &message, CompletionToken &&token)`::

  Handle the token and dispatch the operation to the ABI stable
  `async_write_trailers`.

`template<class CompletionToken> BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_end_of_message(CompletionToken &&token)`::

  Handle the token and dispatch the operation to the ABI stable
  `async_write_end_of_message`.

===== See also

* <<poly_socket_base,`poly_socket_base`>>
