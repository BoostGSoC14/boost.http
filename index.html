<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<meta name="author" content="Vinícius dos Santos Oliveira">
<title>Boost.Http</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Boost.Http</h1>
<div class="details">
<span id="author" class="author">Vinícius dos Santos Oliveira</span><br>
<span id="email" class="email"><a href="mailto:vini.ipsmaker@gmail.com">vini.ipsmaker@gmail.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_using">1. Using</a>
<ul class="sectlevel2">
<li><a href="#_requirements">1.1. Requirements</a></li>
</ul>
</li>
<li><a href="#_tutorial">2. Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_message_framework">2.1. Message framework</a></li>
<li><a href="#_polymorphic_handlers_stdfunction_alternative">2.2. Polymorphic handlers (<code>std::function</code> alternative)</a></li>
<li><a href="#parsing_tutorial1">2.3. Parsing (beginner)</a></li>
<li><a href="#parsing_tutorial2">2.4. Parsing (advanced)</a></li>
<li><a href="#parsing_tutorial3">2.5. Parsing HTTP upgrade</a></li>
<li><a href="#_implementing_boost_beast_parser_interface">2.6. Implementing Boost.Beast parser interface</a></li>
</ul>
</li>
<li><a href="#design_choices">3. Design choices</a>
<ul class="sectlevel2">
<li><a href="#_faq">3.1. FAQ</a></li>
<li><a href="#_design_choices">3.2. Design choices</a></li>
<li><a href="#_roadmap">3.3. Roadmap</a></li>
</ul>
</li>
<li><a href="#_reference">4. Reference</a>
<ul class="sectlevel2">
<li><a href="#_summary">4.1. Summary</a></li>
<li><a href="#_detailed">4.2. Detailed</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" class="bare">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
</div>
<div class="paragraph">
<p>This library can be used to create applications that need to expose services
through HTTP (e.g. embeddable ReST services).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This is not an official Boost C++ library. It wasn&#8217;t reviewed and can&#8217;t
be downloaded from
www.boost.org. <a href="http://www.boost.org/community/review_schedule.html">This library
will be reviewed eventually</a>.
</td>
</tr>
</table>
</div>
<hr>
<div class="paragraph">
<p>Conceptually Boost.Http is a Boost.Asio socket for HTTP, which means can
leverage Boost.Asio features such as SSL and coroutines, and it integrates
seemlessly with other Boost.Asio sockets.</p>
</div>
<div class="paragraph">
<p>Among its features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Support for modern HTTP features.</p>
<div class="ulist">
<ul>
<li>
<p>Pipelining and persistent connection, where the same connection can be used
to serve HTTP multiple requests.</p>
</li>
<li>
<p>Chunking, where the HTTP body can be split into smaller pieces that are sent
one by one. This is useful for building event listeners.</p>
</li>
<li>
<p>Upgrading, where the HTTP protocol can be changed into another protocol such
as WebSockets.</p>
</li>
<li>
<p>Security, where SSL is used to encrypt the traffic.</p>
</li>
<li>
<p><code>100-continue</code> status.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Lean API that unifies HTTP messages and HTTP chunking.</p>
<div class="ulist">
<ul>
<li>
<p>You can handle the request as soon as the metadata is available (request line
plus header section).</p>
</li>
<li>
<p>There is only one API to acquire the request body. This API allows
progressive downloading.</p>
</li>
<li>
<p>The response body can be be generated wholesale for normal HTTP responses, or
be split into smaller pieces using HTTP chunking.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Extensible asynchronous design inherited from ASIO.</p>
<div class="ulist">
<ul>
<li>
<p>Interaction via futures, coroutines, or callbacks.</p>
</li>
<li>
<p>Various HTTP server architectures are possible, whether multi-threaded
servers (one thread per request, either with or without a thread-pool), one
coroutine per request, or completely single-threaded.</p>
</li>
<li>
<p>Seamless integration with other non-HTTP ASIO services.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Boost.Http also provides the best HTTP parsing abstractions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple.</p>
</li>
<li>
<p>Portable (C++03 and very few other dependencies).</p>
</li>
<li>
<p>Just like Ryan Dahl&#8217;s HTTP parser, this parser does not make any syscalls or
allocations. It also does not buffer data.</p>
</li>
<li>
<p>You can mutate the passed buffer <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</li>
<li>
<p>It doesn&#8217;t steal control flow from your application <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>. Great for HTTP
pipelining.</p>
</li>
<li>
<p>Matching and decoding tokens as separate steps <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Boost.Http also provides a couple of special-purpose server classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lightweight standalone server.</p>
<div class="ulist">
<ul>
<li>
<p>The underlying socket type is customizable, so you can also use a
<code>queue_socket</code> <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup><sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Flexible static file server with support for conditional requests, partial
download and ETag recognition.</p>
<div class="ulist">
<ul>
<li>
<p>You can use the default file resolver or provide one yourself.</p>
</li>
<li>
<p>You can adapt the default resolver.</p>
</li>
<li>
<p>You can add a last hook to customize the response message before the file is
served.</p>
</li>
<li>
<p>Stateless abstractions, relying on OS capabilities to provide cache.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Boost.Http has been designed for multiple backends, such HTTP/2, and FastGCI,
which can be added in the future. You can choose between compile-time and
runtime polymorphism. Adapters are provided.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using">1. Using</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_requirements">1.1. Requirements</h3>
<div class="paragraph">
<p>This library is written in C++11 and requires a C++11 supporting compiler.</p>
</div>
<div class="paragraph">
<p>This library tries to reuse standard library components when possible, but this
is not always the case. <code>std::error_code</code>, for instance, cannot be transparently
replaced by <code>boost::system::error_code</code> within ASIO-using code.</p>
</div>
<div class="paragraph">
<p>The full list of dependencies is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CMake 3.1.0 or newer <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>. You can skip this requirement if
you don&#8217;t intend to run the tests.</p>
</li>
<li>
<p>Boost 1.66 or newer.</p>
<div class="ulist">
<ul>
<li>
<p>algorithm, container, string_view, ASIO, date_time and system <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>.</p>
</li>
<li>
<p>unit_test_framework <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>.</p>
</li>
<li>
<p>context and coroutine <sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>.</p>
</li>
<li>
<p>filesystem <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="http://asciidoctor.org/">asciidoctor</a>,
<a href="https://github.com/asciidoctor/asciidoctor-diagram/">asciidoctor-diagram</a>,
<a href="http://plantuml.com/">PlantUML</a> and <a href="https://kevinpt.github.io/syntrax/">syntrax</a>
<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>. You&#8217;ll also need <a href="http://pandoc.org/">pandoc</a>
if you want to generate the ePUB output.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tutorial">2. Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_message_framework">2.1. Message framework</h3>
<div class="paragraph">
<p>In this tutorial, you&#8217;ll have a small and fast introduction to HTTP (if you&#8217;re
already familiar with HTTP, you can skip the associated section and it&#8217;s more
likely you&#8217;ll deeply understand Boost.Http faster). You&#8217;ll also learn
incrementally how to build a proper handling of HTTP requests using Boost.Http.</p>
</div>
<div class="paragraph">
<p>A second step would be how to organize your application and make an useful
application, but this second step is left for the user to tackle alone.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This tutorial assumes you&#8217;re already familiar with ASIO!
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This tutorial will make use of coroutines, to increase readability like
nothing else could do. You might be interested in the use of alternative
asynchronous models to achieve lower memory usage or something else. When C++
adds proper support for coroutines, this will not only be the most readable way,
but also the most performant.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_http">2.1.1. HTTP</h4>
<div class="paragraph">
<p>HTTP is a protocol that shines in extensibility. Its <code>1.1</code> version has been used
unchanged since 1997 and has been able to power very creative applications to
this date. An <code>HTTP/2.0</code> standard has been released, but most of the
differencies are related to efficient connection management and the only feature
that can affect higher-level layers of an application making use of HTTP is the
HTTP push, which is used to speculatively send data to a client that the server
anticipates the client will need.</p>
</div>
<div class="paragraph">
<p>HTTP also provides means to upgrade a protocol for a running connection and the
WebSocket protocol is gaining importance where HTTP is used the most, in the
web.</p>
</div>
<div class="paragraph">
<p>HTTP is a protocol that is oriented to exchange of request and reply
messages. Each request is independent, hence the stateless nature of the
protocol. Each request has an associated verb and path, used to tell <strong>what</strong> do
to <strong>who</strong>. Every HTTP message has a body (a payload of binary data) and
associated metadata (i.e. a <code>multimap&lt;string, string&gt;</code>). The HTTP response also
has a status code associated which is used to indicate success of the requested
action.</p>
</div>
<div class="paragraph">
<p>The metadata carried in every HTTP message is named as HTTP headers. The HTTP
headers carry information on how to handle the data payload, with info such as
the mime type, language and more. HTTP request messages can contain a token
which is used to associate multiple different requests with the same client, so
the user doesn&#8217;t need to type username and password for every page request.</p>
</div>
<div class="paragraph">
<p>GET is the most common HTTP verb and it has the simple semantic to retrieve the
resource.</p>
</div>
<div class="paragraph">
<p>If you just want to expose a bunch of files from the local filesystem, you may
be interested in <a href="#async_response_transmit_dir"><code>async_response_transmit_dir</code></a>,
which will take several responsibilities from you (e.g. partial download and a
few basic mechanisms to avoid corrupt files).</p>
</div>
<div class="paragraph">
<p>The usual setup for an HTTP application is to parse the request URL and choose
an appropriate handler based on the path component. Optional middleware handlers
can do some ACL based on authentication, resource usage and so on. An auxiliar
database is almost always used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_accepting_new_connections">2.1.2. Accepting new connections</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Remember, the journey of a thousand miles begins with the first step.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>First, we&#8217;re going to write the boilerplate code Asio require us to write if we
want use stackful coroutines to handle a non predetermined number of concurrent
connections.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/spawn.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/buffered_socket.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">std</span><span class="tok-p">;</span>
<span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">boost</span><span class="tok-p">;</span>

<span class="tok-k">class</span> <span class="tok-nc">connection</span><span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">enable_shared_from_this</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-kt">void</span> <span class="tok-k">operator</span><span class="tok-p">()(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">auto</span> <span class="tok-n">self</span> <span class="tok-o">=</span> <span class="tok-n">shared_from_this</span><span class="tok-p">();</span>
        <span class="tok-k">try</span> <span class="tok-p">{</span>
            <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;--</span><span class="tok-se">\n</span><span class="tok-s">[&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Socket ready&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
            <span class="tok-c1">// &gt;&gt;&gt; OUR CODE GOES HERE &lt;&lt;&lt;</span>
        <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">system_error</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">{</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">error</span><span class="tok-o">::</span><span class="tok-n">eof</span><span class="tok-p">})</span> <span class="tok-p">{</span>
                <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Aborting on exception: &quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>

            <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Error: &quot;</span>
                 <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exception</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Aborting on exception: &quot;</span>
                 <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
            <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">socket</span> <span class="tok-o">&amp;</span><span class="tok-n">tcp_layer</span><span class="tok-p">()</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">next_layer</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">shared_ptr</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span> <span class="tok-n">make_connection</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">,</span>
                                                       <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">shared_ptr</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span><span class="tok-p">{</span><span class="tok-k">new</span> <span class="tok-n">connection</span><span class="tok-p">{</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">}};</span>
    <span class="tok-p">}</span>

<span class="tok-k">private</span><span class="tok-o">:</span>
    <span class="tok-n">connection</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">)</span>
        <span class="tok-o">:</span> <span class="tok-n">socket</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">)</span>
        <span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">(</span><span class="tok-n">counter</span><span class="tok-p">)</span>
    <span class="tok-p">{}</span>

    <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">buffered_socket</span> <span class="tok-n">socket</span><span class="tok-p">;</span>
    <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ios</span><span class="tok-p">;</span>
    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">acceptor</span> <span class="tok-n">acceptor</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span>
                                     <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span>
                                     <span class="tok-o">::</span><span class="tok-n">endpoint</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">v6</span><span class="tok-p">(),</span> <span class="tok-mi">8080</span><span class="tok-p">));</span>

    <span class="tok-k">auto</span> <span class="tok-n">do_accept</span> <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-o">&amp;</span><span class="tok-n">acceptor</span><span class="tok-p">,</span><span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">](</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-kt">int</span> <span class="tok-n">counter</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
        <span class="tok-k">for</span> <span class="tok-p">(</span> <span class="tok-p">;</span> <span class="tok-nb">true</span> <span class="tok-p">;</span> <span class="tok-o">++</span><span class="tok-n">counter</span> <span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">try</span> <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">connection</span>
                    <span class="tok-o">=</span> <span class="tok-n">connection</span><span class="tok-o">::</span><span class="tok-n">make_connection</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">);</span>
                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to accept a new connection&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">async_accept</span><span class="tok-p">(</span><span class="tok-n">connection</span><span class="tok-o">-&gt;</span><span class="tok-n">tcp_layer</span><span class="tok-p">(),</span> <span class="tok-n">yield</span><span class="tok-p">);</span>

                <span class="tok-k">auto</span> <span class="tok-n">handle_connection</span>
                    <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-n">connection</span><span class="tok-p">](</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span> <span class="tok-k">mutable</span> <span class="tok-p">{</span>
                    <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-n">connection</span><span class="tok-p">)(</span><span class="tok-n">yield</span><span class="tok-p">);</span>
                <span class="tok-p">};</span>
                <span class="tok-n">spawn</span><span class="tok-p">(</span><span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">get_executor</span><span class="tok-p">(),</span> <span class="tok-n">handle_connection</span><span class="tok-p">);</span>
            <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exception</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Aborting on exception: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
        <span class="tok-p">}</span>
    <span class="tok-p">};</span>

    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to schedule new connections acceptance&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">spawn</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">do_accept</span><span class="tok-p">);</span>

    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to run the I/O scheduler/executor&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">ios</span><span class="tok-p">.</span><span class="tok-n">run</span><span class="tok-p">();</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Summarizing, we make use of <code>shared_ptr</code> to alloc object and ensure it&#8217;ll stay
alive as long as there is some reference to it and we spawn an acceptor
algorithm who will create a <code>shared_ptr</code> for every connection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">socket</span> <span class="tok-o">&amp;</span><span class="tok-n">connection</span><span class="tok-o">::</span><span class="tok-n">tcp_layer</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">next_layer</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>basic_buffered_socket&lt;T&gt;::next_layer()</code> member-function will return the
internal T object. The <code>buffered_socket</code> typedef uses <code>asio::ip::tcp::socket</code> as
<code>T</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">spawn</span><span class="tok-p">(</span><span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">get_executor</span><span class="tok-p">(),</span> <span class="tok-n">handle_connection</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We spawn a new handler for every connection, so we&#8217;ll be able to handle them all
concurrently.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">auto</span> <span class="tok-n">self</span> <span class="tok-o">=</span> <span class="tok-n">shared_from_this</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We must create a reference to the <code>shared_ptr</code> before calling any asynchronous
function to ensure the object will be live as long as the coroutine.</p>
</div>
</div>
<div class="sect3">
<h4 id="_receiving_requests">2.1.3. Receiving requests</h4>
<div class="paragraph">
<p>You can find the whole code at the end of the secion. For now, we build upon the
code from the previous code (just replace the “our code goes” here comment with
the code we&#8217;ll build in this section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">is_open</span><span class="tok-p">())</span> <span class="tok-p">{</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So, the first thing you should do is loop while the socket is open, so the whole
pipelining of requests will be handled. If the connection closes ungracefully,
an error code will be generated (converted to exceptions by the coroutine
completion token) during one of the operations. If the connection closes
gracefully, the loop will eventually stop by <code>is_open()</code> returning <code>false</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_request</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So, the first part to actually handle is to ask for the request message. You&#8217;ll
get the full method and path by the time the completion handler is called (in
the case of coroutines, this means the next line of code). You must not touch
any of these variables while the operation is in progress (hard to get it wrong
if you&#8217;re using coroutines). <code>self&#8594;request&#8594;headers()</code> will also be filled and
whatever part of the body that has already been received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">read_state</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
    <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">read_state</span><span class="tok-p">())</span> <span class="tok-p">{</span>
    <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-nl">message_ready</span><span class="tok-p">:</span>
        <span class="tok-c1">// ...</span>
        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_some</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
        <span class="tok-k">break</span><span class="tok-p">;</span>
    <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-nl">body_ready</span><span class="tok-p">:</span>
        <span class="tok-c1">// ...</span>
        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_trailers</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
        <span class="tok-k">break</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>self&#8594;socket.read_state()</code> to know which part of the request is
still missing and ask for the rest.</p>
</div>
<div class="paragraph">
<p>But there is a little gotcha. You should send a <code>100-continue</code> to ask for the
rest of the body if required. This feature appeared first in <code>HTTP/1.1</code> as a
mean to better use network traffic, by allowing you to reject requests sooner.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">request_continue_required</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">))</span> <span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
    <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_write_response_continue</span><span class="tok-p">(</span><span class="tok-n">yield</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is how we check if we should send <code>100-continue</code>. It must be done after
<code>async_read_request</code> and before <code>async_read_some</code>.</p>
</div>
<div class="paragraph">
<p>By this time, we have already fully received the request and we can do something
with it. Pretty easy, see?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">response</span> <span class="tok-n">reply</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The response message we&#8217;re about to send.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">body</span><span class="tok-p">{</span><span class="tok-s">&quot;Hello World from </span><span class="tok-se">\&quot;</span><span class="tok-s">&quot;</span><span class="tok-p">};</span>
<span class="tok-n">body</span> <span class="tok-o">+=</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">target</span><span class="tok-p">();</span>
<span class="tok-n">body</span> <span class="tok-o">+=</span> <span class="tok-s">&quot;</span><span class="tok-se">\&quot;\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">copy</span><span class="tok-p">(</span><span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">begin</span><span class="tok-p">(),</span> <span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">(),</span>
          <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">back_inserter</span><span class="tok-p">(</span><span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">()));</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We feed some bytes to the body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">status_code</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-mi">200</span><span class="tok-p">;</span>
<span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">reason_phrase</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-s">&quot;OK&quot;</span><span class="tok-p">;</span>
<span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_write_response</span><span class="tok-p">(</span><span class="tok-n">reply</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And then we send the response. Our application is complete.</p>
</div>
<div class="paragraph">
<p>There is a gotcha here. If you use pure <code>asio::ip::tcp::socket</code>, you&#8217;re subject
to Asio composed operations restrictions and you should not schedule any
operation while the previous one is in progress. You can wrap
<code>asio::ip::tcp::socket</code> into some queuing socket <sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> to work around this bug and Boost.Http will give you the
required customization points to allow you to use it. We don&#8217;t worry about this
problem here, because with coroutines we&#8217;re done.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">we_are_halting</span><span class="tok-p">())</span>
    <span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">headers</span><span class="tok-p">().</span><span class="tok-n">emplace</span><span class="tok-p">(</span><span class="tok-s">&quot;connection&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;close&quot;</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we&#8217;re going to halt the server and want to gracefully close current
connections, this code can be used to close the HTTP pipeline after the current
response end. You should pay attention to safe and idempotent methods if you
want to learn more about HTTP pipelining and HTTP in general.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">().</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">// free unused resources</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Given we&#8217;re consuming the body, it&#8217;s a good idea to free unused resources. We
don&#8217;t use C++11&#8217;s <code>shrink_to_fit</code> because it could trigger another reallocation
in the next piece of body received. The idea is to reuse a small allocated
buffer instead. You could also create your own message type to discard feeded
bytes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">async_accept</span><span class="tok-p">(</span><span class="tok-n">connection</span><span class="tok-o">-&gt;</span><span class="tok-n">tcp_layer</span><span class="tok-p">(),</span> <span class="tok-n">yield</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP doesn&#8217;t require you to handle protocol negotiation separately from the
remaining protocol or any super special handshaking flow. Therefore, we use a
“naked” acceptor to fuel an usable HTTP socket. Other HTTP backends may have
different usage.</p>
</div>
<div class="paragraph">
<p>And, like I promised, here is the complete code (with a lot of print statements
and a few lines to demonstrate more usage):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/spawn.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/buffered_socket.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/query.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/request.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/response.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">std</span><span class="tok-p">;</span>
<span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">boost</span><span class="tok-p">;</span>

<span class="tok-kt">bool</span> <span class="tok-nf">we_are_halting</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-k">class</span> <span class="tok-nc">connection</span><span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">enable_shared_from_this</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-kt">void</span> <span class="tok-k">operator</span><span class="tok-p">()(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">auto</span> <span class="tok-n">self</span> <span class="tok-o">=</span> <span class="tok-n">shared_from_this</span><span class="tok-p">();</span>
        <span class="tok-k">try</span> <span class="tok-p">{</span>
            <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;[&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Socket ready&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
            <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">is_open</span><span class="tok-p">())</span> <span class="tok-p">{</span>
                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;--</span><span class="tok-se">\n</span><span class="tok-s">[&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] About to receive a new message&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_request</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
                <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">().</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">// free unused resources</span>

                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">request_continue_required</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">))</span> <span class="tok-p">{</span>
                    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span>
                         <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Continue required. About to send&quot;</span>
                        <span class="tok-s">&quot; </span><span class="tok-se">\&quot;</span><span class="tok-s">100-continue</span><span class="tok-se">\&quot;</span><span class="tok-s">&quot;</span>
                         <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
                    <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_write_response_continue</span><span class="tok-p">(</span><span class="tok-n">yield</span><span class="tok-p">);</span>
                <span class="tok-p">}</span>

                <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">read_state</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-n">empty</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span>
                         <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Message not fully received&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                    <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">read_state</span><span class="tok-p">())</span> <span class="tok-p">{</span>
                    <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-nl">message_ready</span><span class="tok-p">:</span>
                        <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span>
                             <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] About to receive some body&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_some</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
                        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">().</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">// free unused resources</span>
                        <span class="tok-k">break</span><span class="tok-p">;</span>
                    <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">read_state</span><span class="tok-o">::</span><span class="tok-nl">body_ready</span><span class="tok-p">:</span>
                        <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span>
                             <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] About to receive trailers&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_read_trailers</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
                        <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">().</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">// free unused resources</span>
                        <span class="tok-k">break</span><span class="tok-p">;</span>
                    <span class="tok-k">default</span><span class="tok-o">:</span><span class="tok-p">;</span>
                    <span class="tok-p">}</span>
                <span class="tok-p">}</span>

                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Message received. State = &quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-kt">int</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">read_state</span><span class="tok-p">())</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Method: &quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">method</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Path: &quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">target</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-p">{</span>
                    <span class="tok-k">auto</span> <span class="tok-n">host</span> <span class="tok-o">=</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">headers</span><span class="tok-p">().</span><span class="tok-n">find</span><span class="tok-p">(</span><span class="tok-s">&quot;host&quot;</span><span class="tok-p">);</span>
                    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">host</span> <span class="tok-o">!=</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">headers</span><span class="tok-p">().</span><span class="tok-n">end</span><span class="tok-p">())</span>
                        <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Host header: &quot;</span>
                             <span class="tok-o">&lt;&lt;</span> <span class="tok-n">host</span><span class="tok-o">-&gt;</span><span class="tok-n">second</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-p">}</span>

                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Write state = &quot;</span>
                          <span class="tok-o">&lt;&lt;</span> <span class="tok-kt">int</span><span class="tok-p">(</span><span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">write_state</span><span class="tok-p">())</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] About to send a reply&quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>

                <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">response</span> <span class="tok-n">reply</span><span class="tok-p">;</span>

                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">we_are_halting</span><span class="tok-p">())</span>
                    <span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">headers</span><span class="tok-p">().</span><span class="tok-n">emplace</span><span class="tok-p">(</span><span class="tok-s">&quot;connection&quot;</span><span class="tok-p">,</span> <span class="tok-s">&quot;close&quot;</span><span class="tok-p">);</span>

                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">body</span><span class="tok-p">{</span><span class="tok-s">&quot;Hello World from </span><span class="tok-se">\&quot;</span><span class="tok-s">&quot;</span><span class="tok-p">};</span>
                <span class="tok-n">body</span> <span class="tok-o">+=</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">request</span><span class="tok-p">.</span><span class="tok-n">target</span><span class="tok-p">();</span>
                <span class="tok-n">body</span> <span class="tok-o">+=</span> <span class="tok-s">&quot;</span><span class="tok-se">\&quot;\n</span><span class="tok-s">&quot;</span><span class="tok-p">;</span>
                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">copy</span><span class="tok-p">(</span><span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">begin</span><span class="tok-p">(),</span> <span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">(),</span>
                          <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">back_inserter</span><span class="tok-p">(</span><span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">body</span><span class="tok-p">()));</span>

                <span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">status_code</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-mi">200</span><span class="tok-p">;</span>
                <span class="tok-n">reply</span><span class="tok-p">.</span><span class="tok-n">reason_phrase</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-s">&quot;OK&quot;</span><span class="tok-p">;</span>
                <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">async_write_response</span><span class="tok-p">(</span><span class="tok-n">reply</span><span class="tok-p">,</span> <span class="tok-n">yield</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
        <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">system_error</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">{</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">error</span><span class="tok-o">::</span><span class="tok-n">eof</span><span class="tok-p">})</span> <span class="tok-p">{</span>
                <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Aborting on exception: &quot;</span>
                     <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>

            <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Error: &quot;</span>
                 <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exception</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-sc">&#39;[&#39;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">self</span><span class="tok-o">-&gt;</span><span class="tok-n">counter</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;] Aborting on exception: &quot;</span>
                 <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
            <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
        <span class="tok-p">}</span>
    <span class="tok-p">}</span>

    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">socket</span> <span class="tok-o">&amp;</span><span class="tok-n">tcp_layer</span><span class="tok-p">()</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">next_layer</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">shared_ptr</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span> <span class="tok-n">make_connection</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">,</span>
                                                       <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">shared_ptr</span><span class="tok-o">&lt;</span><span class="tok-n">connection</span><span class="tok-o">&gt;</span><span class="tok-p">{</span><span class="tok-k">new</span> <span class="tok-n">connection</span><span class="tok-p">{</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">}};</span>
    <span class="tok-p">}</span>

<span class="tok-k">private</span><span class="tok-o">:</span>
    <span class="tok-n">connection</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">)</span>
        <span class="tok-o">:</span> <span class="tok-n">socket</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">)</span>
        <span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">(</span><span class="tok-n">counter</span><span class="tok-p">)</span>
    <span class="tok-p">{}</span>

    <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">buffered_socket</span> <span class="tok-n">socket</span><span class="tok-p">;</span>
    <span class="tok-kt">int</span> <span class="tok-n">counter</span><span class="tok-p">;</span>

    <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">request</span> <span class="tok-n">request</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ios</span><span class="tok-p">;</span>
    <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">acceptor</span> <span class="tok-n">acceptor</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span>
                                     <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span>
                                     <span class="tok-o">::</span><span class="tok-n">endpoint</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">v6</span><span class="tok-p">(),</span> <span class="tok-mi">8080</span><span class="tok-p">));</span>

    <span class="tok-k">auto</span> <span class="tok-n">do_accept</span> <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-o">&amp;</span><span class="tok-n">acceptor</span><span class="tok-p">,</span><span class="tok-o">&amp;</span><span class="tok-n">ios</span><span class="tok-p">](</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-kt">int</span> <span class="tok-n">counter</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
        <span class="tok-k">for</span> <span class="tok-p">(</span> <span class="tok-p">;</span> <span class="tok-nb">true</span> <span class="tok-p">;</span> <span class="tok-o">++</span><span class="tok-n">counter</span> <span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">try</span> <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">connection</span>
                    <span class="tok-o">=</span> <span class="tok-n">connection</span><span class="tok-o">::</span><span class="tok-n">make_connection</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">counter</span><span class="tok-p">);</span>
                <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to accept a new connection&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">async_accept</span><span class="tok-p">(</span><span class="tok-n">connection</span><span class="tok-o">-&gt;</span><span class="tok-n">tcp_layer</span><span class="tok-p">(),</span> <span class="tok-n">yield</span><span class="tok-p">);</span>

                <span class="tok-k">auto</span> <span class="tok-n">handle_connection</span>
                    <span class="tok-o">=</span> <span class="tok-p">[</span><span class="tok-n">connection</span><span class="tok-p">](</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">yield_context</span> <span class="tok-n">yield</span><span class="tok-p">)</span> <span class="tok-k">mutable</span> <span class="tok-p">{</span>
                    <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-n">connection</span><span class="tok-p">)(</span><span class="tok-n">yield</span><span class="tok-p">);</span>
                <span class="tok-p">};</span>
                <span class="tok-n">spawn</span><span class="tok-p">(</span><span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">get_executor</span><span class="tok-p">(),</span> <span class="tok-n">handle_connection</span><span class="tok-p">);</span>
            <span class="tok-p">}</span> <span class="tok-k">catch</span> <span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exception</span> <span class="tok-o">&amp;</span><span class="tok-n">e</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                <span class="tok-n">cerr</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;Aborting on exception: &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">e</span><span class="tok-p">.</span><span class="tok-n">what</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
                <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">exit</span><span class="tok-p">(</span><span class="tok-mi">1</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
        <span class="tok-p">}</span>
    <span class="tok-p">};</span>

    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to schedule new connections acceptance&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">spawn</span><span class="tok-p">(</span><span class="tok-n">ios</span><span class="tok-p">,</span> <span class="tok-n">do_accept</span><span class="tok-p">);</span>

    <span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;About to run the I/O scheduler/executor&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">ios</span><span class="tok-p">.</span><span class="tok-n">run</span><span class="tok-p">();</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_chunked_messages">2.1.4. Using chunked messages</h4>
<div class="paragraph">
<p>In the previous example, we used atomic messages to respond the request. But
this is limiting when we&#8217;re trying to achieve certain kind of tasks, like
serving a live video stream. A second option for us is to use chunked messages
to respond the request.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Chunked messages are not always available and you must check if you can
use chunked messages for every request with the <code>write_response_native_stream()</code>
socket member-function.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If chunked messages are available, you can use the following sequence of actions
to respond the request:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>async_write_response_metadata</code> once.</p>
</li>
<li>
<p><code>async_write</code> zero or more times.</p>
</li>
<li>
<p><code>async_write_trailers</code> or <code>async_write_end_of_message</code>, once.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_runtime_based_polymorphic_abstractions">2.1.5. Runtime-based polymorphic abstractions</h4>
<div class="paragraph">
<p>If you want to create a function that will handle requests originated from
different HTTP backends, you have three choices:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rewrite the handler for every HTTP backend.</p>
</li>
<li>
<p>Write generic handlers.</p>
</li>
<li>
<p>Type-erase the HTTP backends.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Boost.Http provide some abstractions to type erase the HTTP backends (playing a
similar role to <code>std::function</code>). The starting point to learn about it is the
<a href="#server_socket_adaptor"><code>server_socket_adaptor</code> page</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-nf">handler</span><span class="tok-p">(</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">poly_server_socket</span> <span class="tok-o">&amp;</span><span class="tok-n">socket</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>
<span class="tok-p">}</span>

<span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">server_socket_adaptor</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">buffered_socket</span><span class="tok-o">&gt;</span>
    <span class="tok-n">socket</span><span class="tok-p">(</span><span class="tok-n">acceptor</span><span class="tok-p">.</span><span class="tok-n">get_executor</span><span class="tok-p">().</span><span class="tok-n">context</span><span class="tok-p">());</span>
<span class="tok-n">handler</span><span class="tok-p">(</span><span class="tok-n">socket</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_polymorphic_handlers_stdfunction_alternative">2.2. Polymorphic handlers (<code>std::function</code> alternative)</h3>
<div class="paragraph">
<p>Boost.Asio uses handlers with signatures similar to the following to notify
about the completion of tasks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you intend to wrap the template heavy usage of Boost.Asio behind a stable
interface that can be accessed through dynamically loaded plug-ins, you may be
tempted to use <code>std::function</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">class</span> <span class="tok-nc">my_socket</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-k">virtual</span> <span class="tok-o">~</span><span class="tok-n">my_socket</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-k">default</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-nf">async_write_some</span><span class="tok-p">(</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">const_buffer</span> <span class="tok-n">buf</span><span class="tok-p">,</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">function</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span><span class="tok-p">)</span><span class="tok-o">&gt;</span> <span class="tok-n">handler</span>
    <span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-nf">async_read_some</span><span class="tok-p">(</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-kt">char</span><span class="tok-o">&gt;</span> <span class="tok-o">&amp;</span><span class="tok-n">buf</span><span class="tok-p">,</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">function</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span><span class="tok-p">)</span><span class="tok-o">&gt;</span> <span class="tok-n">handler</span>
    <span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">void</span> <span class="tok-nf">work</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>

    <span class="tok-k">auto</span> <span class="tok-n">handle_socket</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">dll</span><span class="tok-o">::</span><span class="tok-n">import</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">shared_ptr</span><span class="tok-o">&lt;</span><span class="tok-n">my_socket</span><span class="tok-o">&gt;</span><span class="tok-p">)</span><span class="tok-o">&gt;</span><span class="tok-p">(</span>
        <span class="tok-n">path_to_shared_library</span><span class="tok-p">,</span> <span class="tok-s">&quot;handle_socket&quot;</span>
    <span class="tok-p">);</span>

    <span class="tok-c1">// ...</span>

    <span class="tok-k">for</span> <span class="tok-p">(;;)</span> <span class="tok-p">{</span>
        <span class="tok-c1">// ...</span>

        <span class="tok-n">handle_socket</span><span class="tok-p">(</span><span class="tok-n">sock</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this approach is wrong. <code>std::function</code> does type erasure of functors,
but it won&#8217;t do type erasure of associated allocators and associated executors
which are a core part of Boost.Asio. This extra information will be discarded.</p>
</div>
<div class="paragraph">
<p>If there is an associated executor with a completion handler, this associated
executor should be used and propagated by every intermediate handler in the
chain.</p>
</div>
<div class="paragraph">
<p>If I try the following, the propagation will stop at the <code>my_socket</code> boundary as
<code>std::function</code> discards the associated executor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-nf">work</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// ...</span>

    <span class="tok-k">auto</span> <span class="tok-n">handler</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">bind_executor</span><span class="tok-p">(</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span><span class="tok-o">::</span><span class="tok-n">strand</span><span class="tok-p">{</span><span class="tok-n">ctx</span><span class="tok-p">},</span>
        <span class="tok-p">[](</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span><span class="tok-p">)</span> <span class="tok-p">{}</span>
    <span class="tok-p">);</span>

    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">async_write</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-n">sock</span><span class="tok-p">,</span> <span class="tok-n">handler</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One way to verify this assertion is with a simple test case. Create two
execution contexts, <code>ctx1</code> and <code>ctx2</code>. Post a handler to <code>ctx1</code> and then call
<code>ctx1.run()</code>. You should expect the handler to be called. Now modify <code>handler</code>
to be wrapped and associated with an executor from <code>ctx2</code>. If only this change
is done, you should expect the program to exit without ever calling the
handler. The following code illustrates this situation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/bind_executor.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/io_context.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/post.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx1</span><span class="tok-p">;</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx2</span><span class="tok-p">;</span>

    <span class="tok-k">auto</span> <span class="tok-n">handler</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">bind_executor</span><span class="tok-p">(</span>
        <span class="tok-n">ctx2</span><span class="tok-p">,</span>
        <span class="tok-p">[]()</span> <span class="tok-p">{</span>
            <span class="tok-c1">// won&#39;t happen</span>
            <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;handler called&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
    <span class="tok-p">);</span>

    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">post</span><span class="tok-p">(</span><span class="tok-n">ctx1</span><span class="tok-p">,</span> <span class="tok-n">handler</span><span class="tok-p">);</span>

    <span class="tok-n">ctx1</span><span class="tok-p">.</span><span class="tok-n">run</span><span class="tok-p">();</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you also change the code to call <code>ctx2.run()</code> after <code>ctx1.run()</code>, you should
expect the handler to be called. But this is just an exercise for the
reader. We&#8217;re sticking with the previous code of no handler called as the
desired behaviour. To be more specific, we&#8217;re interested in making sure that we
can <em>observe</em> that execution scheduling is done through a specific executor
(i.e. associated executors are respected). And, for this executor in particular,
the observed output is of no handler called.</p>
</div>
<div class="paragraph">
<p>If you wrap our handler within a <code>std::function</code> object, the associated
executors will be discarded and you should expect the handler to be called
again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;functional&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/bind_executor.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/io_context.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/post.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx1</span><span class="tok-p">;</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx2</span><span class="tok-p">;</span>

    <span class="tok-k">auto</span> <span class="tok-n">handler</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">bind_executor</span><span class="tok-p">(</span>
        <span class="tok-n">ctx2</span><span class="tok-p">,</span>
        <span class="tok-p">[]()</span> <span class="tok-p">{</span>
            <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;handler called&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
    <span class="tok-p">);</span>

    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">post</span><span class="tok-p">(</span><span class="tok-n">ctx1</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">function</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">()</span><span class="tok-o">&gt;</span><span class="tok-p">{</span><span class="tok-n">handler</span><span class="tok-p">});</span>

    <span class="tok-n">ctx1</span><span class="tok-p">.</span><span class="tok-n">run</span><span class="tok-p">();</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s why we provide <code>boost::http::asio::experimental::poly_handler</code> as an
alternative to <code>std::function</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/asio/experimental/poly_handler.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/bind_executor.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/io_context.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/asio/post.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx1</span><span class="tok-p">;</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">io_context</span> <span class="tok-n">ctx2</span><span class="tok-p">;</span>

    <span class="tok-k">auto</span> <span class="tok-n">handler</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">bind_executor</span><span class="tok-p">(</span>
        <span class="tok-n">ctx2</span><span class="tok-p">,</span>
        <span class="tok-p">[]()</span> <span class="tok-p">{</span>
            <span class="tok-c1">// won&#39;t happen</span>
            <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;handler called&quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
    <span class="tok-p">);</span>

    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">post</span><span class="tok-p">(</span>
        <span class="tok-n">ctx1</span><span class="tok-p">,</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">poly_handler</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">()</span><span class="tok-o">&gt;</span><span class="tok-p">{</span><span class="tok-n">handler</span><span class="tok-p">}</span>
    <span class="tok-p">);</span>

    <span class="tok-n">ctx1</span><span class="tok-p">.</span><span class="tok-n">run</span><span class="tok-p">();</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you call <code>boost::asio::get_associated_executor</code> on
<code>boost::http::asio::experimental::poly_handler</code>, you&#8217;ll get a type erased
(i.e. <code>boost::asio::executor</code>) executor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">auto</span> <span class="tok-n">phandler</span>
    <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">poly_handler</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">()</span><span class="tok-o">&gt;</span><span class="tok-p">{</span><span class="tok-n">handler</span><span class="tok-p">};</span>
<span class="tok-k">auto</span> <span class="tok-n">ex</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">get_associated_executor</span><span class="tok-p">(</span><span class="tok-n">phandler</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>poly_handler</code>, we can update the previous <code>my_socket</code> definition and make
the DLL boundary work properly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">class</span> <span class="tok-nc">my_socket</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-k">virtual</span> <span class="tok-o">~</span><span class="tok-n">my_socket</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-k">default</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-nf">async_write_some</span><span class="tok-p">(</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">const_buffer</span> <span class="tok-n">buf</span><span class="tok-p">,</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">poly_handler</span><span class="tok-o">&lt;</span>
            <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span><span class="tok-p">)</span>
        <span class="tok-o">&gt;</span> <span class="tok-n">handler</span>
    <span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-nf">async_read_some</span><span class="tok-p">(</span>
        <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-kt">char</span><span class="tok-o">&gt;</span> <span class="tok-o">&amp;</span><span class="tok-n">buf</span><span class="tok-p">,</span>
        <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">poly_handler</span><span class="tok-o">&lt;</span>
            <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span><span class="tok-p">)</span>
        <span class="tok-o">&gt;</span> <span class="tok-n">handler</span>
    <span class="tok-p">)</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>poly_handler</code> will also preserve the associated allocators as can be verified
with the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>

<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/asio/experimental/poly_handler.hpp&gt;</span><span class="tok-cp"></span>

<span class="tok-k">struct</span> <span class="tok-n">MyHandler</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-n">allocator_type</span> <span class="tok-o">=</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">polymorphic_allocator</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-o">&gt;</span><span class="tok-p">;</span>

    <span class="tok-n">MyHandler</span><span class="tok-p">(</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">memory_resource</span> <span class="tok-o">*</span><span class="tok-n">r</span><span class="tok-p">)</span>
        <span class="tok-o">:</span> <span class="tok-n">r</span><span class="tok-p">(</span><span class="tok-n">r</span><span class="tok-p">)</span>
    <span class="tok-p">{}</span>

    <span class="tok-kt">void</span> <span class="tok-k">operator</span><span class="tok-p">()()</span> <span class="tok-p">{}</span>

    <span class="tok-n">allocator_type</span> <span class="tok-n">get_allocator</span><span class="tok-p">()</span> <span class="tok-k">const</span>
    <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-p">{</span><span class="tok-n">r</span><span class="tok-p">};</span>
    <span class="tok-p">}</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">memory_resource</span> <span class="tok-o">*</span><span class="tok-n">r</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-k">auto</span> <span class="tok-n">r1</span> <span class="tok-o">=</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">new_delete_resource</span><span class="tok-p">();</span>
    <span class="tok-k">auto</span> <span class="tok-n">r2</span> <span class="tok-o">=</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">null_memory_resource</span><span class="tok-p">();</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">poly_handler</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-p">()</span><span class="tok-o">&gt;</span>
        <span class="tok-n">handler</span><span class="tok-p">{</span><span class="tok-n">MyHandler</span><span class="tok-p">{</span><span class="tok-n">r1</span><span class="tok-p">}};</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">experimental</span><span class="tok-o">::</span><span class="tok-n">pmr</span><span class="tok-o">::</span><span class="tok-n">polymorphic_allocator</span><span class="tok-o">&lt;</span><span class="tok-kt">void</span><span class="tok-o">&gt;</span> <span class="tok-n">fallback_a</span> <span class="tok-o">=</span> <span class="tok-n">r2</span><span class="tok-p">;</span>
    <span class="tok-k">auto</span> <span class="tok-n">a</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">get_associated_allocator</span><span class="tok-p">(</span><span class="tok-n">handler</span><span class="tok-p">,</span> <span class="tok-n">fallback_a</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;r1 = &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span><span class="tok-p">)(</span><span class="tok-n">r1</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;r2 = &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span><span class="tok-p">)(</span><span class="tok-n">r2</span><span class="tok-p">)</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-s">&quot;a = &quot;</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-p">(</span><span class="tok-kt">void</span><span class="tok-o">*</span><span class="tok-p">)(</span><span class="tok-n">a</span><span class="tok-p">.</span><span class="tok-n">resource</span><span class="tok-p">())</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>

    <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example, we associated the <code>MyHandler</code> object with <code>r1</code> just to wrap it
under <code>poly_handler</code>. Then we asked what was the associated allocator <code>a</code> and
passed <code>r2</code> as the fallback in case there was no such <code>a</code>. The expected output
would be for <code>r1</code> to be the same as <code>a</code>. And that&#8217;s just what you&#8217;ll see if you
run the example. If you want the example to fail (as in discarding the
associated allocator and showing a different output), just replace
<code>poly_handler</code> with <code>std::function</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you try to use an associated allocator whose type doesn&#8217;t match
<code>std::experimental::pmr::polymorphic_allocator&lt;T&gt;</code>, <code>poly_handler</code> will fail to
wrap it and it won&#8217;t compile. This behaviour is on purpose as we should not
silently discard associated properties. The reason why I don&#8217;t support other
types of allocators for associated allocators (fallback allocators passed to
<code>boost::asio::get_associated_allocator</code> can still be of different types) is
because they make little sense in a generic context such as ASIO&#8217;s and
implementation complexity.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="parsing_tutorial1">2.3. Parsing (beginner)</h3>
<div class="paragraph">
<p>In this tutorial, you&#8217;ll learn how to use this library to parse HTTP streams
easily.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We assume the reader has basic understanding of C++ and Boost.Asio.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We start with the code that should resemble the structure of the program you&#8217;re
about to code. And this structure is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/reader/request.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;string&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;map&gt;</span><span class="tok-cp"></span>

<span class="tok-k">namespace</span> <span class="tok-n">http</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-p">;</span>
<span class="tok-k">namespace</span> <span class="tok-n">asio</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-p">;</span>

<span class="tok-k">struct</span> <span class="tok-n">my_socket_consumer</span>
<span class="tok-p">{</span>
<span class="tok-k">private</span><span class="tok-o">:</span>
    <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">reader</span><span class="tok-o">::</span><span class="tok-n">request</span> <span class="tok-n">request_reader</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">buffer</span><span class="tok-p">;</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">last_header</span><span class="tok-p">;</span>

<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">method</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">request_target</span><span class="tok-p">;</span>
    <span class="tok-kt">int</span> <span class="tok-n">version</span><span class="tok-p">;</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">multimap</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-o">&gt;</span> <span class="tok-n">headers</span><span class="tok-p">;</span>

    <span class="tok-kt">void</span> <span class="tok-nf">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
        <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

        <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

        <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
                <span class="tok-c1">// do nothing</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
                <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
                <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
                <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
                <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-p">}</span>
            <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>

        <span class="tok-n">ready</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

<span class="tok-k">protected</span><span class="tok-o">:</span>
    <span class="tok-k">virtual</span> <span class="tok-kt">void</span> <span class="tok-n">ready</span><span class="tok-p">()</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;re building a piece of code that consumes HTTP from somewhere — the in — and
spits it out in the form of C++ structured data to somewhere else — the out.</p>
</div>
<div class="paragraph">
<p>The <em>in</em> of your program is connected to the above piece of code through the
<code>on_socket_callback</code> member function. The <em>out</em> of your program is connected to
the previous piece of code through the <code>ready</code> overrideable member-function.</p>
</div>
<div class="paragraph">
<p>By now I shouldn&#8217;t be worried about your understanding of how you&#8217;ll connect the
network I/O with the <em>in</em> of the program. The connection point is obvious
by now. However, I&#8217;ll briefly explain the <em>out</em> connection point and then we can
proceed to delve into the <em>inout</em>-inbetween (Danas) part of the program.</p>
</div>
<div class="paragraph">
<p>Once the <code>ready</code> member function is called, the data for your request will be
available in the <code>method</code>, <code>request_target</code> and the other <em>public</em>
variables. From now on, I&#8217;ll focus my attention to the sole implementation of
<code>my_socket_consumer::on_socket_callback</code>.</p>
</div>
<div class="listingblock">
<div class="title">The awaited prize</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-c1">//http::reader::request request_reader;</span>
    <span class="tok-c1">//std::string buffer;</span>
    <span class="tok-c1">//std::string last_header;</span>

    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-c1">// do nothing</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Try to keep in mind the three variables that will really orchestrate the flow:
<code>request_reader</code>, <code>buffer</code> and <code>last_header</code>.</p>
</div>
<div class="paragraph">
<p>The whole work is about managing the buffer and managing the tokens.</p>
</div>
<div class="paragraph">
<p>The token access is very easy. As the parser is incremental, there is only one
token at a time. I don&#8217;t need to explain Boost.Http control-flow because the
control flow will be coded by you (a library, not a framework). You only have to
use <code>code()</code> to check the current token and <code>value&lt;T&gt;()</code> to extract its value.
Use <code>next()</code> to advance a token.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>There is only one caveat. The parser doesn&#8217;t buffer data and will decode the
token into a value (the <code>value&lt;T&gt;()</code> member function) directly from the buffer
data.</p>
</div>
<div class="paragraph">
<p>This means you cannot extract the current value once you drop current buffer
data. As a nice side effect, you spare CPU time for the tokens you do not need
to decode (match&#8217;n&#8217;decoding as separate steps).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parser doesn&#8217;t buffer data, which means when we use the <code>set_buffer</code> member
function, <code>request_reader</code> only maintains a <strong>view</strong> to the passed buffer, which
we&#8217;ll refer to as the virtual buffer from now on.</p>
</div>
<div class="paragraph">
<p>In the virtual buffer, there is head/current and remaining/tail.
<code>request_reader</code> doesn&#8217;t store a pointer/address/index to the real buffer. Once
a token is consumed, his bytes (head) are discarded from the virtual
buffer. When you mutate the real buffer, the virtual buffer is invalidated and
you must inform the parser using <code>set_buffer</code>. However, the bytes discarded from
the virtual buffer shouldn&#8217;t appear again. You must keep track of the number of
discarded bytes to prepare the buffer to the next call to <code>set_buffer</code>. The
previous code doesn&#8217;t handle that.</p>
</div>
<div class="paragraph">
<p>The new tool that you should be presented now is <code>token_size()</code>. <code>token_size()</code>
will return the size in bytes of current/head.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
There is no guarantee <code>token_size()</code> returns the same size as returned
by <code>string_length(request_reader.value&lt;T&gt;())</code>. You <strong>need</strong> to use
<code>token_size()</code> to compute the number of discarded bytes.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-c1">//&lt; NEW</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-c1">// do nothing</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span> <span class="tok-c1">//&lt; NEW</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span> <span class="tok-c1">//&lt; NEW</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>nparsed</code> was easy. However, the <code>while(request_reader.code() !=
code::end_of_message)</code> doesn&#8217;t seem right. It&#8217;s very error-prone to assume the
full HTTP message will be ready in a single call to <code>on_socket_callback</code>. Error
handling must be introduced in the code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span> <span class="tok-c1">//&lt; NEW</span>
           <span class="tok-o">&amp;&amp;</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-c1">// do nothing</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">return</span><span class="tok-p">;</span> <span class="tok-c1">//&lt; NEW</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Don&#8217;t worry about <code>token_size(code::error_insufficient_data)</code> being added
to <code>nparsed</code>. This (error) "token" is defined to be 0-size (it fits perfectly
with the other rules).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Just because it&#8217;s easy and we&#8217;re already at it, let&#8217;s handle the other errors as
well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span>
           <span class="tok-o">&amp;&amp;</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_set_method</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_use_another_connection</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-c1">// Can only happen in response parsing code.</span>
            <span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-nb">false</span><span class="tok-p">);</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_invalid_data</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_no_host</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_invalid_content_length</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_content_length_overflow</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_invalid_transfer_encoding</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">error_chunk_size_overflow</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-k">throw</span> <span class="tok-s">&quot;invalid HTTP data&quot;</span><span class="tok-p">;</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-c1">// do nothing</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And buffer management is complete. However, the code only demonstrated how to
extract simple tokens. Field name and field value are simple tokens, but they
are usually tied together into a complex structure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span>
           <span class="tok-o">&amp;&amp;</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-c1">// ...</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_value</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-c1">// NEW</span>
            <span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">emplace</span><span class="tok-p">(</span><span class="tok-n">last_header</span><span class="tok-p">,</span>
                            <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>last_header</code> did the trick. Easy, but maybe we want to separate headers and
trailers (the HTTP headers that are sent <em>after</em> the message body). This task
can be accomplished by the use of structural tokens.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// NEW:</span>
    <span class="tok-c1">// We have to declare `bool my_socket_consumer::use_trailers = false` and</span>
    <span class="tok-c1">// `std::multimap&lt;std::string, std::string&gt; my_socket_consumer::trailers`.</span>

    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span>
           <span class="tok-o">&amp;&amp;</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-c1">// ...</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_value</span><span class="tok-p">:</span>
            <span class="tok-c1">// NEW</span>
            <span class="tok-p">(</span><span class="tok-n">use_trailers</span> <span class="tok-o">?</span> <span class="tok-nl">trailers</span> <span class="tok-p">:</span> <span class="tok-n">headers</span><span class="tok-p">)</span>
                <span class="tok-p">.</span><span class="tok-n">emplace</span><span class="tok-p">(</span><span class="tok-n">last_header</span><span class="tok-p">,</span>
                         <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">end_of_headers</span><span class="tok-p">:</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-n">use_trailers</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Maybe you had a gut feeling and thought that the previous code was too
strange. If <code>trailer_name</code> is a separate token, why don&#8217;t we use
<code>request_reader.value&lt;token::trailer_name&gt;()</code> (same to <code>trailer_value</code>) and go
away with structural tokens?</p>
</div>
<div class="paragraph">
<p>Yes, I unnecessarily complicated the code here to introduce you the concept of
structural tokens. They are very important and usually you&#8217;ll end up using
them. Maybe this tutorial needs some revamping after the library evolved a few
times.</p>
</div>
<div class="paragraph">
<p>Also notice that here you can use either
<code>request_reader.value&lt;token::field_name&gt;()</code> or
<code>request_reader.value&lt;token::trailer_name&gt;()</code> to extract this token value. It is
as if <code>trailer_name</code> is “implicitly convertible” to <code>field_name</code>, so to speak.
This feature makes the life of users who don&#8217;t need to differentiate headers and
trailers much easier (with no drawback to the users who do need to differentiate
them).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some of the structural tokens' properties are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No <code>value&lt;T&gt;()</code> associated. <code>value&lt;T&gt;()</code> extraction is a property exclusive of
the <em>data</em> tokens.</p>
</li>
<li>
<p>It might be 0-sized.</p>
</li>
<li>
<p>They are always emitted (e.g. <code>code::end_of_body</code> will be emitted before
<code>code::end_of_message</code> even if no <code>code::body_chunk</code> is present).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We were using the <code>code::end_of_message</code> structural token since the initial
version of the code, so they aren&#8217;t completely alien. However, we were ignoring
one very important HTTP parsing feature for this time. It&#8217;s the last missing bit
before your understanding to use this library is complete. Our current code
lacks the ability to handle HTTP pipelining.</p>
</div>
<div class="paragraph">
<p>HTTP pipelining is the feature that allows HTTP clients to send HTTP requests
“in batch”. In other words, they may send several requests at once over the same
connection before the server creates a response to them. If the previous code
faces this situation, it&#8217;ll stop parsing on the first request and possibly wait
forever until the <code>on_socket_callback</code> is called again with more data (yeap,
networking code can be hard with so many little details).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">my_socket_consumer</span><span class="tok-o">::</span><span class="tok-n">on_socket_callback</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">data</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">using</span> <span class="tok-k">namespace</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-p">;</span>
    <span class="tok-k">using</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">;</span>

    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">push_back</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">);</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span>

    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>

    <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span>
           <span class="tok-o">&amp;&amp;</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-c1">// ...</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">use_trailers</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">;</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">//&lt; NEW</span>
            <span class="tok-n">trailers</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span> <span class="tok-c1">//&lt; NEW</span>

            <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">request_target</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-n">version</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">trailer_value</span><span class="tok-p">:</span>
            <span class="tok-p">(</span><span class="tok-n">use_trailers</span> <span class="tok-o">?</span> <span class="tok-nl">trailers</span> <span class="tok-p">:</span> <span class="tok-n">headers</span><span class="tok-p">)</span>
                <span class="tok-p">.</span><span class="tok-n">emplace</span><span class="tok-p">(</span><span class="tok-n">last_header</span><span class="tok-p">,</span>
                         <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">end_of_headers</span><span class="tok-p">:</span>
            <span class="tok-n">use_trailers</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>

        <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
        <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">nparsed</span> <span class="tok-o">+=</span> <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
    <span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">request_reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>

    <span class="tok-n">ready</span><span class="tok-p">();</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">()</span> <span class="tok-o">&gt;</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-c1">//&lt; NEW</span>
        <span class="tok-n">on_socket_callback</span><span class="tok-p">();</span> <span class="tok-c1">//&lt; NEW</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are HTTP libraries that could adopt a “synchronous” approach where the
user must immediately give a HTTP response once the <code>ready()</code> callback is called
so the parsing code can parse the whole buffer until the end and we could just
put the <code>ready()</code> call into the <code>code::end_of_message</code> case.</p>
</div>
<div class="paragraph">
<p>There are HTTP libraries that follow ASIO active style and we expect the user to
call something like <code>async_read_request</code> before it can read the next request. In
this case, the solution for HTTP pipelining would be different.</p>
</div>
<div class="paragraph">
<p>There are libraries that don&#8217;t follow ASIO style, but don&#8217;t force the user to
send HTTP responses immediately on the <code>ready()</code> callback. In such cases,
synchronization/coordination of the response generation by the user and parse
resuming by the library is necessary.</p>
</div>
<div class="paragraph">
<p>This point can be rather diverse and the code for this tutorial only shows a
rather quick&#8217;n&#8217;dirty solution. Any different solution to keep the parsing train
at full-speed is left as an exercise to the reader.</p>
</div>
<div class="paragraph">
<p>The interesting point about the code here is to clear the state of the
<em>to-be-parsed</em> message before each request-response pair. In the previous code,
this was done binding the “method token arrived” event — the first token in a
HTTP request — with such state cleanup.</p>
</div>
<div class="paragraph">
<p>By now, you&#8217;re ready to use this library in your projects. You may want to check
Boost.Http own usage of the parser or the Tufão library as real-world and
complete examples of this parser.</p>
</div>
<div class="ulist">
<div class="title">See also</div>
<ul>
<li>
<p><a href="#request_response_diff">What are the differences between <code>reader::request</code> and
<code>reader::response</code>?</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="parsing_tutorial2">2.4. Parsing (advanced)</h3>
<div class="paragraph">
<p>In this tutorial, you&#8217;ll learn how to use this library to parse HTTP streams
easily.</p>
</div>
<div class="paragraph">
<p>The architecture of the library is broken into two classes of parsers, the
content parsers and the structural parsers.</p>
</div>
<div class="paragraph">
<p>The content parsers handle non-structural elements, terminal tokens, all easy to
match and decode. They are stateless. They are mini-parsers for elements easy to
parse and by themselves don&#8217;t add much value to justify a library (don&#8217;t confuse
<em>low value</em> with <em>valueless</em>). They live in the <code>boost::http::syntax</code>
namespace. They are useful when you want to parse individual HTTP elements like
the <code>range</code> header value. We won&#8217;t see them in this tutorial.</p>
</div>
<div class="paragraph">
<p>The structural parsers handle structured data formats (e.g. HTTP). To achieve
flexibility and performance requirements, they follow the incremental/pull
parser model (a bit like the more traditional Iterator design pattern as
described in the Gang-of-Four book, instead of C++ iterators). These parsers
live in the <code>boost::http::reader</code> namespace. These are the parsers we will look
into now.</p>
</div>
<div class="paragraph">
<p>In the future, we may add support for HTTP/2.0 stream format, but for now, we
are left with two structural parsers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boost::http::reader::request</code> for HTTP/1.0 and HTTP/1.1 request messages.</p>
</li>
<li>
<p><code>boost::http::reader::response</code> for HTTP/1.0 and HTTP/1.1 response messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each structural parser is prepared to receive a continuous stream of messages
(i.e. what NodeJS correctly refer to as keep-alive persistent streams). Because
the structure of messages is flexible enough to be non-representable in simple
non-allocating C++ structures, we don&#8217;t decode the whole stream as a single
parsing result as this would force allocation. What we do instead is to feed the
user with one token at a time and internally we keep a lightweight non-growing
state required to decode further tokens.</p>
</div>
<div class="paragraph">
<p>We use the same token definition for HTTP requests and HTTP responses. The
tokens can be either of status (e.g. <code>error</code> or <code>skip</code>), structural (e.g.
<code>boost::http::token::code::end_of_headers</code>) or data (e.g.
<code>boost::http::token::code::field_name</code>) categories. Only tokens of the data
category have an associated value.</p>
</div>
<div class="paragraph">
<p>Each token is associated with a slice (possibly 0-sized if <code>error</code> token or a
token from the structural category) of the byte stream. The process goes as
follow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set the buffer used by the reader.</p>
</li>
<li>
<p>Consume tokens.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Check <code>code()</code> return.</p>
</li>
<li>
<p>Possibly call <code>value&lt;T&gt;()</code> to extract token value.</p>
</li>
<li>
<p>Call <code>next()</code>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Remove parsed data from the buffer.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>You&#8217;ll need to keep state of parsed vs unparsed data by calling
<code>token_size()</code>.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If the address of the unparsed data changes, the reader is invalidated, so to
speak. You can restore its valid state by setting the buffer to null or to
the new address of the unparsed data.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Enough with abstract info. Take the following part of an HTTP stream:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>GET / HTTP/1.1\r\n
Host: www.example.com\r\n
\r\n</pre>
</div>
</div>
<div class="paragraph">
<p>This stream can be broken in the following series of tokens (order preserved):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>method</code>.</p>
</li>
<li>
<p><code>request_target</code>.</p>
</li>
<li>
<p><code>skip</code>.</p>
</li>
<li>
<p><code>version</code>.</p>
</li>
<li>
<p><code>field_name</code>.</p>
</li>
<li>
<p><code>field_value</code>.</p>
</li>
<li>
<p><code>skip</code>.</p>
</li>
<li>
<p><code>end_of_headers</code>.</p>
</li>
<li>
<p><code>end_of_body</code>.</p>
</li>
<li>
<p><code>end_of_message</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The parser is required to give you a <code>token_size()</code> so you can remove parsed
data from the stream. However, the parser is not required to give the same
series of tokens for the same stream. The strucutral and data tokens will always
be emitted the same. However, the parser may choose to merge some status token
(e.g.  <code>skip</code>) with a data token (e.g. <code>request_target</code>). Therefore, the
following series of tokens would also be possible for the same example given
previously:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>method</code>.</p>
</li>
<li>
<p><code>skip</code>.</p>
</li>
<li>
<p><code>request_target</code>.</p>
</li>
<li>
<p><code>version</code>.</p>
</li>
<li>
<p><code>field_name</code>.</p>
</li>
<li>
<p><code>skip</code>.</p>
</li>
<li>
<p><code>field_value</code>.</p>
</li>
<li>
<p><code>end_of_headers</code>.</p>
</li>
<li>
<p><code>end_of_body</code>.</p>
</li>
<li>
<p><code>end_of_message</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This (non-)guarantee is to give freedom to vary the implementation. It&#8217;d be
absurd to expect different implementations of this interface generating the same
result byte by byte. You may expect different algorithms also in future
versions.</p>
</div>
<div class="paragraph">
<p>Another useful feature of this non-guarantee is to make possible to discard
<code>skip</code> tokens in the buffer, but merge them if the stream is received in the
buffer at once.</p>
</div>
<div class="paragraph">
<p>Just imagine documenting the guarantees of the token stream if we were to make
it predictable. It&#8217;d be insane.</p>
</div>
<div class="paragraph">
<p>However, there is one guarantee that the reader object must provide. It must not
discard bytes of data tokens while the token is incomplete. To illustrate this
point, let&#8217;s go to an example. Given the current token is <code>request_target</code>, you
have the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">assert</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-p">);</span>
<span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>While we traverse the stream, the parser will only <em>match</em> tokens. We don&#8217;t
expect the parser to also <em>decode</em> the tokens. The parser will only decode the
tokens if necessary to further match the following tokens. And even when the
parser decod&#8217;em, the intermediary results may be discarded. In other words,
<em>match</em> and <em>decode</em> are separate steps and you can spare CPU time when you
don&#8217;t need to decode certain elements.</p>
</div>
<div class="paragraph">
<p>The point is that the token value must be extracted directly from the byte
stream and the parser is not allowed to buffer data about the stream (or the
decoded values, for that matter). The implication of this rule gives a guarantee
about the token order and its relationship to the bytem stream.</p>
</div>
<div class="paragraph">
<p>You can imagine the stream as having two views. The tokens and the byte
streams. The token view spans windows over the byte view.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tokens: | method | skip  | request_target | skip          | version
bytes:  |  GET   | &lt;SPC&gt; |     /          | &lt;SPC&gt; HTTP/1. | 1 &lt;CRLF&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The slice of data associated with a data token can grow larger than the
equivalent bytes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tokens: |  method    | request_target | skip  | version
bytes:  |  GET &lt;SPC&gt; |     /          | &lt;SPC&gt; | HTTP/1.1 &lt;CRLF&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>But it cannot shrink smaller than its associated bytes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tokens: | method | skip    | request_target | skip           | version
bytes:  |  GE    | T &lt;SPC&gt; |     /          | &lt;SPC&gt; HTTP/1.1 | &lt;CRLF&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>So you have a token interface easy to inspect and you have a lot of freedom to
manage the underlying buffer. Let&#8217;s see the <code>boost::http::reader::request</code>
parser as used in Tufão:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-n">HttpServerRequest</span><span class="tok-o">::</span><span class="tok-n">onReadyRead</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">timeout</span><span class="tok-p">)</span>
        <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">timer</span><span class="tok-p">.</span><span class="tok-n">start</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">timeout</span><span class="tok-p">);</span>

    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span> <span class="tok-o">+=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">readAll</span><span class="tok-p">();</span>
    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span>
                                         <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">()));</span>

    <span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">Signals</span> <span class="tok-n">whatEmit</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">);</span>
    <span class="tok-kt">bool</span> <span class="tok-n">is_upgrade</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">;</span>

    <span class="tok-k">while</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">symbol</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">error</span><span class="tok-p">:</span>
            <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">.</span><span class="tok-n">close</span><span class="tok-p">();</span>
            <span class="tok-k">return</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-n">clearRequest</span><span class="tok-p">();</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">responseOptions</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">QByteArray</span> <span class="tok-nf">method</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">method</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">QByteArray</span> <span class="tok-nf">url</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">url</span> <span class="tok-o">=</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">url</span><span class="tok-p">);</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">value</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">httpVersion</span> <span class="tok-o">=</span> <span class="tok-n">HttpVersion</span><span class="tok-o">::</span><span class="tok-n">HTTP_1_0</span><span class="tok-p">;</span>
                    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">responseOptions</span> <span class="tok-o">|=</span> <span class="tok-n">HttpServerResponse</span><span class="tok-o">::</span><span class="tok-n">HTTP_1_0</span><span class="tok-p">;</span>
                <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
                    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">httpVersion</span> <span class="tok-o">=</span> <span class="tok-n">HttpVersion</span><span class="tok-o">::</span><span class="tok-n">HTTP_1_1</span><span class="tok-p">;</span>
                    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">responseOptions</span> <span class="tok-o">|=</span> <span class="tok-n">HttpServerResponse</span><span class="tok-o">::</span><span class="tok-n">HTTP_1_1</span><span class="tok-p">;</span>
                <span class="tok-p">}</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">status_code</span><span class="tok-p">:</span>
            <span class="tok-n">qFatal</span><span class="tok-p">(</span><span class="tok-s">&quot;unreachable&quot;</span><span class="tok-p">);</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">reason_phrase</span><span class="tok-p">:</span>
            <span class="tok-n">qFatal</span><span class="tok-p">(</span><span class="tok-s">&quot;unreachable&quot;</span><span class="tok-p">);</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">lastHeader</span> <span class="tok-o">=</span> <span class="tok-n">QByteArray</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">QByteArray</span> <span class="tok-nf">header</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">insert</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">lastHeader</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">header</span><span class="tok-p">));</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">lastHeader</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">trailer_value</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">trailer_value</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">QByteArray</span> <span class="tok-nf">header</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">trailers</span><span class="tok-p">.</span><span class="tok-n">insert</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">lastHeader</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">header</span><span class="tok-p">));</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">lastHeader</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_headers</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">it</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">find</span><span class="tok-p">(</span><span class="tok-s">&quot;connection&quot;</span><span class="tok-p">);</span>
                <span class="tok-kt">bool</span> <span class="tok-n">close_found</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
                <span class="tok-kt">bool</span> <span class="tok-n">keep_alive_found</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
                <span class="tok-k">for</span> <span class="tok-p">(;</span><span class="tok-n">it</span> <span class="tok-o">!=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">end</span><span class="tok-p">();</span><span class="tok-o">++</span><span class="tok-n">it</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                    <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span><span class="tok-p">(</span><span class="tok-n">it</span><span class="tok-o">-&gt;</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">it</span><span class="tok-o">-&gt;</span><span class="tok-n">size</span><span class="tok-p">());</span>
                    <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">header_value_any_of</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">,</span> <span class="tok-p">[</span><span class="tok-o">&amp;</span><span class="tok-p">](</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">v</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;close&quot;</span><span class="tok-p">))</span>
                            <span class="tok-n">close_found</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>

                        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;keep-alive&quot;</span><span class="tok-p">))</span>
                            <span class="tok-n">keep_alive_found</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>

                        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;upgrade&quot;</span><span class="tok-p">))</span>
                            <span class="tok-n">is_upgrade</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>

                        <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
                    <span class="tok-p">});</span>
                    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">close_found</span><span class="tok-p">)</span>
                        <span class="tok-k">break</span><span class="tok-p">;</span>
                <span class="tok-p">}</span>
                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-o">!</span><span class="tok-n">close_found</span>
                    <span class="tok-o">&amp;&amp;</span> <span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">httpVersion</span> <span class="tok-o">==</span> <span class="tok-n">HttpVersion</span><span class="tok-o">::</span><span class="tok-n">HTTP_1_1</span>
                        <span class="tok-o">||</span> <span class="tok-n">keep_alive_found</span><span class="tok-p">))</span> <span class="tok-p">{</span>
                    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">responseOptions</span> <span class="tok-o">|=</span> <span class="tok-n">HttpServerResponse</span><span class="tok-o">::</span><span class="tok-n">KEEP_ALIVE</span><span class="tok-p">;</span>
                <span class="tok-p">}</span>
                <span class="tok-n">whatEmit</span> <span class="tok-o">=</span> <span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">READY</span><span class="tok-p">;</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">body_chunk</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">body_chunk</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">append</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer_cast</span><span class="tok-o">&lt;</span><span class="tok-k">const</span> <span class="tok-kt">char</span><span class="tok-o">*&gt;</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">),</span>
                                  <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer_size</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">));</span>
                <span class="tok-n">whatEmit</span> <span class="tok-o">|=</span> <span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">DATA</span><span class="tok-p">;</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_body</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_message</span><span class="tok-p">:</span>
            <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">remove</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">());</span>
            <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span>
                                                 <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">()));</span>
            <span class="tok-n">whatEmit</span> <span class="tok-o">|=</span> <span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">END</span><span class="tok-p">;</span>
            <span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">,</span> <span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">readyRead</span><span class="tok-p">()),</span>
                       <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">SLOT</span><span class="tok-p">(</span><span class="tok-n">onReadyRead</span><span class="tok-p">()));</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>

        <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">remove</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">());</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">is_upgrade</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">,</span> <span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">readyRead</span><span class="tok-p">()),</span>
                   <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">SLOT</span><span class="tok-p">(</span><span class="tok-n">onReadyRead</span><span class="tok-p">()));</span>
        <span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">socket</span><span class="tok-p">,</span> <span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">disconnected</span><span class="tok-p">()),</span>
                   <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">close</span><span class="tok-p">()));</span>
        <span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">timer</span><span class="tok-p">,</span> <span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">timeout</span><span class="tok-p">()),</span> <span class="tok-k">this</span><span class="tok-p">,</span> <span class="tok-n">SLOT</span><span class="tok-p">(</span><span class="tok-n">onTimeout</span><span class="tok-p">()));</span>

        <span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">body</span><span class="tok-p">.</span><span class="tok-n">swap</span><span class="tok-p">(</span><span class="tok-n">priv</span><span class="tok-o">-&gt;</span><span class="tok-n">buffer</span><span class="tok-p">);</span>
        <span class="tok-n">emit</span> <span class="tok-nf">upgrade</span><span class="tok-p">();</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">whatEmit</span><span class="tok-p">.</span><span class="tok-n">testFlag</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">READY</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">whatEmit</span> <span class="tok-o">&amp;=</span> <span class="tok-o">~</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">Signals</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">READY</span><span class="tok-p">);</span>
        <span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">data</span><span class="tok-p">()));</span>
        <span class="tok-k">this</span><span class="tok-o">-&gt;</span><span class="tok-n">disconnect</span><span class="tok-p">(</span><span class="tok-n">SIGNAL</span><span class="tok-p">(</span><span class="tok-n">end</span><span class="tok-p">()));</span>
        <span class="tok-n">emit</span> <span class="tok-nf">ready</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">whatEmit</span><span class="tok-p">.</span><span class="tok-n">testFlag</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">DATA</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">whatEmit</span> <span class="tok-o">&amp;=</span> <span class="tok-o">~</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">Signals</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">DATA</span><span class="tok-p">);</span>
        <span class="tok-n">emit</span> <span class="tok-nf">data</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">whatEmit</span><span class="tok-p">.</span><span class="tok-n">testFlag</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">END</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">whatEmit</span> <span class="tok-o">&amp;=</span> <span class="tok-o">~</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">Signals</span><span class="tok-p">(</span><span class="tok-n">Priv</span><span class="tok-o">::</span><span class="tok-n">END</span><span class="tok-p">);</span>
        <span class="tok-n">emit</span> <span class="tok-nf">end</span><span class="tok-p">();</span>
        <span class="tok-k">return</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Boost.Http higher level message framework&#8217;s socket has a buffer of fixed size
and cannot have the luxury of appending data every time. Both high level
projects have many fundamental differences.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost.Http</th>
<th class="tableblock halign-left valign-top">Tufão</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boost.Asio active style.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt event loop passive style.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boost usage allowed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">It uses this header-only parser lib at Tufão build time and Tufão user will
 never need Boost again.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message-based framework which allows different backends to be plugged later
 keeping the same handlers.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tied to HTTP/1.1 embedded server.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callbacks and completion tokens. It may read more than asked for, but it&#8217;ll use
 <code>read_state</code> to keep user informed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Combined with Qt network reactive programming style, it has a strange logic
 related to event signalling.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Proper HTTP upgrade semantics.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strange HTTP upgrade semantics thanks to the immaturity of following NodeJS
 design decisions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">It normalizes all header keys to lower case.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case insensitive string classes for the C++ counterpart of the HTTP field names
 structure.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>These are the main differences that I wanted to note. You can be sure this
parser will fit you and it&#8217;ll be easy to use. And more importantly, easy to use
<strong>right</strong>.
<a href="https://vinipsmaker.wordpress.com/2016/08/05/boost-http-has-a-new-parser/">NodeJS
parser demands too much HTTP knowledge on the user behalf</a>. And thanks to the
NodeJS parser hard to use API, Tufão only was able to support proper HTTP
pipelining once it migrated to Boost.Http parser (although Boost.Http managed to
do lots of ninja techs to support it under NodeJS parser).</p>
</div>
<div class="paragraph">
<p>To sum up the data received handler structure, you need:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Get the buffer right with <code>parser.set_buffer(buf)</code>.</p>
</li>
<li>
<p>Loop to consume — <code>parser.next()</code> — tokens while
<code>http::token::code::error_insufficient_data</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Examine token with <code>parser.code()</code>.</p>
</li>
<li>
<p>Maybe handle error.</p>
</li>
<li>
<p>Extract data with <code>parser.value&lt;T&gt;()</code> if a data token.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Remove parsed data.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are a lot of different HTTP server/client models you can build on top of
this framework and the notification style you&#8217;re to use is entirely up
to you. Most likely, you&#8217;ll want to hook some actions when the
always-to-be-triggered delimiters category tokens (e.g.
<code>boost::http::token::code::end_of_headers</code>) are reached.</p>
</div>
</div>
<div class="sect2">
<h3 id="parsing_tutorial3">2.5. Parsing HTTP upgrade</h3>
<div class="paragraph">
<p>Given you already know the basics, parsing HTTP upgrade is trivial. Because the
HTTP parser doesn&#8217;t take ownership of the buffer and you pretty much know up
until which point the stream was parsed as HTTP.</p>
</div>
<div class="paragraph">
<p>All you gotta do is consume all the HTTP data (i.e. watch for
<code>code::end_of_message</code>) and parse the rest of the buffer as the new
protocol. Here is the Tufão code to update an HTTP client to WebSocket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kr">inline</span> <span class="tok-kt">bool</span> <span class="tok-n">WebSocketHttpClient</span><span class="tok-o">::</span><span class="tok-n">execute</span><span class="tok-p">(</span><span class="tok-n">QByteArray</span> <span class="tok-o">&amp;</span><span class="tok-n">chunk</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">errored</span><span class="tok-p">)</span>
        <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>

    <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">chunk</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">chunk</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">()));</span>

    <span class="tok-k">while</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">switch</span><span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">symbol</span><span class="tok-p">())</span> <span class="tok-p">{</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">error</span><span class="tok-p">:</span>
            <span class="tok-n">errored</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
            <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
            <span class="tok-n">qFatal</span><span class="tok-p">(</span><span class="tok-s">&quot;unreachable&quot;</span><span class="tok-p">);</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
            <span class="tok-n">qFatal</span><span class="tok-p">(</span><span class="tok-s">&quot;unreachable&quot;</span><span class="tok-p">);</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">()</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                <span class="tok-n">errored</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
                <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
            <span class="tok-p">}</span>

            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">status_code</span><span class="tok-p">:</span>
            <span class="tok-n">status_code</span> <span class="tok-o">=</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">status_code</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
            <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">status_code</span> <span class="tok-o">!=</span> <span class="tok-mi">101</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                <span class="tok-n">errored</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
                <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
            <span class="tok-p">}</span>

            <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">set_method</span><span class="tok-p">(</span><span class="tok-s">&quot;GET&quot;</span><span class="tok-p">);</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">reason_phrase</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">lastHeader</span> <span class="tok-o">=</span> <span class="tok-n">QByteArray</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
            <span class="tok-p">{</span>
                <span class="tok-k">auto</span> <span class="tok-n">value</span> <span class="tok-o">=</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
                <span class="tok-n">QByteArray</span> <span class="tok-nf">header</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span> <span class="tok-n">value</span><span class="tok-p">.</span><span class="tok-n">size</span><span class="tok-p">());</span>
                <span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">insert</span><span class="tok-p">(</span><span class="tok-n">lastHeader</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">header</span><span class="tok-p">));</span>
                <span class="tok-n">lastHeader</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span>
            <span class="tok-p">}</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_headers</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">body_chunk</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_body</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">trailer_name</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">trailer_value</span><span class="tok-p">:</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-k">case</span> <span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-nl">end_of_message</span><span class="tok-p">:</span>
            <span class="tok-n">ready</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
            <span class="tok-n">chunk</span><span class="tok-p">.</span><span class="tok-n">remove</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">());</span>
            <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">chunk</span><span class="tok-p">.</span><span class="tok-n">data</span><span class="tok-p">(),</span>
                                           <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">()));</span>
            <span class="tok-k">break</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>

        <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>
    <span class="tok-n">chunk</span><span class="tok-p">.</span><span class="tok-n">remove</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">parser</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">());</span>

    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">ready</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">headers</span><span class="tok-p">.</span><span class="tok-n">contains</span><span class="tok-p">(</span><span class="tok-s">&quot;Upgrade&quot;</span><span class="tok-p">))</span>
        <span class="tok-k">return</span> <span class="tok-nb">true</span><span class="tok-p">;</span>

    <span class="tok-k">return</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_boost_beast_parser_interface">2.6. Implementing Boost.Beast parser interface</h3>
<div class="paragraph">
<p>In this tutorial, we&#8217;ll show you how to implement Boost.Beast parser interface
using Boost.Http parser.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
No prior experience with Boost.Beast is required.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Boost.Beast parser borrows much of its design from Ryan Dahl&#8217;s HTTP parser — the
NodeJS parser. This is a design that I do know and used more than once in
different projects. However, this is not the only design I know of. I see much
of this design as an evolution of the language limitations that you find in the
C language.</p>
</div>
<div class="paragraph">
<p><a href="https://vinipsmaker.wordpress.com/2016/08/05/boost-http-has-a-new-parser/">I&#8217;ve
previously written a few complaints about the Ryan Dahl&#8217;s HTTP
parser</a>. Boost.Beast evolves from this design and takes a few different
decisions. We&#8217;ll see if, and which, limitations the Boost.Beast parser still
carries thanks to this inheritance.</p>
</div>
<div class="sect3">
<h4 id="_learning_how_to_use_the_parser">2.6.1. Learning how to use the parser</h4>
<div class="paragraph">
<p>The parser is represented by a <code>basic_parser&lt;isRequest, Derived&gt;</code> class. The
parser is callback-based just like Ryan Dahl&#8217;s HTTP parser and it uses CRTP to
avoid the overhead of virtual function calls.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>And here we can notice the first difference between Boost.Beast and Boost.Http
parsers.</p>
</div>
<div class="paragraph">
<p>If you design an algorithm to work on the parser object, this algorithm must be
a template (and it carries the same drawbacks of a header-only library):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Derived</span><span class="tok-o">&gt;</span>
<span class="tok-kt">void</span> <span class="tok-n">do_stuff</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">beast</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">basic_parser</span><span class="tok-o">&lt;</span><span class="tok-nb">true</span><span class="tok-p">,</span> <span class="tok-n">Derived</span><span class="tok-o">&gt;</span> <span class="tok-n">o</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But if you use Boost.Http parser, this requirement vanishes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-nf">do_stuff</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">reader</span><span class="tok-o">::</span><span class="tok-n">request</span> <span class="tok-n">o</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To feed the parser with data, you call <code>basic_parser::put</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span>
    <span class="tok-k">class</span> <span class="tok-nc">ConstBufferSequence</span><span class="tok-o">&gt;</span>
<span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span>
<span class="tok-n">put</span><span class="tok-p">(</span>
    <span class="tok-n">ConstBufferSequence</span> <span class="tok-k">const</span><span class="tok-o">&amp;</span> <span class="tok-n">buffers</span><span class="tok-p">,</span>
    <span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The parser will match <strong>and</strong> decode the tokens in the stream.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>Match and decoding are always applied together. What does this mean? Not much,
given decoding HTTP/1.1 tokens is cheap and most of the time it reduces to
return a <code>string_view</code> of the associated buffer region.</p>
</div>
<div class="paragraph">
<p>However, the implications of the fundamental model chosen (pull or push) give
rise to larger divergences at this point already.</p>
</div>
<div class="paragraph">
<p>In the Boost.Beast parser, the token is passed to the function callback
registered. In the Boost.Http parser, the token is hold by the parser object
itself.</p>
</div>
<div class="paragraph">
<p>It might not seem much difference at the first glance, but consider the problem
of composability. If I want to write an algorithm to take a
<code>boost::http::reader::request</code> object to read a <code>field_name</code> token and possibly
skip it together with the associated <code>field_value</code> (maybe that field isn&#8217;t of
your interest), you only need to wrap the parser object if you&#8217;re using the
Boost.Http solution <sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>. As for the Boost.Beast parser, you&#8217;re left with a long and hackishy
inheritance chain that I don&#8217;t even want to imagine right now if you were to
compose the algorithms.</p>
</div>
<div class="paragraph">
<p>Just as a concrete illustration of what I meant by the Boost.Http solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">T</span> <span class="tok-cm">/* = http::reader::request */</span><span class="tok-o">&gt;</span>
<span class="tok-kt">void</span> <span class="tok-n">socket_consumer</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">&gt;::</span><span class="tok-n">parse</span><span class="tok-p">(</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span> <span class="tok-n">buf</span><span class="tok-p">)</span> <span class="tok-p">{</span> <span class="tok-cm">/* ... */</span> <span class="tok-p">}</span>

<span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">my_parser_wrapper</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-k">const</span>
<span class="tok-p">{</span>
    <span class="tok-k">return</span> <span class="tok-n">code_</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-kt">void</span> <span class="tok-n">my_parser_wrapper</span><span class="tok-o">::</span><span class="tok-n">next</span><span class="tok-p">()</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// Here I should use a case-insensitive comparison function.</span>
    <span class="tok-c1">// For simplicity, this step is omitted.</span>

    <span class="tok-n">wrapped_parser</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
    <span class="tok-n">code_</span> <span class="tok-o">=</span> <span class="tok-n">wrapped_parser</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">();</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">code_</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">field_name</span>
        <span class="tok-o">&amp;&amp;</span> <span class="tok-p">(</span><span class="tok-n">wrapped_parser</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">()</span>
            <span class="tok-o">==</span> <span class="tok-s">&quot;connection&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">code_</span> <span class="tok-o">=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">skip</span><span class="tok-p">;</span>
        <span class="tok-n">skip_next_value</span> <span class="tok-o">=</span> <span class="tok-nb">true</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">code_</span> <span class="tok-o">==</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">field_value</span>
               <span class="tok-o">&amp;&amp;</span> <span class="tok-n">skip_next_value</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">code_</span> <span class="tok-o">=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">skip</span><span class="tok-p">;</span>
        <span class="tok-n">skip_next_value</span> <span class="tok-o">=</span> <span class="tok-nb">false</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>How would the solution look like using the Boost.Beast parser? Let&#8217;s draft
something:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Derived</span><span class="tok-o">&gt;</span>
<span class="tok-k">class</span> <span class="tok-nc">my_parser_wrapper</span>
    <span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">basic_parser</span><span class="tok-o">&lt;</span><span class="tok-nb">true</span><span class="tok-p">,</span> <span class="tok-n">my_parser_wrapper</span><span class="tok-o">&lt;</span><span class="tok-n">Derived</span><span class="tok-o">&gt;&gt;</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-kt">void</span>
    <span class="tok-n">on_field_impl</span><span class="tok-p">(</span><span class="tok-n">field</span> <span class="tok-n">f</span><span class="tok-p">,</span> <span class="tok-n">string_view</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">string_view</span> <span class="tok-n">value</span><span class="tok-p">,</span> <span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-c1">// Here I should use a case-insensitive comparison function.</span>
        <span class="tok-c1">// For simplicity, this step is omitted.</span>

        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">name</span> <span class="tok-o">==</span> <span class="tok-s">&quot;connection&quot;</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">return</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>

        <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-n">Derived</span><span class="tok-o">&amp;&gt;</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-k">this</span><span class="tok-p">).</span><span class="tok-n">on_field_impl</span><span class="tok-p">(</span><span class="tok-n">f</span><span class="tok-p">,</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">value</span><span class="tok-p">,</span> <span class="tok-n">ec</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>

    <span class="tok-kt">void</span> <span class="tok-n">on_header_impl</span><span class="tok-p">(</span><span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-n">Derived</span><span class="tok-o">&amp;&gt;</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-k">this</span><span class="tok-p">).</span><span class="tok-n">on_header_impl</span><span class="tok-p">(</span><span class="tok-n">ec</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>

    <span class="tok-c1">// ...</span>
<span class="tok-p">};</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">template</span> <span class="tok-o">&lt;</span><span class="tok-k">typename</span><span class="tok-o">&gt;</span> <span class="tok-k">class</span> <span class="tok-nc">parser</span><span class="tok-o">&gt;</span>
<span class="tok-k">class</span> <span class="tok-nc">custom_parser</span>
    <span class="tok-o">:</span> <span class="tok-k">public</span> <span class="tok-n">parser</span><span class="tok-o">&lt;</span><span class="tok-n">custom_parser</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
    <span class="tok-c1">// Here we have our original handler.</span>
    <span class="tok-c1">// It&#39;d be our `my_socket_consumer` from the Boost.Http example.</span>
<span class="tok-p">};</span>

<span class="tok-n">custom_parser</span><span class="tok-o">&lt;</span><span class="tok-n">my_parser_wrapper</span><span class="tok-o">&gt;</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this solution is fully flawed. As <code>my_parser_wrapper</code> inherits directly
from <code>basic_parser</code>, we cannot inject some <code>my_parser_wrapper2</code> which applies
another transformation in the chain.</p>
</div>
<div class="paragraph">
<p>I can&#8217;t emphasize enough that the problem is <strong>not</strong> about adding a
“skip-this-set-of-HTTP-headers” function. The problem is about a fundamental
building block which can solve more of the user needs. I could keep thinking
about the different problems that could happen, but if you do not give a <strong>try</strong>
to enter in the <em>general</em> problem and insist on a <em>myopic vision</em>, you&#8217;ll
<strong>never</strong> grasp my message (just as an addicted to inductive reasoning will never
understand someone who is using deductive reasoning). If all you have is a
hammer, everything looks like a nail. We shall see more design implications
later on as we continue this chapter.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As the tokens are found, the user callbacks are called. The function returns the
number of parsed bytes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>And as each sentence goes on, it seems that I need to explain more design
implications.</p>
</div>
<div class="paragraph">
<p>What if you want to <em>reject</em> messages as soon as one specific token is found?
The point here is about avoiding unnecessary computation of parsing elements of
a message that would be rejected anyway.</p>
</div>
<div class="paragraph">
<p>For Boost.Http parser, the control flow is yours to take and&#8230;&#8203;</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><strong>Do what thou wilt</strong> shall be the whole of the Law.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Aleister Crowley
</div>
</div>
<div class="paragraph">
<p>A concrete example if you may:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-c1">// ...</span>

<span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">last_header_was_x</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">is_good</span><span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">()))</span> <span class="tok-p">{</span>
        <span class="tok-c1">// stop the world (e.g. `return` or `throw`)</span>
    <span class="tok-p">}</span>

<span class="tok-c1">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As for Boost.Beast parser. There <strong>is</strong> an answer, but not with your current
limited knowledge of the API. Let&#8217;s continue to present Boost.Beast API and come
back at this “stop the world” problem later.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The behaviour usually found in push parsers is to parse the stream until the end
of the feeded buffers and then return. This is the NodeJS&#8217;s parser approach from
which Boost.Beast takes much inspiration. However, Boost.Beast takes a slightly
different approach to this problem so it&#8217;s possible to parse only one token at a
time. The Boost.Beast solution is the <code>eager</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span>
<span class="tok-nf">eager</span><span class="tok-p">(</span>
    <span class="tok-kt">bool</span> <span class="tok-n">v</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Normally the parser returns after successfully parsing a structured element
(header, chunk header, or chunk body) even if there are octets remaining in the
input. This is necessary when attempting to parse the header first, or when the
caller wants to inspect information which may be invalidated by subsequent
parsing, such as a chunk extension. The eager option controls whether the parser
keeps going after parsing structured element if there are octets remaining in
the buffer and no error occurs. This option is automatically set or cleared
during certain stream operations to improve performance with no change in
functionality.</p>
</div>
<div class="paragraph">
<p>The default setting is <code>false</code>.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Vinnie Falco<br>
<cite>Boost.Beast documentation</cite>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>And now, back at the “stop the world” problem&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Simply put, Boost.Beast solution is just a hackishy way to implement a pull
parser — the parser approach <em>consciously</em> chosen by Boost.Http parser.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can just set the <code>error_code&amp; ec</code> on the callback
implementation to stop parsing, but this wouldn&#8217;t solve all the use cases (the
reason why <code>eager</code> is provided).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Continuing this inductive reasoning of “hey! a problem appeared, let&#8217;s write yet
another function, <code>function_xyz</code>, to solve use case 777”, a number of other
functions are provided. One of them is <code>header_limit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span>
<span class="tok-nf">header_limit</span><span class="tok-p">(</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">uint32_t</span> <span class="tok-n">v</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>This function sets the maximum allowed size of the header including all field
name, value, and delimiter characters and also including the CRLF sequences in
the serialized input. If the end of the header is not found within the limit of
the header size, the error <code>http::header_limit</code> is returned by
<code>http::basic_parser::put</code>.</p>
</div>
<div class="paragraph">
<p>Setting the limit after any header octets have been parsed results in undefined
behavior.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Vinnie Falco<br>
<cite>Boost.Beast documentation</cite>
</div>
</div>
<div class="paragraph">
<p>Another function, <code>body_limit</code>, is provided in the same spirit of
<code>header_limit</code>. What if I have a use case to limit <code>request-target</code> size? Then
Boost.Beast author will add <code>function_xyz2</code> to use case 778.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>What is the Boost.Http solution to this problem 🤔? This is broken into two
possible cases.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The whole token is in the buffer: In such case you just need to check
<code>token_size</code>.</p>
</li>
<li>
<p>The buffer has been exhausted and no token is there: Here, just check
<code>expected_token</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It&#8217;ll work for <strong>any</strong> token (i.e. you don&#8217;t need one extra function for each
possible token which would just complicate the implementation and inflate the
object with a large <code>Settings</code> object of some sort).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With all this info, the Boost.Beast parser is mostly covered and we can delve
into the implementation of such interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">DESIGN IMPLICATIONS</div>
<div class="paragraph">
<p>Now&#8230;&#8203; let&#8217;s look at something different. Suppose the following scenario:</p>
</div>
<div class="paragraph">
<p>You have an embedded project and the headers must not be stored (as it&#8217;d imply
heap memory of complex data structures). You process options with an in situ
algorithm out from the headers. In Boost.Http parser, I&#8217;m imagining something in
these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-n">last_header_code</span> <span class="tok-p">{</span>
    <span class="tok-n">OUT_OF_INTEREST_SET</span><span class="tok-p">,</span>
    <span class="tok-n">FOO</span><span class="tok-p">,</span>
    <span class="tok-n">BAR</span><span class="tok-p">,</span>
    <span class="tok-n">FOOBAR</span>
<span class="tok-p">};</span>

<span class="tok-c1">// ...</span>

<span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_name</span><span class="tok-p">:</span>
    <span class="tok-p">{</span>
        <span class="tok-k">auto</span> <span class="tok-n">v</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-o">&gt;</span><span class="tok-p">();</span>
        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;foo&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">FOO</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">BAR</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">v</span><span class="tok-p">,</span> <span class="tok-s">&quot;foobar&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">FOOBAR</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
            <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">OUT_OF_INTEREST_SET</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
        <span class="tok-k">break</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
<span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">field_value</span><span class="tok-p">:</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">last_header</span> <span class="tok-o">==</span> <span class="tok-n">FOO</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">foo</span> <span class="tok-o">=</span> <span class="tok-n">process_foo</span><span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">last_header</span> <span class="tok-o">==</span> <span class="tok-n">BAR</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">bar</span> <span class="tok-o">=</span> <span class="tok-n">process_bar</span><span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">last_header</span> <span class="tok-o">==</span> <span class="tok-n">FOOBAR</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-n">foobar</span> <span class="tok-o">=</span> <span class="tok-n">process_foobar</span><span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-o">&gt;</span><span class="tok-p">());</span>
    <span class="tok-p">}</span>
    <span class="tok-k">break</span><span class="tok-p">;</span>

<span class="tok-c1">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Boost.Beast solution is not hard to imagine too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-c1">// ...</span>

<span class="tok-kt">void</span> <span class="tok-nf">on_field_impl</span><span class="tok-p">(</span><span class="tok-n">field</span><span class="tok-p">,</span> <span class="tok-n">string_view</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">string_view</span> <span class="tok-n">value</span><span class="tok-p">,</span> <span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-s">&quot;foo&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">foo</span> <span class="tok-o">=</span> <span class="tok-n">process_foo</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">bar</span> <span class="tok-o">=</span> <span class="tok-n">process_bar</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">iequals</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-s">&quot;foobar&quot;</span><span class="tok-p">))</span> <span class="tok-p">{</span>
        <span class="tok-n">foobar</span> <span class="tok-o">=</span> <span class="tok-n">process_foobar</span><span class="tok-p">(</span><span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-c1">// ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>So&#8230;&#8203; what does each design <em>implies</em>? As Boost.Beast parser always parse field
name + field value <em>together</em>, if both fields sum up more than the buffer size,
you&#8217;re out of luck. Both tokens must fit in the buffer together.</p>
</div>
<div class="paragraph">
<p>Just as an exercise, let&#8217;s pursue the inductive reasoning applied to this
problem. We <em>could</em> split the Boost.Beast&#8217;s <code>on_field_impl</code> callback into two:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>void
on_field_name_impl(
    field f,
    string_view name,
    error_code&amp; ec);

void
on_field_value_impl(
    string_view value,
    error_code&amp; ec);</code></pre>
</div>
</div>
<div class="paragraph">
<p>But then we create another problem:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[&#8230;&#8203;] it is the responsibility of the derived class to copy any information it
needs before returning from the callback [&#8230;&#8203;]</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Vinnie Falco<br>
<cite>Boost.Beast documentation</cite>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t see a problem already, let me unveil it for you. Now, most of the
uses of the parser, which want to store the HTTP headers in some sort of
<code>std::multimap</code> structure will have to perform one extra allocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span> <span class="tok-nf">on_field_name_impl</span><span class="tok-p">(</span><span class="tok-n">field</span><span class="tok-p">,</span> <span class="tok-n">string_view</span> <span class="tok-n">name</span><span class="tok-p">,</span> <span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
    <span class="tok-n">last_header</span> <span class="tok-o">=</span> <span class="tok-n">to_string</span><span class="tok-p">(</span><span class="tok-n">name</span><span class="tok-p">);</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Under the push parser model, these two cases are irreconcilable. Boost.Beast
opts to solve the most common problem and this was a good design choice (let&#8217;s
give credit where credit is due).</p>
</div>
<div class="paragraph">
<p>However, Boost.Http parser is a good choice in <em>any</em> of these two cases. It only
feeds one token at a time. And as Boost.Http message framework demonstrate,
<a href="https://github.com/BoostGSoC14/boost.http/blob/c7b3e11884420b55568222d237e9c429ec24b811/include/boost/http/socket-inl.hpp#L630">we
can use the first bytes of the buffer to store the HTTP field name</a>.</p>
</div>
<div class="paragraph">
<p>And just to present a more readable alternative, you could play with copies of
the reader object made in the stack of the
<code>my_socket_consumer::on_socket_callback</code> function. This way, you have a point in
time and you can make the parser “go back”. The copies are cheap because the
reader object is just an integer-based state machine with a few indexes. The
<em>idea</em> behind this solution is to mirror current Boost.Beast behaviour — field
name and field value are always kept together in the buffer.</p>
</div>
<div class="paragraph">
<p><strong>Remember</strong>&#8230;&#8203; principles. I can attack other specific cases. As an exercise, try
to find a few yourself.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_the_boost_beast_interface">2.6.2. Implementing the Boost.Beast interface</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>As we previously seen, there are several functions in Boost.Beast parser that
are just boilerplate inherited (e.g. <code>eager</code>) thanks to the choice of the wrong
fundamental model (i.e. pull vs push).</p>
</div>
<div class="paragraph">
<p>We&#8217;ll skip some of this boilerplate as it is not of our interest. Our purpose
with this tutorial was to show design implications derived from the choices of
the <em>fundamental</em> models.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-kt">bool</span> <span class="tok-n">isRequest</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Derived</span><span class="tok-o">&gt;</span>
<span class="tok-k">class</span> <span class="tok-nc">basic_parser</span><span class="tok-p">;</span>

<span class="tok-c1">// This template specialization is wrong, but is kept for simplification</span>
<span class="tok-c1">// purposes.</span>
<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-kt">bool</span> <span class="tok-n">isRequest</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Derived</span><span class="tok-o">&gt;</span>
<span class="tok-k">class</span> <span class="tok-nc">basic_parser</span><span class="tok-o">&lt;</span><span class="tok-nb">true</span><span class="tok-p">,</span> <span class="tok-n">Derived</span><span class="tok-o">&gt;</span>
<span class="tok-p">{</span>
<span class="tok-k">public</span><span class="tok-o">:</span>
    <span class="tok-k">template</span><span class="tok-o">&lt;</span>
        <span class="tok-k">class</span> <span class="tok-nc">ConstBufferSequence</span><span class="tok-o">&gt;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span>
    <span class="tok-n">put</span><span class="tok-p">(</span>
        <span class="tok-n">ConstBufferSequence</span> <span class="tok-k">const</span><span class="tok-o">&amp;</span> <span class="tok-n">buffers</span><span class="tok-p">,</span>
        <span class="tok-n">error_code</span><span class="tok-o">&amp;</span> <span class="tok-n">ec</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-c1">// WARNING: the real implementation will have more trouble because of</span>
        <span class="tok-c1">// the `ConstBufferSequence` concept, but for the reason of simplicity,</span>
        <span class="tok-c1">// we don&#39;t show the real code here.</span>
        <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffers</span><span class="tok-p">);</span>

        <span class="tok-n">error_code</span> <span class="tok-n">ec</span><span class="tok-p">;</span>

        <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">()</span> <span class="tok-o">!=</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">error_insufficient_data</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-k">switch</span> <span class="tok-p">(</span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">code</span><span class="tok-p">())</span> <span class="tok-p">{</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">skip</span><span class="tok-p">:</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">method</span><span class="tok-p">:</span>
                <span class="tok-n">method</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-o">&gt;</span><span class="tok-p">;</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">request_target</span><span class="tok-p">:</span>
                <span class="tok-n">target</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-o">&gt;</span><span class="tok-p">;</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>
            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">version</span><span class="tok-p">:</span>
                <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-n">Derived</span><span class="tok-o">&amp;&gt;</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-k">this</span><span class="tok-p">)</span>
                    <span class="tok-p">.</span><span class="tok-n">on_request_impl</span><span class="tok-p">(</span><span class="tok-cm">/*the enum code*/</span><span class="tok-p">,</span> <span class="tok-n">method</span><span class="tok-p">,</span> <span class="tok-n">target</span><span class="tok-p">,</span>
                                     <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">value</span><span class="tok-o">&lt;</span><span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-o">&gt;</span><span class="tok-p">(),</span> <span class="tok-n">ec</span><span class="tok-p">);</span>
                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">ec</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                    <span class="tok-c1">// TODO: extra code to enter in error state</span>
                    <span class="tok-k">return</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">();</span>
                <span class="tok-p">}</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>

            <span class="tok-c1">// ...</span>

            <span class="tok-k">case</span> <span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-nl">end_of_headers</span><span class="tok-p">:</span>
                <span class="tok-k">static_cast</span><span class="tok-o">&lt;</span><span class="tok-n">Derived</span><span class="tok-o">&amp;&gt;</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-k">this</span><span class="tok-p">).</span><span class="tok-n">on_header_impl</span><span class="tok-p">(</span><span class="tok-n">ec</span><span class="tok-p">);</span>
                <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">ec</span><span class="tok-p">)</span> <span class="tok-p">{</span>
                    <span class="tok-c1">// TODO: extra code to enter in error state</span>
                    <span class="tok-k">return</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">();</span>
                <span class="tok-p">}</span>
                <span class="tok-k">break</span><span class="tok-p">;</span>

            <span class="tok-c1">// ...</span>
            <span class="tok-p">}</span>
            <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
        <span class="tok-p">}</span>

        <span class="tok-k">return</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">parsed_count</span><span class="tok-p">();</span>
    <span class="tok-p">}</span>

<span class="tok-k">private</span><span class="tok-o">:</span>
    <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">http</span><span class="tok-o">::</span><span class="tok-n">reader</span><span class="tok-o">::</span><span class="tok-n">request</span> <span class="tok-n">reader</span><span class="tok-p">;</span>

    <span class="tok-c1">// It&#39;s possible and easy to create an implementation that doesn&#39;t allocate</span>
    <span class="tok-c1">// memory. Just keep a copy of `reader` within the `put` function body and</span>
    <span class="tok-c1">// you can go back. As `reader` is just an integer-based state machine with</span>
    <span class="tok-c1">// a few indexes, the copy is cheap. I&#39;m sorry I don&#39;t have the time to code</span>
    <span class="tok-c1">// the demonstration right now.</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">method</span><span class="tok-p">;</span>
    <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span> <span class="tok-n">target</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A final note I want to add is that I plan more improvements to the parser. Just
as Boost.Beast parser is an evolution of the wrong model chosen for the problem,
my parser still has room to <em>evolve</em>. But from my judgment, this parser already
is better than Boost.Beast parser can ever be (i.e. the problems I presented
here are unfixable in Boost.Beast design&#8230;&#8203; not to mention that Boost.Beast
parser has almost the double amount of member-functions to solve <em>the same</em>
problem <sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup>).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="design_choices">3. Design choices</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_faq">3.1. FAQ</h3>
<div class="qlist qanda">
<ol>
<li>
<p><em>Why build on top of Boost.Asio?</em></p>
<p>One of the requirements of Boost.Http is scalable performance. Scalable
performance requires an asynchronous design. Asio is expected to become the
future C++ standard for sockets. So, Asio it is.</p>
<div class="paragraph">
<p>Also, reuse existing std or Boost components is nice and Asio is the Boost
solution for asynchronous socket I/O.</p>
</div>
</li>
<li>
<p><em>Why C++11?</em></p>
<p>Asynchronous code can be largely simplified with language support for
lambdas. To speed up the development (and decrease bugs), C++11 was chosen,
but interface-wise, the only real C++11 feature is enum classes, which can
be emulated in C++98 easily.</p>
<div class="paragraph">
<p>C++98 support might be added later. The priority is to prove the core set of
abstractions is correct. Then I can move on the task to fatten the library. The
proof comes in the act of passing the Boost review process.</p>
</div>
<div class="paragraph">
<p>To be fair, I also depend on the C++11 definition of <code>multimap</code>, but Boost
containers can do the job easily.</p>
</div>
</li>
<li>
<p><em>Have you considered contribute to <em>project X/Y</em>?</em></p>
<p><a href="https://github.com/vinipsmaker/gsoc2014-boost/blob/master/other_frameworks.md">Yes,
I have</a>.</p>
<div class="paragraph">
<p>But current Boost.Http is not like what I was expecting when I started to
writing it. Boost.Http is better. The gap between Boost.Http and other projects
became even larger. My previous research won&#8217;t mention every difference.</p>
</div>
<div class="paragraph">
<p>Boost.Http supports pipelining. Pion has separate functions for
chunking. Boost.Http is designed for multiple backends. POCO, QtHttp and
Casablanca aren&#8217;t build on top of Asio. Pion and cpp-netlib will use their own
thread-pool, instead adhering to Asio threading model.</p>
</div>
</li>
<li>
<p><em>Why is it only server-side?</em></p>
<p>Server-side and client-side are of interest to different
applications. Initially, the focus was to provide a library just to
server-side, but with the time spent on research and development, it became
apparent that many of the proposed abstractions are also useful for
client-side.</p>
<div class="paragraph">
<p>After this fact, a lot of caution was devoted to design the interface to retain
the usefulness in client-side, where it makes sense. But this is not enough. A
lot of time was spent on research just to get the server-side right and I expect
that much time (or more) to also get the client-side right.</p>
</div>
<div class="paragraph">
<p>Before any serious effort is spent on client-side, I want to focus on
server-side, where the application load may be way higher and C++ may be way
more desired. And just as the server-side interface development was driven by a
strict set of guidelines (multiple backends, modularity with specific use
cases&#8230;&#8203;), we need to define what we want to achieve with the client-side
abstraction. What kind of usage will be appropriate with such design.</p>
</div>
</li>
<li>
<p><em>Why isn&#8217;t a router available?</em></p>
<p>Advocates of tree-based routers tend to ignore the middleware-based approach
and the other way around is also true. It happens that some even only know one
way and don&#8217;t even stop to consider that their approach isn&#8217;t appropriate for
every project. This subject will affect the life of the users <strong>a lot</strong> and can
be rather polemic.</p>
<div class="paragraph">
<p>I just provide the building blocks and you can create the router any way you
want. Actually, I intend to implement them later, because implementing them now
will just distract the attention of the reviewers and it&#8217;d be a waste of time if
the review proves the core set of abstractions is wrong.</p>
</div>
<div class="paragraph">
<p>Most of the designs I see propose dynamic routers, where you can change the
routing rules at runtime, but this feature is rarely needed. Wouldn&#8217;t be
wonderful if you could use great syntax sugars to declare routers that receive
as much optimization as possible at compile-time? Wouldn&#8217;t be wonderful to use
nested routers? Wouldn&#8217;t be wonderful if you could collaborate the tree-based
and middleware-based approach very easily? Maybe even some kind of collaboration
between the statically declared routers and dynamic routers? I hope this will be
rather polemic and will require a lot of iterations to get it right, maybe with
a mini-review for acceptance.</p>
</div>
</li>
<li>
<p><em>How robust is this parser?</em></p>
<p>It doesn&#8217;t try to parse URLs at all. It&#8217;ll ensure that only valid characters
(according to HTTP request target BNF rule) are present, but invalid sequences
are accepted.</p>
<div class="paragraph">
<p>This parser is a little (but not too much) more liberal in what accepts and
it&#8217;ll accept invalid sequences for rarely used elements that don&#8217;t impact upper
layers of the application. The reason to accept such non-conformant sequences is
a simpler algorithm that can be more performant (e.g. we only check for invalid
chars, but not invalid sequences). Therefore, it&#8217;s advised to reframe the
message if you intend to forward it to some other participant. Not doing so,
might be a security issue if the participant you are forwarding your message to
is know to show improper behaviour when parsing invalid streams. There are
several references within the RFC7230 where similar decisions are suggested
(e.g. if you receive redundant Content-Length header field, you must merge it
into one before forwarding or reject the message as a whole).</p>
</div>
</li>
<li>
<p><em>Why not make a parser using Boost.Spirit?</em></p>
<p>Boost.Spirit needs backtracking to implement the OR operator. Boost.Spirit
can&#8217;t build a state machine which would allow you to continue parsing from the
suspended point/byte. Thanks to these characteristics, it can&#8217;t be used in our
HTTP parser. Also, we don&#8217;t see much benefit in pursuing this effort.</p>
</li>
<li>
<p><em>What is the recommended buffer size?</em></p>
<p>A buffer of size 7990 is recommended (suggested request line of 8000 by
section 3.1.1 of RFC7230 minus spaces, minus http version information minus
the minimum size of the other token in the request line). However, the real
suggested buffer size should be how long names you expect to have on your own
servers.</p>
</li>
<li>
<p><em>What are the differences between <code>reader::request</code> and <code>reader::response</code>?</em></p>
<div id="request_response_diff" class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>response</code> has the <code>void set_method(view_type method)</code> member-function.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This member-function <strong>MUST</strong> be called for each HTTP response message
being parsed in the stream.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>response</code> has the <code>void puteof()</code> member-function.</p>
</li>
<li>
<p><code>code()</code> member function return value has different guarantees in each class.</p>
</li>
<li>
<p><code>template&lt;class T&gt; typename T::type value() const</code> member function accepts
different input template arguments in each class.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_design_choices">3.2. Design choices</h3>
<div class="paragraph">
<p>To convince you about the solution, I&#8217;ll start the text highlighting some
problems and requirements. If you understand the problem, you&#8217;ll understand why
the solution was proposed like that.</p>
</div>
<div class="paragraph">
<p>One of the wanted features for this library since the very beginning was to make
it possible to make a small change in code to expose the HTTP service through a
different communication mechanism. Like, change from embedded HTTP server to
FastCGI-exposed server.</p>
</div>
<div class="paragraph">
<p>There are several libraries who will provide some object you can use to consume
HTTP traffic from the world and will act as a request-reply door to create web
applications. Libraries who will expose a request object you can use to consume
TCP traffic and will export url and headers properties. The problem with this
approach is the coupling between HTTP messages and HTTP communication channels.</p>
</div>
<div class="paragraph">
<p>In Boost.Http, HTTP messages and HTTP communication channels are decoupled, so
it is easier to replace the communication channel later. You could easily use an
unprotected embedded HTTP server on development environment to tests and replace
it in favor of a full-blow solution during production.</p>
</div>
<div class="paragraph">
<p>Boost.Http defines some type requirements to abstract communication channels and
provide some polymorphic adapters who will type erase them. The abstraction was
specified carefully to allow robust applications. Your application will not hang
trying to live stream a video because the request was done from an <code>HTTP/1.0</code>
client. Also, your handler won&#8217;t know what HTTP version (if any) the HTTP
request was made with.</p>
</div>
<div class="paragraph">
<p>Also among the wanted features was to retain the usefulness of the library
whether you&#8217;re using it to power an application intended to run from an low-end
embedded device or an application intended to run on a cluster with plenty of
resources to be made use of. An embdeded device may not have the luxury to host
a pool or a cache layer, but a cluster may even demand these layers to properly
handle thousands of requests every second. With this use case in mind,
modularity was achieved.</p>
</div>
<div class="paragraph">
<p>The plan to finish such ambitious project was “to expose an HTTP abstraction
able to make use of the HTTP power (chunking/streaming, pipelining, upgrade for
supporting channels and multiplexing for supporting channels), at the same time
that a complete separation of communication channels and HTTP messages is
achieved”.</p>
</div>
<div class="paragraph">
<p>With the separation of HTTP messages and HTTP communication channels, alongside
the use of an active model (you ask by the next request instead providing a
handler and waiting for them), several of the requirements became very easy to
fulfill, such as HTTP pipelining, custom memory allocation, buffers, cache
layers and pools of objects.</p>
</div>
<div class="paragraph">
<p>With such very generalized abstractions, you may be worried about the need to
type too much to get something done. This is being solved by providing higher
level flexible abstractions, such as the file server you can already find.</p>
</div>
<div class="sect3">
<h4 id="_the_what">3.2.1. The what</h4>
<div class="imageblock">
<div class="content">
<img src="request_handling.png" alt="request handling" width="700" height="1206">
</div>
</div>
<div class="paragraph">
<p>The above image shows an overview of how to build HTTP servers using Boost.Http.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume you&#8217;re going to use the provided <code>http::socket</code>, suitable for
embedding HTTP servers in your application.</p>
</div>
<div class="paragraph">
<p>You must instantiate a TCP socket acceptor and accept new connections. You
should handle all connections concurrently.</p>
</div>
<div class="paragraph">
<p>Each connection you handle is a pipeline of request-reply pair. To receive the
full request, your action may be required at several points. First, you should
receive the request metadata, then it may be necessary to issue a 100-continue
response. Then you need to issue reads for the body and the trailers until the
whole request has been received.</p>
</div>
<div class="paragraph">
<p>You&#8217;re finally able to send the reply. You have two options, atomic messages or
chunked messages. Chunked messages are not always available and must check if
they can be used for each request you receive, using
<code>write_response_native_stream()</code>.</p>
</div>
<div class="paragraph">
<p>If you spread the handling logic among several functions, a good approach would
be to always share the triplet
<code>&lt;communication channel, request message, response message&gt;</code> around.</p>
</div>
<div class="paragraph">
<p>Still missing is URL parsing and request routing, so you must do this yourself,
possibly managing pools of message and socket objects.</p>
</div>
<div class="paragraph">
<p>This system allows you to implement powerful schedulers doing fair share of
resources over different IPs, whether the requests originate from HTTP or HTTPS,
using all cores of your CPU and deferring new work when the work load is too
high. You should be able to do all fine-grained tuning you need and also easily
create higher level that are suitable for your application. Not only that, this
library could become an interoperability layer for all higher-level that web
application developers create.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="request_server.png" alt="request server" width="149" height="85">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="request_pipeline.png" alt="request pipeline" width="145" height="85">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="request_request.png" alt="request request" width="457" height="241">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="request_request_metadata.png" alt="request request metadata" width="444" height="83">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="request_body.png" alt="request body" width="162" height="89">
</div>
</div>
<div class="paragraph">
<p>Also, if you pay attention, you&#8217;ll realize that this proposal just expose HTTP
with a message oriented abstraction. All procedures in the diagram are related
to HTTP events and actions. And this is a modern API and you can use pretty much
every modern HTTP feature (persistent streams &amp; HTTP pipelining, chunked
entities, 100-continue status, &#8230;&#8203;). And you won&#8217;t handle any parsing or
low-level detail at all. It&#8217;s abstracted enough to allow alternative backends.</p>
</div>
<div class="paragraph">
<p>However, this can easily become a callback hell, and futures wouldn&#8217;t help much,
given the need to use <code>while</code>-constructs. If you use coroutines, there is hope
your code will be readable. Boost.Http follows Asio extensible asynchronous
model and you&#8217;re free to use callbacks, futures, coroutines or others.</p>
</div>
</div>
<div class="sect3">
<h4 id="_asio_familiarity">3.2.2. ASIO familiarity</h4>
<div class="paragraph">
<p>This library may be very pleasant to use for any ASIO-centered mind.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Completion tokens received as the last argument for aync functions.</p>
</li>
<li>
<p>Async operations have the <code>async_</code> prefix.</p>
</li>
<li>
<p>User control the bufferring mechanism, passing the opaque <code>asio::buffer</code> type.</p>
</li>
<li>
<p>User provides <em>output</em> arguments as references and they&#8217;ll be “filled” by the
time the operation completes.</p>
</li>
<li>
<p>Memory management is left for the user.</p>
</li>
<li>
<p>An active model is presented.</p>
</li>
<li>
<p>Similar nomenclature.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>The ASIO way</em> saved us from many problems that otherwise would force us to
propose solutions to already know problems such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Object pools.</p>
</li>
<li>
<p>Deferring acceptance to later on high load scenarios.</p>
</li>
<li>
<p>HTTP pipelining problems.</p>
</li>
<li>
<p>Partially filling response objects from different layers of abstractions.</p>
</li>
<li>
<p>A wrapping/wrapped socket can take care of tasks such as
synchronization/queueing and timeout.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_the_mysteriousweirdnews_api">3.2.3. The mysterious/weird/news API</h4>
<div class="paragraph">
<p>One of the maybe surprising things to start with is the use of highly structured
objects as opposed to things like opaque buffers. You pass a message object to
the initiating function and you&#8217;ll have a fully decomposed object with an URL, a
method and even an associative container for the headers!!!</p>
</div>
<div class="paragraph">
<p>If you do have special memory requirements for the messages, you&#8217;re free to
implementing an alternative container, as long as it fulfills the documented
<code>Message</code> concept. Connections channels and HTTP messages are <strong>not</strong> coupled
together. You can reuse these pieces in many many different contexts.</p>
</div>
<div class="paragraph">
<p>The uncoupled architecture is more general and it is the default mode, but let&#8217;s
say you work at a more constrained environment where memory copying is banned,
for instance. You could provide your HTTP backend (e.g. a non-copying embedded
server) tied to your specific HTTP message type implementing our ideas and you
still may benefit from this libray. This library provides some HTTP algorithms
and some HTTP handlers (e.g. file server) and these abstractions will save some
time from you.</p>
</div>
<div class="paragraph">
<p>Another difference in this library is the presence of an associated state for
reading and writing messages. I believe this abstraction can be extended to also
support very simple HTTP clients. To avoid confusion, if some member-function
cannot be used for both modes (clients and servers), it&#8217;ll have one of the
following prefixes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>async_read_request</p>
</li>
<li>
<p>async_read_response</p>
</li>
<li>
<p>async_write_request</p>
</li>
<li>
<p>async_write_response</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We gave special attention to <code>read_state</code> and <code>write_state</code> to make sure it&#8217;ll
also be usable for <strong>simple</strong> and asynchronous HTTP clients.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_why">3.2.4. The why</h4>
<div class="paragraph">
<p>Boost.Http provides an HTTP socket, which can be used to manage a pipeline of
HTTP messages (i.e. an HTTP request or an HTTP reply). HTTP is stateless and
each message coming from the same socket is independent. The HTTP socket from
Boost.Http is a concept and specific implementations from this concept may
provide more guarantees about the communication properties. The reasons to
provide few guarantees are (<code>#1</code>) because we want a common denominator from
which we can provide implementation for multiple communication channels and
(<code>#2</code>) because implementation details are usually not required for the
application, which is only interested in a high-level abstraction. The provided
<code>boost::http::basic_socket</code> implementation will handle actual HTTP traffic from
TCP sockets and you can use it to handle <code>HTTP/1.0</code> and <code>HTTP/1.1</code> traffic from
TCP and SSL sockets.</p>
</div>
<div class="paragraph">
<p><code>read_state()</code> and <code>write_state()</code> are used to inspect the current state of
interaction and react appropriately. There are rules regarding when the socket
can mutate and change its states. Once you request the socket to read a new HTTP
request, you&#8217;ll be notified as soon as the request metadata (request line and
HTTP headers) are ready, then you can progressively download the body and react
appropriately. This idea is very useful to improve communication between the
library authors and application authors and also helps to create some tests.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll have to inspect the socket to know whether the current message-exchange
requires <code>100-continue</code>, allows chunked entities (streaming response) and alike.
There is like two kind of replies. With atomic replies, you write the whole
message at once. With chunked message, you compose a message spreading its
construction among several API calls. You may want to use chunked messages when
you don&#8217;t know the whole body in advance (e.g. reading a file, video live
stream&#8230;&#8203;), but chunked messages can only be used in certain message
exchanges. The reason behind providing two kind of replies is to properly
support a wider range of HTTP communication channels.</p>
</div>
<div class="paragraph">
<p>You create one HTTP socket for each HTTP client and should handle them all
concurrently. In case you&#8217;re using the embeddable HTTP server backend, you must
use an acceptor to initialize the <code>basic_socket</code>s' <code>next_layer()</code> and then
consume them. <code>basic_socket</code> templatize the underlying internal socket, so you
can use SSL, queue wrapping socket (to work around Asio&#8217;s composed operations)
and so on. The intention of Boost.Http is not only to generalize over data
structures and HTTP backends, but about any place where it may be helpful.</p>
</div>
<div class="paragraph">
<p>The choice to represent the HTTP messages in separate objects and the whole
combination of this design ease supports for HTTP pipelining a lot. In passive
styles, a request is generated and generated and you must act on them. In this
active style, you explicitly request the next message, handle it and then
request another one. In this scenario, two unrelated messages won&#8217;t be mixed up,
because you won&#8217;t see the next message while you don&#8217;t handle the current
one. The read and write states gives a mean to communicate how to use the API
and how to detect some logical errors in the application.</p>
</div>
<div class="paragraph">
<p>The choice to hide details from the HTTP connection (HTTP version, socket
object&#8230;&#8203;) was done to properly support multiple backends. The ability to query
certain properties from the underlying communication channel is necessary to
achieve reliability under this model. A lot of responsibilies and expected
behaviour is documented on the type requirements for <code>ServerSocket</code> objects.</p>
</div>
<div class="paragraph">
<p>A C++11 multimap is used to represent HTTP headers because that&#8217;s what HTTP
headers conceptually are. HTTP spec specifies you must handle HTTP header
elements with equivalent keys as if there was a single header where the values
are joined with commas. Some old headers don&#8217;t work with this approach and their
values, when multiple elements with equivalent keys are present, must be stored
separately. The order matters, just as the C++11 definition of multimap.</p>
</div>
<div class="paragraph">
<p>Runtime-based polymorphic behaviour isn&#8217;t used by default, because not all
projects are willing to pay for this price. Well defined type requirements are
provided and some polymorphic adaptors will convert models of these type
requirements to classes inheriting a single specific abstract base class.</p>
</div>
<div class="paragraph">
<p>Member-functions as opposed to member-variables are used in HTTP messages,
because some setup (e.g. a proxy who doesn&#8217;t want to reformat the messages) may
want to move the HTTP parser to the HTTP message object. I want to allow a
library who will beat C servers in every aspect.</p>
</div>
<div class="paragraph">
<p>As per <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2">RFC 7230</a>, “a server MUST NOT apply a request to the target resource
until the entire request header section is received, since later header fields
might include conditionals, authentication credentials, or deliberately
misleading duplicate header fields that would impact request processing”, so we
define an interface who will only expose a message once the complete header
section is ready. The message body can be progressively received later. The API
also unifies HTTP messages and HTTP chunking.</p>
</div>
<div class="paragraph">
<p>URL-decomposed objects aren&#8217;t used because all an HTTP backend needs is some
string-like container to push bytes. This container can implement an in-place
URL parsing algorithm and it is all solved. The generic HTTP backends you find
in Boost.Http won&#8217;t care about the url concrete type and you don&#8217;t need to
expect any barrier from this side.</p>
</div>
<div class="paragraph">
<p>We do not use the message itself as a buffer object while we&#8217;re parsing the
connection stream. We require a separate buffer to be able to properly handle
HTTP pipelining (and futurely multiplexing in <code>HTTP/2.0</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_when">3.2.5. The when</h4>
<div class="paragraph">
<p>I couldn&#8217;t resist the temptation of adding a “<em>when</em>” named section after I
already had written a “<em>what</em>” and a “<em>why</em>” section.</p>
</div>
<div class="paragraph">
<p>Just too much research time went into this proposal. Really, a lot of time. I
developed some broken HTTP projects some years ago, learned a lot of design with
really different approaches (PHP, Django, Node.js) trying to solve this problem,
developed my own serious project (<a href="https://github.com/vinipsmaker/tufao">Tufão</a>)
and continued to study and research a lot (the HTTP spec resurrection project,
or <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2">RFC 7230</a>, helped <strong>a lot</strong>). I&#8217;ve gathered info around where interoperability
may be a problem if API doesn&#8217;t help and what features will be desired, sooner
or later, by users, among other data. I&#8217;ve done real effort to gather feedback
from C++ programmers for quite a while already.</p>
</div>
<div class="paragraph">
<p>A special thanks to Bjørn Reese for mentoring me on Asio quirks and API general
design, the feedback which changed the proposal the most. Also a special thanks
to any friend who helped to maintain my mind at a happy state.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_roadmap">3.3. Roadmap</h3>
<div class="ulist">
<ul>
<li>
<p>C++98.</p>
</li>
<li>
<p>Client-side HTTP.</p>
</li>
<li>
<p><code>HTTP/2.0</code>.</p>
</li>
<li>
<p>Request-router.</p>
</li>
<li>
<p>Forms and file uploads.</p>
</li>
<li>
<p>Cookies and sessions (RFC 6265).</p>
</li>
<li>
<p>WebSocket.</p>
</li>
<li>
<p>Alternative backends.</p>
</li>
<li>
<p>Increase test coverage a lot.</p>
</li>
<li>
<p>Benchmarks.</p>
</li>
<li>
<p>Compress replies.</p>
</li>
<li>
<p>WebDAV (it will depend on Boost.XML, which doesn&#8217;t exist yet).</p>
</li>
<li>
<p>World domination.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Parser layer</div>
<ul>
<li>
<p>Parsers combinators.</p>
</li>
<li>
<p>Incremental message generator.</p>
</li>
<li>
<p>Iterator adaptors.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reference">4. Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All declarations from this library resides within the <code>boost::http</code>
namespace. For brevity, this prefix is <strong>not</strong> repeated on the documentation.</p>
</div>
<div class="sect2">
<h3 id="_summary">4.1. Summary</h3>
<div class="sect3">
<h4 id="_classes">4.1.1. Classes</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
<li>
<p><a href="#request"><code>request</code></a></p>
</li>
<li>
<p><a href="#response"><code>response</code></a></p>
</li>
<li>
<p><a href="#socket"><code>socket</code></a></p>
</li>
<li>
<p><a href="#buffered_socket"><code>buffered_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
<li>
<p>Tokens</p>
<div class="ulist">
<ul>
<li>
<p><a href="#token_skip"><code>token::skip</code></a></p>
</li>
<li>
<p><a href="#token_field_name"><code>token::field_name</code></a></p>
</li>
<li>
<p><a href="#token_field_value"><code>token::field_value</code></a></p>
</li>
<li>
<p><a href="#token_body_chunk"><code>token::body_chunk</code></a></p>
</li>
<li>
<p><a href="#token_end_of_headers"><code>token::end_of_headers</code></a></p>
</li>
<li>
<p><a href="#token_end_of_body"><code>token::end_of_body</code></a></p>
</li>
<li>
<p><a href="#token_trailer_name"><code>token::trailer_name</code></a></p>
</li>
<li>
<p><a href="#token_trailer_value"><code>token::trailer_value</code></a></p>
</li>
<li>
<p><a href="#token_end_of_message"><code>token::end_of_message</code></a></p>
</li>
<li>
<p><a href="#token_method"><code>token::method</code></a></p>
</li>
<li>
<p><a href="#token_request_target"><code>token::request_target</code></a></p>
</li>
<li>
<p><a href="#token_version"><code>token::version</code></a></p>
</li>
<li>
<p><a href="#token_status_code"><code>token::status_code</code></a></p>
</li>
<li>
<p><a href="#token_reason_phrase"><code>token::reason_phrase</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Structural parsers</p>
<div class="ulist">
<ul>
<li>
<p><a href="#reader_request"><code>reader::request</code></a></p>
</li>
<li>
<p><a href="#reader_response"><code>reader::response</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_class_templates">4.1.2. Class Templates</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_request"><code>basic_request</code></a></p>
</li>
<li>
<p><a href="#basic_response"><code>basic_response</code></a></p>
</li>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a></p>
</li>
<li>
<p><a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a></p>
</li>
<li>
<p><a href="#request_response_wrapper"><code>request_response_wrapper</code></a></p>
</li>
<li>
<p><a href="#basic_poly_socket_base"><code>basic_poly_socket_base</code></a></p>
</li>
<li>
<p><a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#server_socket_adaptor"><code>server_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#client_socket_adaptor"><code>client_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#socket_adaptor"><code>socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#basic_poly_socket"><code>basic_poly_socket</code></a></p>
</li>
<li>
<p><a href="#is_message"><code>is_message</code></a></p>
</li>
<li>
<p><a href="#is_request_message"><code>is_request_message</code></a></p>
</li>
<li>
<p><a href="#is_response_message"><code>is_response_message</code></a></p>
</li>
<li>
<p><a href="#is_socket"><code>is_socket</code></a></p>
</li>
<li>
<p><a href="#is_server_socket"><code>is_server_socket</code></a></p>
</li>
<li>
<p><a href="#is_client_socket"><code>is_client_socket</code></a></p>
</li>
<li>
<p><a href="#basic_router"><code>basic_router</code></a></p>
</li>
<li>
<p><a href="#regex_router"><code>regex_router</code></a></p>
</li>
<li>
<p>Content parsers</p>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_chunk_size"><code>syntax::chunk_size</code></a></p>
</li>
<li>
<p><a href="#syntax_content_length"><code>syntax::content_length</code></a></p>
</li>
<li>
<p><a href="#syntax_strict_crlf"><code>syntax::strict_crlf</code></a></p>
</li>
<li>
<p><a href="#syntax_liberal_crlf"><code>syntax::liberal_crlf</code></a></p>
</li>
<li>
<p><a href="#syntax_field_name"><code>syntax::field_name</code></a></p>
</li>
<li>
<p><a href="#syntax_left_trimmed_field_value"><code>syntax::left_trimmed_field_value</code></a></p>
</li>
<li>
<p><a href="#syntax_ows"><code>syntax::ows</code></a></p>
</li>
<li>
<p><a href="#syntax_reason_phrase"><code>syntax::reason_phrase</code></a></p>
</li>
<li>
<p><a href="#syntax_status_code"><code>syntax::status_code</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_free_functions">4.1.3. Free Functions</h4>
<div class="ulist">
<ul>
<li>
<p>Header processing</p>
<div class="ulist">
<ul>
<li>
<p><a href="#header_to_ptime"><code>header_to_ptime</code></a></p>
</li>
<li>
<p><a href="#to_http_date"><code>to_http_date</code></a></p>
</li>
<li>
<p><a href="#header_value_all_of"><code>header_value_all_of</code></a></p>
</li>
<li>
<p><a href="#header_value_any_of"><code>header_value_any_of</code></a></p>
</li>
<li>
<p><a href="#header_value_none_of"><code>header_value_none_of</code></a></p>
</li>
<li>
<p><a href="#header_value_for_each"><code>header_value_for_each</code></a></p>
</li>
<li>
<p><a href="#etag_match_strong"><code>etag_match_strong</code></a></p>
</li>
<li>
<p><a href="#etag_match_weak"><code>etag_match_weak</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Channel querying</p>
<div class="ulist">
<ul>
<li>
<p><a href="#request_continue_required"><code>request_continue_required</code></a></p>
</li>
<li>
<p><a href="#request_upgrade_desired"><code>request_upgrade_desired</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>File server</p>
<div class="ulist">
<ul>
<li>
<p><a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a></p>
</li>
<li>
<p><a href="#async_response_transmit_dir"><code>async_response_transmit_dir</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_enumerations">4.1.4. Enumerations</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#read_state"><code>read_state</code></a></p>
</li>
<li>
<p><a href="#write_state"><code>write_state</code></a></p>
</li>
<li>
<p><a href="#status_code"><code>status_code</code></a></p>
</li>
<li>
<p><a href="#token_code_value"><code>token::code::value</code></a></p>
</li>
<li>
<p><a href="#token_symbol_value"><code>token::symbol::value</code></a></p>
</li>
<li>
<p><a href="#token_category_value"><code>token::category::value</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_error_codes">4.1.5. Error Codes</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#http_errc"><code>http_errc</code></a></p>
</li>
<li>
<p><a href="#file_server_errc"><code>file_server_errc</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_type_requirements">4.1.6. Type Requirements</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#message_concept"><code>Message</code></a></p>
</li>
<li>
<p><a href="#request_concept"><code>Request</code></a></p>
</li>
<li>
<p><a href="#response_concept"><code>Response</code></a></p>
</li>
<li>
<p><a href="#socket_concept"><code>Socket</code></a></p>
</li>
<li>
<p><a href="#server_socket_concept"><code>ServerSocket</code></a></p>
</li>
<li>
<p><a href="#client_socket_concept"><code>ClientSocket</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_headers">4.1.7. Headers</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#algorithm_header"><code>&lt;boost/http/algorithm.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#header_header"><code>&lt;boost/http/algorithm/header.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#query_header"><code>&lt;boost/http/algorithm/query.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#file_server_header"><code>&lt;boost/http/file_server.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#headers_header"><code>&lt;boost/http/headers.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#http_category_header"><code>&lt;boost/http/http_category.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#http_errc_header"><code>&lt;boost/http/http_errc.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#request_header"><code>&lt;boost/http/request.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#response_header"><code>&lt;boost/http/response.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#request_response_wrapper_header"><code>&lt;boost/http/request_response_wrapper.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket_header"><code>&lt;boost/http/poly_server_socket.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket_header"><code>&lt;boost/http/poly_client_socket.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base_header"><code>&lt;boost/http/poly_socket_base.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#poly_socket_header"><code>&lt;boost/http/poly_socket.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#read_state_header"><code>&lt;boost/http/read_state.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#server_socket_adaptor_header"><code>&lt;boost/http/server_socket_adaptor.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#client_socket_adaptor_header"><code>&lt;boost/http/client_socket_adaptor.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#socket_adaptor_header"><code>&lt;boost/http/socket_adaptor.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#socket_header"><code>&lt;boost/http/socket.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#buffered_socket_header"><code>&lt;boost/http/buffered_socket.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#status_code_header"><code>&lt;boost/http/status_code.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#write_state_header"><code>&lt;boost/http/write_state.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#traits_header"><code>&lt;boost/http/traits.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#basic_router_header"><code>&lt;boost/http/basic_router.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#regex_router_header"><code>&lt;boost/http/regex_router.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#token_header"><code>&lt;boost/http/token.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#reader_request_header"><code>&lt;boost/http/reader/request.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#reader_response_header"><code>&lt;boost/http/reader/response.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_chunk_size_header"><code>&lt;boost/http/syntax/chunk_size.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_content_length_header"><code>&lt;boost/http/syntax/content_length.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_crlf_header"><code>&lt;boost/http/syntax/crlf.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_field_name_header"><code>&lt;boost/http/syntax/field_name.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_field_value_header"><code>&lt;boost/http/syntax/field_value.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_ows_header"><code>&lt;boost/http/syntax/ows.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_reason_phrase_header"><code>&lt;boost/http/syntax/reason_phrase.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#syntax_status_code_header"><code>&lt;boost/http/syntax/status_code.hpp&gt;</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_macros">4.1.8. Macros</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>BOOST_HTTP_SOCKET_DEFAULT_BUFFER_SIZE</code></dt>
<dd>
<p>This macro defines the default buffer size for
<a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a>. It&#8217;s safe to override this
value (per using class or globally) and should be done before including the
file <a href="#buffered_socket_header"><code>&lt;boost/http/buffered_socket.hpp&gt;</code></a>. The
default provided value (i.e. the non-overriden version) is unspecified
(e.g. can change among versions and platforms).</p>
</dd>
<dt class="hdlist1"><code>BOOST_HTTP_UPGRADE_HEAD_DISABLE_CHECK</code></dt>
<dd>
<p>Define this macro if you want to disable the check in
<code>basic_socket::upgrade_head</code>. The check is there to ensure that you only uses
this function in HTTP client mode. It&#8217;ll throw an exception to notify the
violation.</p>
</dd>
<dt class="hdlist1"><code>BOOST_HTTP_SOCKET_DEFAULT_BODY_COPY_THRESHOLD</code></dt>
<dd>
<p>This macro defines the default value for <a href="#basic_socket"><code>basic_socket</code></a>'s
<code>Settings::body_copy_threshold</code>. It represents the maximum amount of bytes
<a href="#basic_socket"><code>basic_socket</code></a> will copy from message bodies in an attempt to
send a single buffer chunk to the underlying network write syscall. If <code>0</code>,
then no body is copied and a split write buffer will always be used. The
default provided value (i.e. the non-overriden version) is unspecified
(e.g. can change among versions and platforms).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_detailed">4.2. Detailed</h3>
<div class="sect3">
<h4 id="headers">4.2.1. <code>headers</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/headers.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>headers</code> is a simple typedef for some unspecified multimap container.</p>
</div>
<div class="paragraph">
<p>The user can safely assume that <code>headers::key_type</code> will be <code>std::string</code> and
<code>headers::mapped_type</code> will be <code>std::string</code>. <code>std::string</code> is used because
fulfills the requirements perfectly and is very unlikely it will ever cause any
controversy.</p>
</div>
<div class="paragraph">
<p>The user can also assume that this type fulfills the <a href="#message_concept">Headers
definition of message</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Previously, <code>headers</code> was guaranteed to be a typedef for
<code>boost::container::flat_multimap</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="request">4.2.2. <code>request</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/request.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>request</code> is a simple typedef for <a href="#basic_request"><code>basic_request</code></a>. It&#8217;s
defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_request</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-p">,</span> <span class="tok-n">headers</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">request</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>std::vector&lt;std::uint8_t&gt;</code> is used over <code>std::string</code>, because fits the purpose
of the body (binary data payload container) better (no <code>'\0'</code> character
terminator, well-defined behaviours of capacity, size and iterator invalidation,
&#8230;&#8203;).</p>
</div>
<div class="sect4">
<h5 id="_see_also">4.2.2.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response">4.2.3. <code>response</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/response.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>response</code> is a simple typedef for <a href="#basic_response"><code>basic_response</code></a>. It&#8217;s
defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_response</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">string</span><span class="tok-p">,</span> <span class="tok-n">headers</span><span class="tok-p">,</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">vector</span><span class="tok-o">&lt;</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">uint8_t</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">response</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>std::vector&lt;std::uint8_t&gt;</code> is used over <code>std::string</code>, because fits the purpose
of the body (binary data payload container) better (no <code>'\0'</code> character
terminator, well-defined behaviours of capacity, size and iterator invalidation,
&#8230;&#8203;).</p>
</div>
<div class="sect4">
<h5 id="_see_also_2">4.2.3.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="socket">4.2.4. <code>socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>socket</code> is a simple typedef for <a href="#basic_socket"><code>basic_socket</code></a>. It&#8217;s defined
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_socket</span><span class="tok-o">&lt;</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">socket</span><span class="tok-o">&gt;</span> <span class="tok-n">socket</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="buffered_socket">4.2.5. <code>buffered_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/buffered_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>buffered_socket</code> is a simple typedef for <a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a>. It&#8217;s defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_buffered_socket</span><span class="tok-o">&lt;</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">ip</span><span class="tok-o">::</span><span class="tok-n">tcp</span><span class="tok-o">::</span><span class="tok-n">socket</span><span class="tok-o">&gt;</span> <span class="tok-n">buffered_socket</span><span class="tok-p">;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="request_response_wrapper">4.2.6. <code>request_response_wrapper</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/request_response_wrapper.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>request_response_wrapper</code> is an adapter which acts like a common type (akin to
<code>std::common_type</code>) for different <code>Request</code> and <code>Response</code> types. There is no
type erasure and only <a href="#message_concept"><code>Message</code> interface</a> will be available.</p>
</div>
<div class="paragraph">
<p>The purpose of this class is <strong>not</strong> to be a polymorphic wrapper. Therefore, it&#8217;s
not our concern to make sure compatible objects (i.e. objects with the same
<code>header_type</code> and so on) are of the <strong>same</strong> <code>request_response_wrapper</code> type. In
other words, <code>request_response_wrapper</code> will not free you from the template work
if you want to support different <code>Request</code>/<code>Response</code> types. This is <strong>not</strong> a
design issue. However, there is a templated constructor which can accept <strong>some</strong>
different types.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters">4.2.6.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>A model of the <a href="#message_concept"><code>Message</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>A model of the <a href="#message_concept"><code>Message</code> concept</a>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>Response::headers_type</code> must be the same as <code>Request::headers_type</code>. And
the same applies to <code>Response::body_type</code>. Also, if <code>const</code> is applied to
<code>Request</code> or <code>Response</code>, it must be applied to both.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types">4.2.6.2. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>headers_type</code></dt>
<dd>
<p>If <code>Request</code> is <code>const</code>, then it is defined as <code>const typename
Request::headers_type</code>. Otherwise, it&#8217;s defined as <code>typename
Request::headers_type</code>.</p>
</dd>
<dt class="hdlist1"><code>body_type</code></dt>
<dd>
<p>If <code>Request</code> is <code>const</code>, then it is defined as <code>const typename
Request::body_type</code>. Otherwise, it&#8217;s defined as <code>typename Request::body_type</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions">4.2.6.3. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>request_response_wrapper(Request &amp;request)</code></dt>
<dd>
<p>Constructs a <code>request_response_wrapper</code> from a <code>Request</code>.</p>
</dd>
<dt class="hdlist1"><code>request_response_wrapper(Response &amp;response)</code></dt>
<dd>
<p>Constructs a <code>request_response_wrapper</code> from a <code>Response</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class Request2, class Response2&gt; request_response_wrapper(request_response_wrapper&lt;Request2, Response2&gt; &amp;other)</code></dt>
<dd>
<p>Constructs a <code>request_response_wrapper</code> from another
<code>request_response_wrapper</code> with compatible <code>headers_type</code> and <code>body_type</code>.</p>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="_message_concept"><code>Message</code> concept</h6>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>headers_type &amp;headers()</code></dt>
<dd>
<p>Returns the wrapped headers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;headers() const</code></dt>
<dd>
<p>Returns the wrapped headers object.</p>
</dd>
<dt class="hdlist1"><code>body_type &amp;body()</code></dt>
<dd>
<p>Returns the wrapped body object.</p>
</dd>
<dt class="hdlist1"><code>const body_type &amp;body() const</code></dt>
<dd>
<p>Returns the wrapped body object.</p>
</dd>
<dt class="hdlist1"><code>headers_type &amp;trailers()</code></dt>
<dd>
<p>Returns the wrapped trailers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;trailers() const</code></dt>
<dd>
<p>Returns the wrapped trailers object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_3">4.2.6.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_poly_socket_base">4.2.7. <code>basic_poly_socket_base</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_socket_base.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>basic_poly_socket_base</code> is the base class for all classes in the hierarchy
defined for runtime-based polymorphic HTTP producers. It is an abstract class
that only contains functionality useful for simultaneously both channel ends
(client and server).</p>
</div>
<div class="paragraph">
<p>References for objects of this class are expected to fulfill the
<a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</div>
<div class="paragraph">
<p>This class has no state to ease multiple inheritance and it is virtual-inherited
by <a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a> and
<a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a>.</p>
</div>
<div class="paragraph">
<p>The design for the hierarchy started with this class was a little inspired by
<em>C++'s iostream</em> and
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3525.pdf">N3525:
Polymorphic Allocators</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="poly_socket_hierarchy.png" alt="poly socket hierarchy" width="828" height="409">
</div>
<div class="title">Figure 1. <code>poly_socket_base</code> hierarchy</div>
</div>
<div class="sect4">
<h5 id="_template_parameters_2">4.2.7.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Message</code></dt>
<dd>
<p>The message type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_2">4.2.7.2. Member types</h5>
<div class="paragraph">
<p>These are the types chosen <em>set in stone</em> to guarantee ABI stability across
binaries (including possible plugins).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef boost::asio::executor executor_type</code></dt>
<dd>
<p>The executor type.</p>
</dd>
<dt class="hdlist1"><code>typedef Message message_type</code></dt>
<dd>
<p>The message type usable within this class&#8217;s operations.</p>
</dd>
<dt class="hdlist1"><code>typedef asio::experimental::poly_handler&lt;void(boost::system::error_code)&gt; handler_type</code></dt>
<dd>
<p>The type for asynchronous operation completion handlers.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_2">4.2.7.3. Member functions</h5>
<div class="sect5">
<h6 id="_overwritable_functions">Overwritable functions</h6>
<div class="paragraph">
<p>These are the functions that subclasses need to implement in order to lose the
<code>abstract class</code> property.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>virtual executor_type get_executor() = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual bool is_open() const = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual read_state read_state() const = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual write_state write_state() const = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_read_some(message_type &amp;message, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a> is the
lack of support for completion tokens and the use of a type erased handler
instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_read_trailers(message_type &amp;message, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a> is the
lack of support for completion tokens and the use of a type erased handler
instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write(const message_type &amp;message, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a> is the
lack of support for completion tokens and the use of a type erased handler
instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_trailers(const message_type &amp;message, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a> is the
lack of support for completion tokens and the use of a type erased handler
instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_end_of_message(handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#socket_concept"><code>Socket</code> concept</a> is the
lack of support for completion tokens and the use of a type erased handler
instead.</p>
</dd>
<dt class="hdlist1"><code>virtual ~basic_poly_socket_base() = 0</code></dt>
<dd>
<p>Destructor. Inline definition done with <code>= default</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="_wrappers_to_fulfill_the_asio_extensible_model">Wrappers to fulfill the ASIO extensible model</h6>
<div class="paragraph">
<p>These functions rewrite usual function calls in terms of the ABI stable
interface. They also enable the ASIO extensible model within this hierarchy.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_some(message_type &amp;message, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_read_some</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_trailers(message_type &amp;message, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_read_trailers</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write(const message_type &amp;message, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_trailers(const message_type &amp;message, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_trailers</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_end_of_message(CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_end_of_message</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_4">4.2.7.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_poly_server_socket">4.2.8. <code>basic_poly_server_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_server_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class virtual-inherits
<a href="#basic_poly_socket_base"><code>basic_poly_socket_base&lt;Message&gt;</code></a> and extends its
interface with virtual functions useful for server sockets. This class itself is
also an abstract class with no state (i.e. an <em>interface</em>).</p>
</div>
<div class="paragraph">
<p>References for objects of this class are expected to fulfill the
<a href="#server_socket_concept"><code>ServerSocket</code> concept</a>.</p>
</div>
<div class="paragraph">
<p>This class is inherited by <a href="#basic_poly_socket"><code>basic_poly_socket&lt;Request,
Response, Message&gt;</code></a>, <a href="#server_socket_adaptor"><code>server_socket_adaptor</code></a> and
<a href="#socket_adaptor"><code>socket_adaptor</code></a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_3">4.2.8.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>The request type.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>The response type.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_3">4.2.8.2. Member types</h5>
<div class="paragraph">
<p>These are the types chosen <em>set in stone</em> to guarantee ABI stability across
binaries (including possible plugins).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Request request_type</code></dt>
<dd>
<p>The request type.</p>
</dd>
<dt class="hdlist1"><code>typedef Response response_type</code></dt>
<dd>
<p>The response type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_3">4.2.8.3. Member functions</h5>
<div class="sect5">
<h6 id="_overwritable_functions_2">Overwritable functions</h6>
<div class="paragraph">
<p>These are the functions that subclasses need to implement in order to lose the
<code>abstract class</code> property.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>virtual bool write_response_native_stream() const = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_read_request(request_type &amp;request, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> is the lack of support for completion tokens and the use of a type
erased handler instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_response(const response_type &amp;response, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> is the lack of support for completion tokens and the use of a type
erased handler instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_response_continue(handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> is the lack of support for completion tokens and the use of a type
erased handler instead.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_response_metadata(const response_type &amp;response, handler_type handler) = 0</code></dt>
<dd>
<p>The only difference between this function (besides mandatory virtual) and the
one with the same name found on the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> is the lack of support for completion tokens and the use of a type
erased handler instead.</p>
</dd>
<dt class="hdlist1"><code>virtual ~basic_poly_server_socket()</code></dt>
<dd>
<p>Destructor.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="_wrappers_to_fulfill_the_asio_extensible_model_2">Wrappers to fulfill the ASIO extensible model</h6>
<div class="paragraph">
<p>These functions rewrite usual function calls in terms of the ABI stable
interface. They also enable the ASIO extensible model within this hierarchy.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_request(request_type &amp;request, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_read_request</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_response(const response_type &amp;response, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_response</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_response_continue(CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_response_continue</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_response_metadata(const response_type &amp;response, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_response_metadata</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_5">4.2.8.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_poly_client_socket">4.2.9. <code>basic_poly_client_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_client_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class virtual-inherits
<a href="#basic_poly_socket_base"><code>basic_poly_socket_base&lt;Message&gt;</code></a> and extends its
interface with virtual functions useful for client sockets. This class itself is
also an abstract class with no state (i.e. an <em>interface</em>).</p>
</div>
<div class="paragraph">
<p>References for objects of this class are expected to fulfill the
<a href="#client_socket_concept"><code>ClientSocket</code> concept</a>.</p>
</div>
<div class="paragraph">
<p>This class is inherited by <a href="#basic_poly_socket"><code>basic_poly_socket&lt;Request,
Response, Message&gt;</code></a>, <a href="#client_socket_adaptor"><code>client_socket_adaptor</code></a> and
<a href="#socket_adaptor"><code>socket_adaptor</code></a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_4">4.2.9.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>The request type.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>The response type.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_4">4.2.9.2. Member types</h5>
<div class="paragraph">
<p>These are the types chosen <em>set in stone</em> to guarantee ABI stability across
binaries (including possible plugins).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Request request_type</code></dt>
<dd>
<p>The request type.</p>
</dd>
<dt class="hdlist1"><code>typedef Response response_type</code></dt>
<dd>
<p>The response type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_4">4.2.9.3. Member functions</h5>
<div class="sect5">
<h6 id="_overwritable_functions_3">Overwritable functions</h6>
<div class="paragraph">
<p>These are the functions that subclasses need to implement in order to lose the
<code>abstract class</code> property.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>virtual void async_write_request(const request_type &amp;request, handler_type handler) = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_write_request_metadata(const request_type &amp;request, handler_type handler) = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual void async_read_response(response_type &amp;response, handler_type handler) = 0</code></dt>
<dd>
<p>This function presents no differences (besides mandatory virtual) from the one
with the same name found on the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>virtual ~basic_poly_client_socket()</code></dt>
<dd>
<p>Destructor.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="_wrappers_to_fulfill_the_asio_extensible_model_3">Wrappers to fulfill the ASIO extensible model</h6>
<div class="paragraph">
<p>These functions rewrite usual function calls in terms of the ABI stable
interface. They also enable the ASIO extensible model within this hierarchy.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_request(const request_type &amp;request, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_request</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_request_metadata(const request_type &amp;request, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_write_request_metadata</code>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_read_response(response_type &amp;response, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Handle the token and dispatch the operation to the ABI stable
<code>async_read_response</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_6">4.2.9.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_poly_socket">4.2.10. <code>basic_poly_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class inherits
<a href="#basic_poly_server_socket"><code>basic_poly_server_socket&lt;Request, Response,
Message&gt;</code></a> and <a href="#basic_poly_client_socket"><code>basic_poly_client_socket&lt;Request,
Response, Message&gt;</code></a>. This class itself is also an abstract class with no state
(i.e. an <em>interface</em>).</p>
</div>
<div class="paragraph">
<p>References for objects of this class are expected to fulfill the
<a href="#server_socket_concept"><code>ServerSocket</code> concept</a> and the
<a href="#client_socket_concept"><code>ClientSocket</code> concept</a>.</p>
</div>
<div class="paragraph">
<p>This class is inherited by <a href="#socket_adaptor"><code>socket_adaptor</code></a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_5">4.2.10.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>The request type.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>The response type.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_5">4.2.10.2. Member types</h5>
<div class="paragraph">
<p>These are the types chosen <em>set in stone</em> to guarantee ABI stability across
binaries (including possible plugins).</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Request request_type</code></dt>
<dd>
<p>Request message type.</p>
</dd>
<dt class="hdlist1"><code>typedef Response response_type</code></dt>
<dd>
<p>Response message type.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_7">4.2.10.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="poly_socket_base">4.2.11. <code>poly_socket_base</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_socket_base.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>poly_socket_base</code> is a simple typedef for
<a href="#basic_poly_socket_base"><code>basic_poly_socket_base</code></a>. It&#8217;s defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_poly_socket_base</span><span class="tok-o">&lt;</span><span class="tok-n">request_response_wrapper</span><span class="tok-o">&lt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">response</span><span class="tok-o">&gt;&gt;</span>
  <span class="tok-n">poly_socket_base</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_8">4.2.11.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_socket_base"><code>basic_poly_socket_base</code></a></p>
</li>
<li>
<p><a href="#request"><code>request</code></a></p>
</li>
<li>
<p><a href="#response"><code>response</code></a></p>
</li>
<li>
<p><a href="#request_response_wrapper"><code>request_response_wrapper</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="poly_server_socket">4.2.12. <code>poly_server_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_server_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>poly_server_socket</code> is a simple typedef for
<a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a>. It&#8217;s
defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_poly_server_socket</span><span class="tok-o">&lt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">response</span><span class="tok-o">&gt;</span>
  <span class="tok-n">poly_server_socket</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_9">4.2.12.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#message"><code>message</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="poly_client_socket">4.2.13. <code>poly_client_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_client_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>poly_client_socket</code> is a simple typedef for
<a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a>. It&#8217;s
defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_poly_client_socket</span><span class="tok-o">&lt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">response</span><span class="tok-o">&gt;</span>
  <span class="tok-n">poly_client_socket</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_10">4.2.13.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#message"><code>message</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="poly_socket">4.2.14. <code>poly_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/poly_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>poly_socket</code> is a simple typedef for
<a href="#basic_poly_socket"><code>basic_poly_socket</code></a>. It&#8217;s defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">typedef</span> <span class="tok-n">basic_poly_socket</span><span class="tok-o">&lt;</span><span class="tok-n">request</span><span class="tok-p">,</span> <span class="tok-n">response</span><span class="tok-o">&gt;</span> <span class="tok-n">poly_socket</span><span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_11">4.2.14.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_socket"><code>basic_poly_socket</code></a></p>
</li>
<li>
<p><a href="#message"><code>message</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_request">4.2.15. <code>basic_request</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/request.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This template can be used to easily define classes fulfilling the
<a href="#request_concept"><code>Request</code> concept</a> and specializing the
<a href="#is_request_message"><code>is_request_message</code></a> trait.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_6">4.2.15.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>The type to fulfill the <code>X::string_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Headers</code></dt>
<dd>
<p>The type to fulfill the <code>X::headers_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Body</code></dt>
<dd>
<p>The type to fulfill the <code>X::body_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_6">4.2.15.2. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef String string_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::string_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>typedef Headers headers_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::headers_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>typedef Body body_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::body_type</code> from the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_5">4.2.15.3. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>string_type &amp;method()</code></dt>
<dd>
<p>Returns the internal method object.</p>
</dd>
<dt class="hdlist1"><code>const string_type &amp;method() const</code></dt>
<dd>
<p>Returns the internal method object.</p>
</dd>
<dt class="hdlist1"><code>string_type &amp;target()</code></dt>
<dd>
<p>Returns the internal request target object.</p>
</dd>
<dt class="hdlist1"><code>const string_type &amp;target() const</code></dt>
<dd>
<p>Returns the internal request target object.</p>
</dd>
<dt class="hdlist1"><code>headers_type &amp;headers()</code></dt>
<dd>
<p>Returns the internal headers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;headers() const</code></dt>
<dd>
<p>Returns the internal headers object.</p>
</dd>
<dt class="hdlist1"><code>body_type &amp;body()</code></dt>
<dd>
<p>Returns the internal body object.</p>
</dd>
<dt class="hdlist1"><code>const body_type &amp;body() const</code></dt>
<dd>
<p>Returns the internal body object.</p>
</dd>
<dt class="hdlist1"><code>headers_type &amp;trailers()</code></dt>
<dd>
<p>Returns the internal trailers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;trailers() const</code></dt>
<dd>
<p>Returns the internal trailers object.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_12">4.2.15.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request"><code>request</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_response">4.2.16. <code>basic_response</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/response.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This template can be used to easily define classes fulfilling the
<a href="#response_concept"><code>Response</code> concept</a> and specializing the
<a href="#is_response_message"><code>is_response_message</code></a> trait.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_7">4.2.16.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>The type to fulfill the <code>X::string_type</code> from the <a href="#response_concept"><code>Response</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Headers</code></dt>
<dd>
<p>The type to fulfill the <code>X::headers_type</code> from the <a href="#response_concept"><code>Response</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Body</code></dt>
<dd>
<p>The type to fulfill the <code>X::body_type</code> from the <a href="#response_concept"><code>Response</code>
concept</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_7">4.2.16.2. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef String string_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::string_type</code> from the <a href="#response_concept"><code>Response</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>typedef Headers headers_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::headers_type</code> from the <a href="#response_concept"><code>Response</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>typedef Body body_type</code></dt>
<dd>
<p>The type to fulfill the <code>X::body_type</code> from the <a href="#response_concept"><code>Response</code>
concept</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_6">4.2.16.3. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>std::uint_least16_t &amp;status_code()</code></dt>
<dd>
<p>Returns the internal status code object.</p>
</dd>
<dt class="hdlist1"><code>const std::uint_least16_t &amp;status_code() const</code></dt>
<dd>
<p>Returns the internal status code object.</p>
</dd>
<dt class="hdlist1"><code>string_type &amp;reason_phrase()</code></dt>
<dd>
<p>Returns the internal reason phrase object.</p>
</dd>
<dt class="hdlist1"><code>const string_type &amp;reason_phrase() const</code></dt>
<dd>
<p>Returns the internal reason phrase object.</p>
</dd>
<dt class="hdlist1"><code>headers_type &amp;headers()</code></dt>
<dd>
<p>Returns the internal headers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;headers() const</code></dt>
<dd>
<p>Returns the internal headers object.</p>
</dd>
<dt class="hdlist1"><code>body_type &amp;body()</code></dt>
<dd>
<p>Returns the internal body object.</p>
</dd>
<dt class="hdlist1"><code>const body_type &amp;body() const</code></dt>
<dd>
<p>Returns the internal body object.</p>
</dd>
<dt class="hdlist1"><code>headers_type &amp;trailers()</code></dt>
<dd>
<p>Returns the internal trailers object.</p>
</dd>
<dt class="hdlist1"><code>const headers_type &amp;trailers() const</code></dt>
<dd>
<p>Returns the internal trailers object.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_13">4.2.16.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#response"><code>response</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_socket">4.2.17. <code>basic_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This template can be used to easily define classes fulfilling the strict
<a href="#server_socket_concept"><code>ServerSocket</code> concept</a> and the strict
<a href="#client_socket_concept"><code>ClientSocket</code> concept</a>
(<a href="#is_server_socket"><code>is_server_socket</code></a> and
<a href="#is_client_socket"><code>is_client_socket</code></a> traits are specialized). These classes
exposes the <code>HTTP/1.1</code> wire format (i.e. a builtin/standalone HTTP server) into
an easy-to-use API.</p>
</div>
<div class="paragraph">
<p>The underlying I/O object is expected to have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is stream-oriented (i.e. no message boundaries; read or write operations
may transfer fewer bytes than requested&#8230;&#8203;).</p>
</li>
<li>
<p>It fulfills the ASIO&#8217;s <code>AsyncReadStream</code> requirement.</p>
</li>
<li>
<p>It fulfills the ASIO&#8217;s <code>AsyncWriteStream</code> requirement.</p>
</li>
<li>
<p>It is backed by a reliable transport or session-layer “connection” with
in-order delivery of octets (i.e. any 8-bit sequence of data).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This class doesn&#8217;t restrict the message, method, path and reason phrase types.
Therefore, the following members are <strong>not</strong> defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>message_type</code></p>
</li>
<li>
<p><code>request_type</code></p>
</li>
<li>
<p><code>response_type</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The API from this class is implemented in terms of composed
operations. As such, you MUST <strong>NOT</strong> initiate any async read operation while
there is another read operation in progress and you MUST <strong>NOT</strong> initiate any
async write operation while there is another write operation in progress. If you
cannot guarantee the ordering of the operations, you should use some queueing
socket (e.g.
<a href="http://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp">
AxioMQ&#8217;s <code>basic_queue_socket</code></a>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You cannot detect the lack of network inactivity properly under this
layer. If you need to implement timeouts, you should do so under the lower
layer.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_8">4.2.17.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Socket</code></dt>
<dd>
<p>The underlying communication channel type. It MUST fulfill the requirements
for ASIO&#8217;s <code>AsyncReadStream</code> and ASIO&#8217;s <code>AsyncWriteStream</code>.</p>
</dd>
<dt class="hdlist1"><code>Settings</code></dt>
<dd>
<p>Traits to define some settings. It defaults to <em>unspecified</em>.</p>
<div class="paragraph">
<p>As a reference, the default traits class has the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">struct</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">reader</span><span class="tok-o">::</span><span class="tok-n">request</span> <span class="tok-n">req_parser</span><span class="tok-p">;</span>
    <span class="tok-k">typedef</span> <span class="tok-n">reader</span><span class="tok-o">::</span><span class="tok-n">response</span> <span class="tok-n">res_parser</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">constexpr</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">body_copy_threshold</span>
        <span class="tok-o">=</span> <span class="tok-n">BOOST_HTTP_SOCKET_DEFAULT_BODY_COPY_THRESHOLD</span><span class="tok-p">;</span>
<span class="tok-p">};</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_8">4.2.17.2. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Socket next_layer_type</code></dt>
<dd>
<p>The type of the underlying communication channel.</p>
</dd>
<dt class="hdlist1"><code>typedef typename next_layer_type::executor_type executor_type</code></dt>
<dd>
<p>The type of the executor associated with the object.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_7">4.2.17.3. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>basic_socket(boost::asio::io_context &amp;io_context, boost::asio::mutable_buffer inbuffer)</code></dt>
<dd>
<p>Constructor. <em>io_context</em> is passed to the constructor from the underlying
stream.</p>
<div class="openblock">
<div class="title">Exceptions:</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>std::invalid_argument</code>: If buffer size is zero.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>template&lt;class&#8230;&#8203; Args&gt; basic_socket(boost::asio::mutable_buffer inbuffer, Args&amp;&amp;&#8230;&#8203; args)</code></dt>
<dd>
<p>Constructor. <em>args</em> are forwarded to the constructor from the underlying
stream.</p>
<div class="openblock">
<div class="title">Exceptions:</div>
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>std::invalid_argument</code>: If buffer size is zero.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>next_layer_type &amp;next_layer()</code></dt>
<dd>
<p>Returns a reference to the underlying stream.</p>
</dd>
<dt class="hdlist1"><code>const next_layer_type &amp;next_layer() const</code></dt>
<dd>
<p>Returns a reference to the underlying stream.</p>
</dd>
<dt class="hdlist1"><code>void open()</code></dt>
<dd>
<p>Change socket state to open.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
See <code>is_open()</code>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
You MUST cancel current ongoing operations and wait for their
completion handlers to be called before call this function. Otherwise, undefined
behaviour is invoked.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>boost::asio::const_buffer upgrade_head() const</code></dt>
<dd>
<p>Return the buffer representing the first few bytes of the upgraded stream (may
be empty).</p>
</dd>
<dt class="hdlist1"><code>void lock_client_to_http10()</code></dt>
<dd>
<p>Lock HTTP to <code>HTTP/1.0</code> version if socket is used as a client socket.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class Message, class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,void(system::error_code, std::size_t)) async_read_chunkext(Message &amp;message, typename Message::headers_type &amp;chunkext, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Initiate an asynchronous operation to read a part of the message body. Handler
is called when at least one byte is read (called with no error set and value
<code>0</code>), when chunk extensions are found (called with no error set and some value
different than <code>0</code>), when the end of message is reached (called with no error
set and value <code>0</code>) or when some error occurs.</p>
<div class="paragraph">
<p><code>message.body()</code>, <code>message.trailers()</code> and <code>chunkext</code> are left in an unspecified
state while the operation is in progress. <code>chunkext.clear()</code> will be called by
this function before the read operation is scheduled.</p>
</div>
<div class="paragraph">
<p>When valid chunk extensions are found, they are stored in <code>chunkext</code> and handler
is called before the chunk bytes are stored in <code>message.body()</code>. The chunk size
is passed to the handler and <code>chunkext</code> data refers to the <strong>next</strong> bytes that
will be pushed into <code>message.body()</code> (i.e. you need to initiate another read
to get the chunk data referred by <code>chunkext</code>).</p>
</div>
<div class="paragraph">
<p>This design is simple (no need for extra error code, simple to explain, simple
to program for, &#8230;&#8203;) and does expose relevant information to the user (e.g. you
can extract message boundaries) without compromising security (read is still
limited by buffer size and you will <strong>not</strong> be exposed to — for instance —
infinite appends into <code>message.body()</code>).</p>
</div>
</dd>
<dt class="hdlist1"><code>template&lt;class Message, class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_chunkext(const Message &amp;message, const typename Message::headers_type &amp;chunkext, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>Initiate an asynchronous operation to write a chunk of the HTTP body data
payload (chunked message). Handler is called with an appropriate argument when
the operation completes.</p>
<div class="paragraph">
<p><code>message.body()</code> and <code>chunkext</code> MUST <strong>NOT</strong> be modified while the operation is in
progress.</p>
</div>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="_socket_concept"><code>Socket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executor_type get_executor()</code></p>
</li>
<li>
<p><code>bool is_open() const</code></p>
</li>
<li>
<p><code>read_state read_state() const</code></p>
</li>
<li>
<p><code>write_state write_state() const</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_some(Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_trailers(Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write(const Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_trailers(const Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_end_of_message(CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_serversocket_concept"><code>ServerSocket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#server_socket_concept"><code>ServerSocket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bool write_response_native_stream() const</code></p>
</li>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_request(Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response(const Response &amp;response, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response_continue(CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response_metadata(const Response &amp;response,
                              CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_clientsocket_concept"><code>ClientSocket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#client_socket_concept"><code>ClientSocket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_request(const Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_request_metadata(const Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_response(Response &amp;response, CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_buffered_socket">4.2.18. <code>basic_buffered_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/buffered_socket.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This template can be used to easily define classes fulfilling the strict
<a href="#server_socket_concept"><code>ServerSocket</code> concept</a> and
<a href="#client_socket_concept"><code>ClientSocket</code> concept</a>. These classes exposes the
<code>HTTP/1.1</code> wire format (i.e. a builtin/standalone HTTP server) into an
easy-to-use API.</p>
</div>
<div class="paragraph">
<p>The underlying I/O object is expected to have the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is stream-oriented (i.e. no message boundaries; read or write operations
may transfer fewer bytes than requested&#8230;&#8203;).</p>
</li>
<li>
<p>It fulfills the ASIO&#8217;s <code>AsyncReadStream</code> requirement.</p>
</li>
<li>
<p>It fulfills the ASIO&#8217;s <code>AsyncWriteStream</code> requirement.</p>
</li>
<li>
<p>It is backed by a reliable transport or session-layer “connection” with
in-order delivery of octets (i.e. any 8-bit sequence of data).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This class doesn&#8217;t restrict the message, method, path and reason phrase types.
Therefore, the following members are <strong>not</strong> defined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>message_type</code></p>
</li>
<li>
<p><code>request_type</code></p>
</li>
<li>
<p><code>response_type</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The API from this class is implemented in terms of composed
operations. As such, you MUST <strong>NOT</strong> initiate any async read operation while
there is another read operation in progress and you MUST <strong>NOT</strong> initiate any
async write operation while there is another write operation in progress. If you
cannot guarantee the ordering of the operations, you should use some queueing
socket (e.g.
<a href="http://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp">
AxioMQ&#8217;s <code>basic_queue_socket</code></a>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You cannot detect the lack of network inactivity properly under this
layer. If you need to implement timeouts, you should do so under the lower
layer.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_9">4.2.18.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Socket</code></dt>
<dd>
<p>The underlying communication channel type. It MUST fulfill the requirements
for ASIO&#8217;s <code>AsyncReadStream</code> and ASIO&#8217;s <code>AsyncWriteStream</code>.</p>
</dd>
<dt class="hdlist1"><code>Settings</code></dt>
<dd>
<p>Traits passed to the underlying <code>Socket</code>. It defaults to <em>unspecified</em>.</p>
</dd>
<dt class="hdlist1"><code>N</code></dt>
<dd>
<p>The internal buffer size. It defaults to
<code>BOOST_HTTP_SOCKET_DEFAULT_BUFFER_SIZE</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_9">4.2.18.2. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Socket next_layer_type</code></dt>
<dd>
<p>The type of the underlying communication channel.</p>
</dd>
<dt class="hdlist1"><code>typedef typename next_layer_type::executor_type executor_type</code></dt>
<dd>
<p>The type of the executor associated with the object.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_8">4.2.18.3. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>basic_buffered_socket(boost::asio::io_context &amp;io_context)</code></dt>
<dd>
<p>Constructor. <em>io_context</em> is passed to the constructor from the underlying
stream.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class&#8230;&#8203; Args&gt; basic_buffered_socket(Args&amp;&amp;&#8230;&#8203; args)</code></dt>
<dd>
<p>Constructor. <em>args</em> are forwarded to the constructor from the underlying
stream.</p>
</dd>
<dt class="hdlist1"><code>next_layer_type &amp;next_layer()</code></dt>
<dd>
<p>Returns a reference to the underlying stream.</p>
</dd>
<dt class="hdlist1"><code>const next_layer_type &amp;next_layer() const</code></dt>
<dd>
<p>Returns a reference to the underlying stream.</p>
</dd>
<dt class="hdlist1"><code>boost::asio::const_buffer upgrade_head() const</code></dt>
<dd>
<p>Return the buffer representing the first few bytes of the upgraded stream (may
be empty).</p>
</dd>
<dt class="hdlist1"><code>void lock_client_to_http10()</code></dt>
<dd>
<p>Lock HTTP to <code>HTTP/1.0</code> version if socket is used as a client socket.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class Message, class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,void(system::error_code, std::size_t)) async_read_chunkext(Message &amp;message, typename Message::headers_type &amp;chunkext, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>See documentation in <a href="#basic_socket"><code>basic_socket</code></a>.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class Message, class CompletionToken&gt; BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, void(system::error_code)) async_write_chunkext(const Message &amp;message, const typename Message::headers_type &amp;chunkext, CompletionToken &amp;&amp;token)</code></dt>
<dd>
<p>See documentation in <a href="#basic_socket"><code>basic_socket</code></a>.</p>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="_socket_concept_2"><code>Socket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>executor_type get_executor()</code></p>
</li>
<li>
<p><code>bool is_open() const</code></p>
</li>
<li>
<p><code>read_state read_state() const</code></p>
</li>
<li>
<p><code>write_state write_state() const</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_some(Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_trailers(Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write(const Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Message, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_trailers(const Message &amp;message, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_end_of_message(CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_serversocket_concept_2"><code>ServerSocket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#server_socket_concept"><code>ServerSocket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>bool write_response_native_stream() const</code></p>
</li>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_request(Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response(const Response &amp;response, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response_continue(CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_response_metadata(const Response &amp;response,
                              CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_clientsocket_concept_2"><code>ClientSocket</code> concept</h6>
<div class="paragraph">
<p>See the <a href="#client_socket_concept"><code>ClientSocket</code> concept</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_request(const Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Request, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_write_request_metadata(const Request &amp;request, CompletionToken &amp;&amp;token)</code></p>
</li>
<li>
<p><code>template&lt;class Response, class CompletionToken&gt;
BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken,
                              void(boost::system::error_code))
async_read_response(Response &amp;response, CompletionToken &amp;&amp;token)</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="server_socket_adaptor">4.2.19. <code>server_socket_adaptor</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/server_socket_adaptor.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class adapts a class fulfilling the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> to implement the <a href="#basic_poly_server_socket"><code>basic_poly_server_socket&lt;Request, Response, Message&gt;</code></a> interface.</p>
</div>
<div class="paragraph">
<p>This design was chosen taking a number of shortcomings in consideration.</p>
</div>
<div class="paragraph">
<p>If the user can control object construction, he might benefit by less levels of
indirection by constructing both (the HTTP socket and its runtime-based
polymorphic adaptor) at once and at a single memory space.</p>
</div>
<div class="paragraph">
<p>The scenario where the user don&#8217;t control the object construction was also taken
in consideration. In these cases, it&#8217;s possible to use the
<code>std::reference_wrapper</code> type found in the <code>&lt;functional&gt;</code> header. There is a
<code>server_socket_adaptor</code> specialization that will do the job for
<code>std::reference_wrapper</code>.</p>
</div>
<div class="paragraph">
<p>Also, if the user needs to query for the specific type at runtime, the user can
do so with a single call to <code>dynamic_cast</code> to the specific polymorphic wrapper
(rather than calling a second function to query for the wrapped object).</p>
</div>
<div class="paragraph">
<p>The design is simple to use, to learn and to read. These values were chosen to
avoid misuse by the user&#8217;s part.</p>
</div>
<div class="paragraph">
<p>Although very different, the name and inspiration were borrowed from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3525.pdf">N3525:
Polymorphic Allocators</a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_10">4.2.19.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Socket</code></dt>
<dd>
<p>The type to be wrapped.</p>
</dd>
<dt class="hdlist1"><code>Request = request</code></dt>
<dd>
<p>The request message type. Default argument is <a href="#request"><code>request</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Response = response</code></dt>
<dd>
<p>The response message type. Default argument is <a href="#response"><code>response</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type. Default argument is <a href="#request_response_wrapper"><code>request_response_wrapper&lt;Request, Response&gt;</code></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_specializations">4.2.19.2. Specializations</h5>
<div class="ulist">
<ul>
<li>
<p><code>server_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_10">4.2.19.3. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Socket next_layer_type</code></dt>
<dd>
<p>The type of the wrapped socket.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_9">4.2.19.4. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class&#8230;&#8203; Args&gt; server_socket_adaptor(Args&amp;&amp;&#8230;&#8203; args)</code></dt>
<dd>
<p>Constructor. <code>args</code> are forwarded to the underlying socket constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Not available under the
<code>server_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>server_socket_adaptor(Socket &amp;socket)</code></dt>
<dd>
<p>Constructor. <code>socket</code> is passed to the <code>std::reference_wrapper</code>
constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only available under the
<code>server_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>next_layer_type &amp;next_layer()</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
<dt class="hdlist1"><code>const next_layer_type &amp;next_layer() const</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="client_socket_adaptor">4.2.20. <code>client_socket_adaptor</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/client_socket_adaptor.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class adapts a class fulfilling the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a> to implement the <a href="#basic_poly_client_socket"><code>basic_poly_client_socket&lt;Request, Response, Message&gt;</code></a> interface.</p>
</div>
<div class="paragraph">
<p>This design was chosen taking a number of shortcomings in consideration.</p>
</div>
<div class="paragraph">
<p>If the user can control object construction, he might benefit by less levels of
indirection by constructing both (the HTTP socket and its runtime-based
polymorphic adaptor) at once and at a single memory space.</p>
</div>
<div class="paragraph">
<p>The scenario where the user doesn&#8217;t control the object construction was also
taken in consideration. In these cases, it&#8217;s possible to use the
<code>std::reference_wrapper</code> type found in the <code>&lt;functional&gt;</code> header. There is a
<code>client_socket_adaptor</code> specialization that will do the job for
<code>std::reference_wrapper</code>.</p>
</div>
<div class="paragraph">
<p>Also, if the user needs to query for the specific type at runtime, the user can
do so with a single call to <code>dynamic_cast</code> to the specific polymorphic wrapper
(rather than calling a second function to query for the wrapped object).</p>
</div>
<div class="paragraph">
<p>The design is simple to use, to learn and to read. These values were chosen to
avoid misuse by the user&#8217;s part.</p>
</div>
<div class="paragraph">
<p>Although very different, the name and inspiration were borrowed from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3525.pdf">N3525:
Polymorphic Allocators</a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_11">4.2.20.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Socket</code></dt>
<dd>
<p>The type to be wrapped.</p>
</dd>
<dt class="hdlist1"><code>Request = request</code></dt>
<dd>
<p>The request message type. Default argument is <a href="#request"><code>request</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Response = response</code></dt>
<dd>
<p>The response message type. Default argument is <a href="#response"><code>response</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type. Default argument is <a href="#request_response_wrapper"><code>request_response_wrapper&lt;Request, Response&gt;</code></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_specializations_2">4.2.20.2. Specializations</h5>
<div class="ulist">
<ul>
<li>
<p><code>client_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_11">4.2.20.3. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Socket next_layer_type</code></dt>
<dd>
<p>The type of the wrapped socket.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_10">4.2.20.4. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class&#8230;&#8203; Args&gt; client_socket_adaptor(Args&amp;&amp;&#8230;&#8203; args)</code></dt>
<dd>
<p>Constructor. <code>args</code> are forwarded to the underlying socket constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Not available under the
<code>client_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>client_socket_adaptor(Socket &amp;socket)</code></dt>
<dd>
<p>Constructor. <code>socket</code> is passed to the <code>std::reference_wrapper</code>
constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only available under the
<code>client_socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>next_layer_type &amp;next_layer()</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
<dt class="hdlist1"><code>const next_layer_type &amp;next_layer() const</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="socket_adaptor">4.2.21. <code>socket_adaptor</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/socket_adaptor.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class adapts a class fulfilling the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> and the <a href="#client_socket_concept"><code>ClientSocket</code> concept</a> to implement
the <a href="#basic_poly_socket"><code>basic_poly_socket&lt;Request, Response, Message&gt;</code></a>
interface.</p>
</div>
<div class="paragraph">
<p>This design was chosen taking a number of shortcomings in consideration.</p>
</div>
<div class="paragraph">
<p>If the user can control object construction, he might benefit by less levels of
indirection by constructing both (the HTTP socket and its runtime-based
polymorphic adaptor) at once and at a single memory space.</p>
</div>
<div class="paragraph">
<p>The scenario where the user doesn&#8217;t control the object construction was also
taken into consideration. In these cases, it&#8217;s possible to use the
<code>std::reference_wrapper</code> type found in the <code>&lt;functional&gt;</code> header. There is a
<code>socket_adaptor</code> specialization that will do the job for
<code>std::reference_wrapper</code>.</p>
</div>
<div class="paragraph">
<p>Also, if the user needs to query for the specific type at runtime, the user can
do so with a single call to <code>dynamic_cast</code> to the specific polymorphic wrapper
(rather than calling a second function to query for the wrapped object).</p>
</div>
<div class="paragraph">
<p>The design is simple to use, to learn and to read. These values were chosen to
avoid misuse by the user&#8217;s part.</p>
</div>
<div class="paragraph">
<p>Although very different, the name and inspiration were borrowed from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3525.pdf">N3525:
Polymorphic Allocators</a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_12">4.2.21.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Socket</code></dt>
<dd>
<p>The type to be wrapped.</p>
</dd>
<dt class="hdlist1"><code>Request = request</code></dt>
<dd>
<p>The request message type. Default argument is <a href="#request"><code>request</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Response = response</code></dt>
<dd>
<p>The response message type. Default argument is <a href="#response"><code>response</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Message = request_response_wrapper&lt;Request, Response&gt;</code></dt>
<dd>
<p>The message type. Default argument is <a href="#request_response_wrapper"><code>request_response_wrapper&lt;Request, Response&gt;</code></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_specializations_3">4.2.21.2. Specializations</h5>
<div class="ulist">
<ul>
<li>
<p><code>socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_member_types_12">4.2.21.3. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef Socket next_layer_type</code></dt>
<dd>
<p>The type of the wrapped socket.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_11">4.2.21.4. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>template&lt;class&#8230;&#8203; Args&gt; socket_adaptor(Args&amp;&amp;&#8230;&#8203; args)</code></dt>
<dd>
<p>Constructor. <code>args</code> are forwarded to the underlying socket constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Not available under the
<code>socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>socket_adaptor(Socket &amp;socket)</code></dt>
<dd>
<p>Constructor. <code>socket</code> is passed to the <code>std::reference_wrapper</code>
constructor.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only available under the
<code>socket_adaptor&lt;std::reference_wrapper&lt;Socket&gt;&gt;</code> specialization.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>next_layer_type &amp;next_layer()</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
<dt class="hdlist1"><code>const next_layer_type &amp;next_layer() const</code></dt>
<dd>
<p>Socket isn&#8217;t exposed directly to avoid confusion over the duplication of
interfaces.</p>
<div class="paragraph">
<p>The name socket is not used because both (the wrapped object and this object
itself) are sockets and it would be confusing.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_to_ptime">4.2.22. <code>header_to_ptime</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-o">&gt;</span>
<span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">posix_time</span><span class="tok-o">::</span><span class="tok-n">ptime</span> <span class="tok-n">header_to_ptime</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">value</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Converts an <em>HTTP-date</em> <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup> field
value into <code>boost::posix_time::ptime</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Values containing extra whitespace at the beginning or at the end of
<em>value</em> will be rejected and no conversion will be done. This behaviour is
intentional.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_13">4.2.22.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_paremeters">4.2.22.2. Paremeters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;value</code></dt>
<dd>
<p>An <em>HTTP-date</em>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value">4.2.22.3. Return value</h5>
<div class="paragraph">
<p>The converted value if <em>value</em> is a valid <em>HTTP-date</em> or
<code>boost::posix_time::ptime(date_time::not_a_date_time)</code> otherwise.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
You can use <code>ptime&#8217;s `is_not_a_date_time()</code> member-function to check if
the conversion failed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_14">4.2.22.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#to_http_date"><code>to_http_date</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="to_http_date">4.2.23. <code>to_http_date</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">String</span><span class="tok-o">&gt;</span>
<span class="tok-n">String</span> <span class="tok-n">to_http_date</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">posix_time</span><span class="tok-o">::</span><span class="tok-n">ptime</span> <span class="tok-o">&amp;</span><span class="tok-n">datetime</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Converts a <code>boost::posix_time::ptime</code> into the preferred string representation
according to section 7.1.1.1 of RFC 7231 (i.e. fixed length/zone/capitalization
subset of the format defined in section 3.3 of RFC 5322).</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_14">4.2.23.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>String</code> concept
(i.e. <code>std::basic_string</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters">4.2.23.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const boost::posix_time::ptime &amp;datetime</code></dt>
<dd>
<p>The timepoint to be converted. It MUST be in UTC timezone.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_2">4.2.23.3. Return value</h5>
<div class="paragraph">
<p>The string representation in the preferred format (a.k.a. <em>IMF-fixdate</em>).</p>
</div>
</div>
<div class="sect4">
<h5 id="_exceptions">4.2.23.4. Exceptions</h5>
<div class="ulist">
<ul>
<li>
<p><code>std::out_of_range</code>: If invalid <em>datetime</em> is given.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_15">4.2.23.5. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#header_to_ptime">header_to_ptime</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_value_all_of">4.2.24. <code>header_value_all_of</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Predicate</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">header_value_all_of</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">header_value</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">Predicate</span> <span class="tok-o">&amp;</span><span class="tok-n">p</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Checks if unary predicate <em>p</em> returns <code>true</code> for all elements from the
comma-separated list defined by the <em>header_value</em> HTTP field value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This algorithm is liberal in what it accepts and it will skip invalid
elements. An invalid element is a sequence, possibly empty, containing no other
character than optional white space (i.e. <code>'\x20'</code> or <code>'\t'</code>).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_15">4.2.24.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
<dt class="hdlist1"><code>Predicate</code></dt>
<dd>
<p>A type whose instances are callable and have the following signature:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">bool</span><span class="tok-p">(</span><span class="tok-n">StringView</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_2">4.2.24.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;header_value</code></dt>
<dd>
<p>The HTTP field value.</p>
</dd>
<dt class="hdlist1"><code>const Predicate &amp;p</code></dt>
<dd>
<p>The functor predicate that will be called for the elements found on the
comma-separated list.</p>
<div class="paragraph">
<p>Optional white space (only at the beginning and at the end) is trimmed before
applying the element to <em>p</em>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_3">4.2.24.3. Return value</h5>
<div class="paragraph">
<p><code>true</code> if <em>p</em> doesn&#8217;t returns <code>false</code> for any element from the list and <code>false</code>
otherwise. This also means that you&#8217;ll get the return value <code>true</code> for empty
lists.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_value_any_of">4.2.25. <code>header_value_any_of</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Predicate</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">header_value_any_of</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">header_value</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">Predicate</span> <span class="tok-o">&amp;</span><span class="tok-n">p</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Checks if unary predicate <em>p</em> returns <code>true</code> for at least one element from the
comma-separated list defined by the <em>header_value</em> HTTP field value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This algorithm is liberal in what it accepts and it will skip invalid
elements. An invalid element is a sequence, possibly empty, containing no other
character than optional white space (i.e. <code>'\x20'</code> or <code>'\t'</code>).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_16">4.2.25.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
<dt class="hdlist1"><code>Predicate</code></dt>
<dd>
<p>A type whose instances are callable and have the following signature:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">bool</span><span class="tok-p">(</span><span class="tok-n">StringView</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_3">4.2.25.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;header_value</code></dt>
<dd>
<p>The HTTP field value.</p>
</dd>
<dt class="hdlist1"><code>const Predicate &amp;p</code></dt>
<dd>
<p>The functor predicate that will be called for the elements found on the
comma-separated list.</p>
<div class="paragraph">
<p>Optional white space (only at the beginning and at the end) is trimmed before
applying the element to <em>p</em>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_4">4.2.25.3. Return value</h5>
<div class="paragraph">
<p><code>true</code> if the <em>p</em> returns <code>true</code> for at least one element from the list and
<code>false</code> otherwise. This also means that you&#8217;ll get the return value <code>false</code> for
empty lists.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_value_none_of">4.2.26. <code>header_value_none_of</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Predicate</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">header_value_none_of</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">header_value</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">Predicate</span> <span class="tok-o">&amp;</span><span class="tok-n">p</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Checks if unary predicate <em>p</em> returns <code>true</code> for no elements from the
comma-separated list defined by the <em>header_value</em> HTTP field value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This algorithm is liberal in what it accepts and it will skip invalid
elements. An invalid element is a sequence, possibly empty, containing no other
character than optional white space (i.e. <code>'\x20'</code> or <code>'\t'</code>).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_17">4.2.26.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
<dt class="hdlist1"><code>Predicate</code></dt>
<dd>
<p>A type whose instances are callable and have the following signature:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">bool</span><span class="tok-p">(</span><span class="tok-n">StringView</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_4">4.2.26.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;header_value</code></dt>
<dd>
<p>The HTTP field value.</p>
</dd>
<dt class="hdlist1"><code>const Predicate &amp;p</code></dt>
<dd>
<p>The functor predicate that will be called for the elements found on the
comma-separated list.</p>
<div class="paragraph">
<p>Optional white space (only at the beginning and at the end) is trimmed before
applying the element to <em>p</em>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_5">4.2.26.3. Return value</h5>
<div class="paragraph">
<p><code>true</code> if <em>p</em> doesn&#8217;t returns <code>true</code> for any element from the list and <code>false</code>
otherwise. This also means that you&#8217;ll get the return value <code>true</code> for empty
lists.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_value_for_each">4.2.27. <code>header_value_for_each</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">F</span><span class="tok-o">&gt;</span>
<span class="tok-n">F</span> <span class="tok-n">header_value_for_each</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">header_value</span><span class="tok-p">,</span> <span class="tok-n">F</span> <span class="tok-n">f</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Apply <em>f</em> for each element from the comma-separated list defined by the
<em>header_value</em> HTTP field value.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This algorithm is liberal in what it accepts and it will skip invalid
elements. An invalid element is a sequence, possibly empty, containing no other
character than optional white space (i.e. <code>'\x20'</code> or <code>'\t'</code>).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_18">4.2.27.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
<dt class="hdlist1"><code>F</code></dt>
<dd>
<p>A type whose instances are callable and have the following signature:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">StringView</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_5">4.2.27.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;header_value</code></dt>
<dd>
<p>The HTTP field value.</p>
</dd>
<dt class="hdlist1"><code>F f</code></dt>
<dd>
<p>The functor that will be called for the elements found on the comma-separated
list.</p>
<div class="paragraph">
<p>Optional white space (only at the beginning and at the end) is trimmed before
applying the element to <em>f</em>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_6">4.2.27.3. Return value</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">move</span><span class="tok-p">(</span><span class="tok-n">f</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="etag_match_strong">4.2.28. <code>etag_match_strong</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">etag_match_strong</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">a</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">b</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Check if <em>a</em> and <em>b</em> match.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This function doesn&#8217;t pedantically check if both arguments are actual entity
tags and you should validate at least one of the arguments yourself.</p>
</div>
<div class="paragraph">
<p>Builtin validation is only done enough to protect against attacks.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_19">4.2.28.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_6">4.2.28.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;a</code></dt>
<dd>
<p>The entity tag to compare against <em>b</em>.</p>
</dd>
<dt class="hdlist1"><code>const StringView &amp;b</code></dt>
<dd>
<p>The entity tag to compare against <em>a</em>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_7">4.2.28.3. Return value</h5>
<div class="paragraph">
<p><code>true</code> if the entity tags match, using the strong comparison <sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> or <code>false</code> otherwise.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="etag_match_weak">4.2.29. <code>etag_match_weak</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">StringView</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">etag_match_weak</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">a</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">StringView</span> <span class="tok-o">&amp;</span><span class="tok-n">b</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Check if <em>a</em> and <em>b</em> match.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This function doesn&#8217;t pedantically check if both arguments are actual entity
tags and you should validate at least one of the arguments yourself.</p>
</div>
<div class="paragraph">
<p>Builtin validation is only done enough to protect against attacks.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_20">4.2.29.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>It MUST fulfill the requirements of the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_7">4.2.29.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const StringView &amp;a</code></dt>
<dd>
<p>The entity tag to compare against <em>b</em>.</p>
</dd>
<dt class="hdlist1"><code>const StringView &amp;b</code></dt>
<dd>
<p>The entity tag to compare against <em>a</em>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_8">4.2.29.3. Return value</h5>
<div class="paragraph">
<p><code>true</code> if the entity tags match, using the weak comparison <sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup> or <code>false</code> otherwise.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="request_continue_required">4.2.30. <code>request_continue_required</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/query.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-o">&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">request_continue_required</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">request</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Check if the request represented by <em>request</em> requires a “100 (Continue)
response” <sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>If you can properly process and reply the message without its body, you&#8217;re free
to go. Otherwise, you should send a “100 (Continue) response” to ask for the
message body from the HTTP client.</p>
</div>
<div class="paragraph">
<p>This feature was designed to decrease network traffic, by allowing servers to
sooner reject messages that would be discarded anyway.</p>
</div>
<div class="paragraph">
<p>The name <em>required</em> is used instead <em>supported</em>, because an action from the
server is required.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_21">4.2.30.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_8">4.2.30.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const Request &amp;request</code></dt>
<dd>
<p>The read message.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_9">4.2.30.3. Return value</h5>
<div class="paragraph">
<p>Whether the request represented by <em>request</em> requires a “100 (Continue)
response”.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="request_upgrade_desired">4.2.31. <code>request_upgrade_desired</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/query.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-p">,</span>
         <span class="tok-k">class</span> <span class="tok-nc">StringView</span> <span class="tok-o">=</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span>
             <span class="tok-k">typename</span> <span class="tok-n">Request</span><span class="tok-o">::</span><span class="tok-n">headers_type</span><span class="tok-o">::</span><span class="tok-n">mapped_type</span><span class="tok-o">::</span><span class="tok-n">value_type</span><span class="tok-o">&gt;&gt;</span>
<span class="tok-kt">bool</span> <span class="tok-n">request_upgrade_desired</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">request</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Check if the client desires to initiate a protocol upgrade.</p>
</div>
<div class="paragraph">
<p>The desired protocols are present in the <code>"upgrade"</code> header as a comma-separated
list.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
You MUST <strong>NOT</strong> upgrade to a protocol listed in the <code>"upgrade"</code> header
if this function returns <code>false</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The upgrade desire can always be safely ignored.</p>
</div>
<div class="paragraph">
<p>The user MUST wait till the whole request is received before proceeding to the
protocol upgrade.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_22">4.2.31.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>StringView</code></dt>
<dd>
<p>A type fulfilling the requirements for the <code>StringView</code> concept
(i.e. <code>boost::basic_string_view</code>).</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_9">4.2.31.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>const Request &amp;request</code></dt>
<dd>
<p>The read message.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_10">4.2.31.3. Return value</h5>
<div class="paragraph">
<p>Whether the client desires to initiate a protocol upgrade.</p>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_16">4.2.31.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#header_value_any_of"><code>header_value_any_of</code></a></p>
</li>
<li>
<p><a href="#header_value_for_each"><code>header_value_for_each</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="async_response_transmit_file">4.2.32. <code>async_response_transmit_file</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/file_server.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function has two overloads.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">ServerSocket</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Response</span><span class="tok-p">,</span>
         <span class="tok-k">class</span> <span class="tok-nc">CompletionToken</span><span class="tok-o">&gt;</span>
<span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span>
<span class="tok-n">async_response_transmit_file</span><span class="tok-p">(</span><span class="tok-n">ServerSocket</span> <span class="tok-o">&amp;</span><span class="tok-n">socket</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">imessage</span><span class="tok-p">,</span>
                             <span class="tok-n">Response</span> <span class="tok-o">&amp;</span><span class="tok-n">omessage</span><span class="tok-p">,</span>
                             <span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">filesystem</span><span class="tok-o">::</span><span class="tok-n">path</span> <span class="tok-o">&amp;</span><span class="tok-n">file</span><span class="tok-p">,</span>
                             <span class="tok-n">CompletionToken</span> <span class="tok-o">&amp;&amp;</span><span class="tok-n">token</span><span class="tok-p">);</span> <span class="tok-c1">// (1)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">ServerSocket</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Response</span><span class="tok-p">,</span>
         <span class="tok-k">class</span> <span class="tok-nc">CompletionToken</span><span class="tok-o">&gt;</span>
<span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span>
<span class="tok-n">async_response_transmit_file</span><span class="tok-p">(</span><span class="tok-n">ServerSocket</span> <span class="tok-o">&amp;</span><span class="tok-n">socket</span><span class="tok-p">,</span> <span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">imessage</span><span class="tok-p">,</span>
                             <span class="tok-n">Response</span> <span class="tok-o">&amp;</span><span class="tok-n">omessage</span><span class="tok-p">,</span>
                             <span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">filesystem</span><span class="tok-o">::</span><span class="tok-n">path</span> <span class="tok-o">&amp;</span><span class="tok-n">file</span><span class="tok-p">,</span>
                             <span class="tok-kt">bool</span> <span class="tok-n">is_head_request</span><span class="tok-p">,</span>
                             <span class="tok-n">CompletionToken</span> <span class="tok-o">&amp;&amp;</span><span class="tok-n">token</span><span class="tok-p">);</span> <span class="tok-c1">// (2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function will handle a big part of the file serving job for you, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;ll interpret and process the request headers. However, it doesn&#8217;t process
the request method nor the the input path. This means you still have to
guarantee the method is applicable and you&#8217;re also expected to resolve the
input path to a valid local file path.</p>
</li>
<li>
<p>It&#8217;ll fill all the applicable response headers appropriate to the request.</p>
</li>
<li>
<p>It&#8217;ll interpret the file attributes to process conditional requests and
partial download. However, MIME detection (the <code>"content-type"</code> optional
header) is still left for the user to handle.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Summarizing your responsibilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ensure it is a <code>"GET"</code> method or a method with similar semantics before
calling this function. <em>Overload 2</em> also accepts the <code>"HEAD"</code> method.</p>
</li>
<li>
<p>Resolve the input URL to the appropriate file.</p>
</li>
<li>
<p><strong>Optional</strong>: MIME detection (the <code>"content-type"</code> header).</p>
</li>
<li>
<p><strong>Optional</strong>: <code>ETag</code> detection (see
<a href="#async_response_transmit_file_etag">below</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A method with semantics similar to the <code>"GET"</code> method is any method fulfilling
the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The body data payload for the response message is compatible.</p>
</li>
<li>
<p>The following headers for the request message have the same meaning:</p>
<div class="ulist">
<ul>
<li>
<p><code>"if-modified-since"</code></p>
</li>
<li>
<p><code>"if-range"</code></p>
</li>
<li>
<p><code>"if-unmodified-since"</code></p>
</li>
<li>
<p><code>"range"</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>The following headers for the response message have the same meaning or don&#8217;t
affect the message processing:</p>
<div class="ulist">
<ul>
<li>
<p><code>"accept-ranges"</code></p>
</li>
<li>
<p><code>"content-range"</code></p>
</li>
<li>
<p><code>"content-type"</code></p>
</li>
<li>
<p><code>"date"</code></p>
</li>
<li>
<p><code>"last-modified"</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>The same set of status code for the response are applicable.</p>
<div class="ulist">
<ul>
<li>
<p><code>"200 OK"</code></p>
</li>
<li>
<p><code>"206 Partial Content"</code></p>
</li>
<li>
<p><code>"304 Not Modified"</code></p>
</li>
<li>
<p><code>"412 Precondition Failed"</code></p>
</li>
<li>
<p><code>"416 Range Not Satisfiable"</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This function will call the handler with <code>file_server_errc::io_error</code> if
any operation on the <strong>file stream</strong> fails or throws an exception.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The response headers filled by this function MUST NOT be sent through
trailers. Therefore, this function will not do any operation and it will call
the handler with an <code>error_code</code> (<code>file_server_errc::write_state_not_supported</code>)
set if you pass a socket for which the headers were already sent.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p>async_response_transmit_file will make use of the streaming interface only if
available.</p>
</div>
<div class="paragraph">
<p>If you want to avoid wasting memory under HTTP/1.0 and other non-streaming
capable channels, starting points for two solutions are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reject channels without a streaming interface (e.g. HTTP/1.0). RFC 2068
(a.k.a.  HTTP/1.1) has been available since January 1997.</p>
</li>
<li>
<p>Write a custom message type that adapts the filestream to the message concept
and specialize the algorithm for such message.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>omessage.body()</code> will be used as output buffer. If
<code>omessage.body().capacity() == 0</code>, an unspecified buffer size will be used and
it is very likely it&#8217;ll be highly inefficient.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="async_response_transmit_file_etag">4.2.32.1. ETags</h5>
<div class="paragraph">
<p>An ETag is a string that identify a representation of a resource. The ETag can
be used to perform conditional requests more robust than the ones done with
dates (limited by HTTP to seconds-based precision). In the conditional request
context, an etag is a validator.</p>
</div>
<div class="paragraph">
<p>If you want to make use of the ETag implementation, just set the <code>"etag"</code> header
in the <code>omessage</code> object to the appropriate value, as described below (also
described in more details in RFC7232).</p>
</div>
<div class="paragraph">
<p>The first decision you must do if you decide to provide an etag is if you&#8217;re
going to provide a strong validator or a weak validator.</p>
</div>
<div class="sect5">
<h6 id="_strong_validators">Strong validators</h6>
<div class="paragraph">
<p>A strong validator changes whenever a change occurs to the representation data
that would be observable in the payload body. A strong validator is unique
across all versions of all representations associated with a particular resource
over time.</p>
</div>
<div class="paragraph">
<p>A strong etag has the form (specified in Augmented Backus-Naur Form (ABNF)
notation of [RFC5234]):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>strong-etag = DQUOTE *etagc DQUOTE
etagc       = %x21 / %x23-7E / obs-text
            ; VCHAR except double quotes, plus obs-text
obs-text    = %x80-FF</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Some recipients might perform backslash unescaping. Therefore, it is a
good practice to avoid backslash characters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>"xyasdzzy"</code></p>
</li>
<li>
<p><code>"xyz9czy"</code></p>
</li>
<li>
<p><code>""</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
A strong validator might change for reasons other than a change to the
representation data.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
There is no implication of uniqueness across representations of different
resources.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_weak_validators">Weak validators</h6>
<div class="paragraph">
<p>A weak validator might not change for every change to the representation data.</p>
</div>
<div class="paragraph">
<p>A weak etag has the form (specified in Augmented Backus-Naur Form (ABNF)
notation of [RFC5234]):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>weak-etag  = weak opaque-tag
weak       = %x57.2F ; "W/", case-sensitive
opaque-tag = DQUOTE *etagc DQUOTE
etagc      = %x21 / %x23-7E / obs-text
           ; VCHAR except double quotes, plus obs-text
obs-text   = %x80-FF</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
Some recipients might perform backslash unescaping. Therefore, it is a
good practice to avoid backslash characters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Some examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>W/"xyasdzzy"</code></p>
</li>
<li>
<p><code>W/"xyz9czy"</code></p>
</li>
<li>
<p><code>W/""</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_template_parameters_23">4.2.32.2. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ServerSocket</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#server_socket_concept"><code>ServerSocket
concept</code></a>.</p>
</dd>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#request_concept"><code>Request</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#response_concept"><code>Response</code> concept</a>.</p>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>Response::body_type</code> MUST fulfill the following extra requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Its elements MUST be stored contiguously (e.g. <code>std::vector</code>).</p>
</li>
<li>
<p>It MUST support C++11 <code>std::vector</code> capicity and data semantics
(<em>vector.capacity</em> and <em>vector.data</em>, respectively).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These extra requirements are posed because file APIs are defined in terms of
buffer <sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup> operations.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>CompletionToken</code></dt>
<dd>
<p>Must fulfill the ASIO requirements for a completion token.</p>
<div class="paragraph">
<p>The used handler signature is <code>void(boost::system::error_code)</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_10">4.2.32.3. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ServerSocket &amp;socket</code></dt>
<dd>
<p>The socket associated with the <em>imessage</em> and <em>omessage</em> that will be used for
the response.</p>
</dd>
<dt class="hdlist1"><code>const Request &amp;imessage</code></dt>
<dd>
<p>The request message received.</p>
</dd>
<dt class="hdlist1"><code>Response &amp;omessage</code></dt>
<dd>
<p>The message object that should be used to reply the message.</p>
<div class="paragraph">
<p>The user might be interested in filling some extra headers here like
<code>"content-type"</code> or cache policies.</p>
</div>
</dd>
<dt class="hdlist1"><code>const filesystem::path &amp;file</code></dt>
<dd>
<p>The requested file that should be transmitted.</p>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
If you cannot guarantee the <em>file</em> did not change twice during the
second covered by the last write time, you should remove all <code>"range"</code> and
<code>"if-range"</code> headers from <em>imessage</em> before calling this function. It&#8217;s possible
to construct a more robust file server by making use of system-level APIs that
can provide unique identifiers for file revisions.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>bool is_head_request</code></dt>
<dd>
<p>Whether the request was made with a <code>"HEAD"</code> method.</p>
<div class="paragraph">
<p>If the received request isn&#8217;t <code>"GET"</code> nor <code>"HEAD"</code>, you MAY remove all <code>"range"</code>
and <code>"if-range"</code> headers and pass the value <code>false</code> to this argument.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Available only for <em>overload 2</em>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>CompletionToken &amp;&amp;token</code></dt>
<dd>
<p>The token from which the handler and the return value are extracted.</p>
<div class="paragraph">
<p>The extracted handler is called when the operation completes.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_11">4.2.32.4. Return value</h5>
<div class="paragraph">
<p>Extracted using <em>token</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_17">4.2.32.5. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#file_server_errc">file_server_errc</a></p>
</li>
<li>
<p><a href="#async_response_transmit_dir">async_response_transmit_dir</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="async_response_transmit_dir">4.2.33. <code>async_response_transmit_dir</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/file_server.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function has two overloads.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">ServerSocket</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">ConvertibleToPath</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-p">,</span>
         <span class="tok-k">class</span> <span class="tok-nc">Response</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">CompletionToken</span><span class="tok-o">&gt;</span>
<span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span>
<span class="tok-n">async_response_transmit_dir</span><span class="tok-p">(</span><span class="tok-n">ServerSocket</span> <span class="tok-o">&amp;</span><span class="tok-n">socket</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">ConvertibleToPath</span> <span class="tok-o">&amp;</span><span class="tok-n">ipath</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">imessage</span><span class="tok-p">,</span> <span class="tok-n">Response</span> <span class="tok-o">&amp;</span><span class="tok-n">omessage</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">filesystem</span><span class="tok-o">::</span><span class="tok-n">path</span> <span class="tok-o">&amp;</span><span class="tok-n">root_dir</span><span class="tok-p">,</span>
                            <span class="tok-n">CompletionToken</span> <span class="tok-o">&amp;&amp;</span><span class="tok-n">token</span><span class="tok-p">);</span> <span class="tok-c1">// (1)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">ServerSocket</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">ConvertibleToPath</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Request</span><span class="tok-p">,</span>
         <span class="tok-k">class</span> <span class="tok-nc">Response</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">Predicate</span><span class="tok-p">,</span> <span class="tok-k">class</span> <span class="tok-nc">CompletionToken</span><span class="tok-o">&gt;</span>
<span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span>
<span class="tok-n">async_response_transmit_dir</span><span class="tok-p">(</span><span class="tok-n">ServerSocket</span> <span class="tok-o">&amp;</span><span class="tok-n">socket</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">ConvertibleToPath</span> <span class="tok-o">&amp;</span><span class="tok-n">ipath</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">Request</span> <span class="tok-o">&amp;</span><span class="tok-n">imessage</span><span class="tok-p">,</span> <span class="tok-n">Response</span> <span class="tok-o">&amp;</span><span class="tok-n">omessage</span><span class="tok-p">,</span>
                            <span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">filesystem</span><span class="tok-o">::</span><span class="tok-n">path</span> <span class="tok-o">&amp;</span><span class="tok-n">root_dir</span><span class="tok-p">,</span>
                            <span class="tok-n">Predicate</span> <span class="tok-n">filter</span><span class="tok-p">,</span> <span class="tok-n">CompletionToken</span> <span class="tok-o">&amp;&amp;</span><span class="tok-n">token</span><span class="tok-p">);</span> <span class="tok-c1">// (2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function does a lot more than just sending bytes. It carries the
responsibilities from <a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a>, but add a few more of its own:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It&#8217;ll also handle the HTTP method.</p>
</li>
<li>
<p>It&#8217;ll also handle the file resolution. It does so with respect to the given
<em>root_dir</em> argument.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The only feature missing is mime support (<code>"content-type"</code> header). It cannot be
done reliably within this abstraction.</p>
</div>
<div class="paragraph">
<p>This function will handle even the start line and the only acceptable
<code>write_state</code> is <code>empty</code>. It&#8217;ll fail on any other <code>write_state</code>.</p>
</div>
<div class="paragraph">
<p>All urls are absolute, but are absolute with respect to the given
<em>root_dir</em>. This interface provides no means to disable this security check. If
the user needs that much complex logic, then it should write its own path
resolving solution and use <a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
This function will call the handler with
<code>file_server_category::file_not_found</code> if the requested file, with respect to
the given <em>root_dir</em>, cannot be found. The channel remains untouched in this
case, giving the user the opportunity to send custom 404 messages.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
This function will call the handler with
<code>file_server_category::file_type_not_supported</code> if resolution finishes but this
function cannot process the result because the file is not regular (directories,
block devices&#8230;&#8203;). The channel is also left untouched, giving the user the
opportunity to use another HTTP consumer.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_template_parameters_24">4.2.33.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ServerSocket</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>ConvertibleToPath</code></dt>
<dd>
<p>A type whose instances can be used to construct a <code>boost::filesystem::path</code>
object.</p>
</dd>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#request_concept"><code>Request</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>Must fulfill the requirements for the <a href="#response_concept"><code>Response</code> concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Predicate</code></dt>
<dd>
<p>A type whose instances are callable and have the following signature:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">bool</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">filesystem</span><span class="tok-o">::</span><span class="tok-n">path</span> <span class="tok-o">&amp;</span><span class="tok-n">resolved_path</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>CompletionToken</code></dt>
<dd>
<p>Must fulfill the ASIO requirements for a completion token.</p>
<div class="paragraph">
<p>The used handler signature is <code>void(boost::system::error_code)</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_parameters_11">4.2.33.2. Parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ServerSocket &amp;socket</code></dt>
<dd>
<p>The socket associated with the <em>imessage</em> and <em>omessage</em> that will be used for
the response.</p>
</dd>
<dt class="hdlist1"><code>const ConvertibleToPath &amp;ipath</code></dt>
<dd>
<p><em>ipath</em> (standing for input path) is the <strong>parsed path</strong> from the requested url.</p>
<div class="paragraph">
<p>It&#8217;s guaranteed that it&#8217;ll only be used to construct a <code>boost::filesystem::path</code>
object. Thus, the user can fake the requested path to force an <em>internal
redirect</em>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
This is the input <strong>path component</strong>, not the input URL. Therefore, you
MUST parse the input url before dispatching it to this function and only the
path component must be forwarded. Extracting the path is an extra responsibility
for the user, but it is an useful abstraction for scenarios where the user
doesn&#8217;t control the served root dir. Thanks to the security check, this
<em>internal redirect</em> trick doesn&#8217;t work for files outside the <em>root_dir</em>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>const Request &amp;imessage</code></dt>
<dd>
<p>The request message received.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Any request method is acceptable, but any method other than <code>"GET"</code> and
<code>"HEAD"</code> will be responded with <code>"405 Method Not Allowed"</code>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>Response &amp;omessage</code></dt>
<dd>
<p>The message object that should be used to reply the message.</p>
<div class="paragraph">
<p>The user might be interested in filling some extra headers here like
<code>"content-type"</code> or cache policies.</p>
</div>
</dd>
<dt class="hdlist1"><code>const boost::filesystem::path &amp;root_dir</code></dt>
<dd>
<p>The dir to be interpreted as the root dir of requested files.</p>
</dd>
<dt class="hdlist1"><code>Predicate filter</code></dt>
<dd>
<p>It is applied to the resolved path as the last step before proceeding to file
and network operations.</p>
<div class="paragraph">
<p>If filter returns <code>false</code>, the functions finishes before touching the channel,
with the error_code <code>file_server_category::filter_set</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
It&#8217;s possible to use a stateful non-pure <em>filter</em> to add response headers
and properly process mime types (content-type header).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<em>filter</em> can also be used to redirect files by modifying the input arg.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This function might throw if <em>filter</em> throws. In this case, we provide the
basic exception guarantee.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Available only for <em>overload 2</em>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>CompletionToken &amp;&amp;token</code></dt>
<dd>
<p>The token from which the handler and the return value are extracted.</p>
<div class="paragraph">
<p>The extracted handler is called when the operation completes.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_return_value_12">4.2.33.3. Return value</h5>
<div class="paragraph">
<p>Extracted using <em>token</em>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_18">4.2.33.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#file_server_errc"><code>file_server_errc</code></a></p>
</li>
<li>
<p><a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="read_state">4.2.34. <code>read_state</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/read_state.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-k">class</span> <span class="tok-nc">read_state</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Represents the current state in the HTTP incoming request or HTTP incoming
response.</p>
</div>
<div class="paragraph">
<p>Be prepared to face multiple state changes after a single action is scheduled
(e.g. you issue <code>read_message</code> action and the state already changed to
<code>finished</code> when the handler is invoked).</p>
</div>
<div class="sect4">
<h5 id="_member_constants_incoming_request">4.2.34.1. Member constants (incoming request)</h5>
<div class="imageblock">
<div class="content">
<img src="read_request_state.png" alt="read request state" width="494" height="611">
</div>
<div class="title">Figure 2. Incoming request</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>empty</code></dt>
<dd>
<p>This is the initial state. It means that the request object wasn&#8217;t read yet.</p>
<div class="paragraph">
<p>At this state, you can only issue a <code>read_request</code> action.</p>
</div>
</dd>
<dt class="hdlist1"><code>message_ready</code></dt>
<dd>
<p>This state is reached from the <code>empty</code> state, once you ask for a new message.</p>
<div class="paragraph">
<p>No more <code>read_request</code> actions can be issued from this state.</p>
</div>
<div class="paragraph">
<p>From this state, you can issue the <code>read_some</code> action. The state will change to
<code>body_ready</code> once all body was read. In streaming connections (e.g. HTTP/1.1
chunked entities), this condition (body fully received) might never happen.</p>
</div>
<div class="paragraph">
<p>Once this state is reached, you can safely use the read start line and the
headers.</p>
</div>
</dd>
<dt class="hdlist1"><code>body_ready</code></dt>
<dd>
<p>This state is reached from the <code>message_ready</code>, once the http producer
(e.g. embedded server) fully received the message body.</p>
<div class="paragraph">
<p>From this state, you can only issue the <code>read_trailers</code> action.</p>
</div>
<div class="paragraph">
<p>Once this state is reached, you can safely assume that no more body parts will
be received.</p>
</div>
</dd>
<dt class="hdlist1"><code>finished</code></dt>
<dd>
<p>It means the message is complete and you can no longer issue another
<code>read_request</code> until something else is done (e.g. send another http
response). This is a different/special value, because the “something else to
do” might not be related to read actions.</p>
<div class="paragraph">
<p>It can be reached from <code>body_ready</code> state, after all trailers have been
received. It&#8217;s safe to assume that all message data is available at the time
this state is reached.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_constants_incoming_response">4.2.34.2. Member constants (incoming response)</h5>
<div class="imageblock">
<div class="content">
<img src="read_response_state.png" alt="read response state" width="498" height="433">
</div>
<div class="title">Figure 3. Incoming response</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>empty</code></dt>
<dd>
<p>This is the initial state.</p>
<div class="paragraph">
<p>There are two ways to interpret this state. It might mean that the response
object wasn&#8217;t read yet.</p>
</div>
<div class="paragraph">
<p>Another interpretation is that it was reached from the <code>body_ready</code> state
(directly — through a call to <code>read_trailers</code> — or indirectly — through a call
to <code>read_some</code> or <code>read_response</code>), after all trailers have been received. It&#8217;s
safe to assume that all message data is available if this is the case.</p>
</div>
<div class="paragraph">
<p>At this state, you can only issue a <code>read_response</code> action.</p>
</div>
</dd>
<dt class="hdlist1"><code>message_ready</code></dt>
<dd>
<p>This state is reached from the <code>empty</code> state, once you ask for a new message.</p>
<div class="paragraph">
<p>No more <code>read_response</code> actions can be issued from this state.</p>
</div>
<div class="paragraph">
<p>From this state, you can issue the <code>read_some</code> action. The state will change to
<code>body_ready</code> once all body was read. In streaming connections (e.g. HTTP/1.1
chunked entities), this condition (body fully received) might never happen.</p>
</div>
<div class="paragraph">
<p>Once this state is reached, you can safely use the read start line and the
headers.</p>
</div>
</dd>
<dt class="hdlist1"><code>body_ready</code></dt>
<dd>
<p>This state is reached from the <code>message_ready</code>, once the http producer
(e.g. an http client) fully received the message body.</p>
<div class="paragraph">
<p>From this state, you can only issue the <code>read_trailers</code> action.</p>
</div>
<div class="paragraph">
<p>Once this state is reached, you can safely assume that no more body parts will
be received.</p>
</div>
</dd>
<dt class="hdlist1"><code>finished</code> (<strong>UNUSED</strong>)</dt>
<dd>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only makes sense in server mode, when reading an incoming request. In
client mode, <code>empty</code> target state is used instead.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_19">4.2.34.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#write_state"><code>write_state</code></a></p>
</li>
<li>
<p><a href="#socket_concept"><code>Socket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="write_state">4.2.35. <code>write_state</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/write_state.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-k">class</span> <span class="tok-nc">write_state</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Represents the current state in the HTTP outgoing response or HTTP outgoing
request.</p>
</div>
<div class="sect4">
<h5 id="_member_constants_outgoing_response">4.2.35.1. Member constants (outgoing response)</h5>
<div class="imageblock">
<div class="content">
<img src="write_response_state.png" alt="write response state" width="406" height="698">
</div>
<div class="title">Figure 4. Outgoing response</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>empty</code></dt>
<dd>
<p>This is the initial state.</p>
<div class="paragraph">
<p>It means that the response object hasn&#8217;t been sent yet.</p>
</div>
<div class="paragraph">
<p>At this state, you can only issue the metadata or issue a continue action, if
continue is supported/used in this HTTP session. Even if continue was requested,
issue a continue action is optional and only required if you need the request&#8217;s
body.</p>
</div>
</dd>
<dt class="hdlist1"><code>continue_issued</code></dt>
<dd>
<p>This state is reached from the <code>empty</code> state, once you issue a continue
action.</p>
<div class="paragraph">
<p>No more continue actions can be issued from this state.</p>
</div>
</dd>
<dt class="hdlist1"><code>metadata_issued</code></dt>
<dd>
<p>This state can be reached either from <code>empty</code> or <code>continue_issued</code>.</p>
<div class="paragraph">
<p>It happens when the metadata (start line + header section) is issued (through
<code>write_response_metadata</code>).</p>
</div>
<div class="paragraph">
<p>From this state, you can only issue the body, the trailers or the end of the
message.</p>
</div>
</dd>
<dt class="hdlist1"><code>finished</code></dt>
<dd>
<p>The message is considered complete once this state is reached.</p>
<div class="paragraph">
<p>You can no longer issue anything once this state is reached. The underlying
channel will change the outgoing_state to <code>empty</code> once some unspecified event
occurs. This event is usually a new request.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_constants_outgoing_request">4.2.35.2. Member constants (outgoing request)</h5>
<div class="imageblock">
<div class="content">
<img src="write_request_state.png" alt="write request state" width="805" height="306">
</div>
<div class="title">Figure 5. Outgoing request</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>empty</code></dt>
<dd>
<p>This is the initial state.</p>
<div class="paragraph">
<p>It means that the request object hasn&#8217;t been sent yet.</p>
</div>
<div class="paragraph">
<p>At this state, you can only issue the metadata.</p>
</div>
</dd>
<dt class="hdlist1"><code>continue_issued</code> (<strong>UNUSED</strong>)</dt>
<dd>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only makes sense in server mode, when sending an outgoing response.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>metadata_issued</code></dt>
<dd>
<p>This state can be reached from <code>empty</code>.</p>
<div class="paragraph">
<p>It happens when the metadata (start line + header section) is issued (through
<code>write_request_metadata</code>).</p>
</div>
<div class="paragraph">
<p>From this state, you can only issue the body, the trailers or the end of the
message.</p>
</div>
</dd>
<dt class="hdlist1"><code>finished</code> (<strong>UNUSED</strong>)</dt>
<dd>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only makes sense in server mode, when sending an outgoing response. In
client mode, <code>empty</code> target state is used instead.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_20">4.2.35.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#read_state"><code>read_state</code></a></p>
</li>
<li>
<p><a href="#socket_concept"><code>Socket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="status_code">4.2.36. <code>status_code</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/status_code.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-k">class</span> <span class="tok-nc">status_code</span><span class="tok-o">:</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">uint_fast16_t</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This scoped enumeration defines the values for the
<a href="http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml">
“Hypertext Transfer Protocol (HTTP) Status Code Registry”</a>.</p>
</div>
<div class="sect4">
<h5 id="_member_constants">4.2.36.1. Member constants</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>continue_request</code></dt>
<dd>
<p><code>100</code></p>
</dd>
<dt class="hdlist1"><code>switching_protocols</code></dt>
<dd>
<p><code>101</code></p>
</dd>
<dt class="hdlist1"><code>processing</code></dt>
<dd>
<p><code>102</code></p>
</dd>
<dt class="hdlist1"><code>ok</code></dt>
<dd>
<p><code>200</code></p>
</dd>
<dt class="hdlist1"><code>created</code></dt>
<dd>
<p><code>201</code></p>
</dd>
<dt class="hdlist1"><code>accepted</code></dt>
<dd>
<p><code>202</code></p>
</dd>
<dt class="hdlist1"><code>non_authoritative_information</code></dt>
<dd>
<p><code>203</code></p>
</dd>
<dt class="hdlist1"><code>no_content</code></dt>
<dd>
<p><code>204</code></p>
</dd>
<dt class="hdlist1"><code>reset_content</code></dt>
<dd>
<p><code>205</code></p>
</dd>
<dt class="hdlist1"><code>partial_content</code></dt>
<dd>
<p><code>206</code></p>
</dd>
<dt class="hdlist1"><code>multi_status</code></dt>
<dd>
<p><code>207</code></p>
</dd>
<dt class="hdlist1"><code>already_reported</code></dt>
<dd>
<p><code>208</code></p>
</dd>
<dt class="hdlist1"><code>im_used</code></dt>
<dd>
<p><code>226</code></p>
</dd>
<dt class="hdlist1"><code>multiple_choices</code></dt>
<dd>
<p><code>300</code></p>
</dd>
<dt class="hdlist1"><code>moved_permanently</code></dt>
<dd>
<p><code>301</code></p>
</dd>
<dt class="hdlist1"><code>found</code></dt>
<dd>
<p><code>302</code></p>
</dd>
<dt class="hdlist1"><code>see_other</code></dt>
<dd>
<p><code>303</code></p>
</dd>
<dt class="hdlist1"><code>not_modified</code></dt>
<dd>
<p><code>304</code></p>
</dd>
<dt class="hdlist1"><code>use_proxy</code></dt>
<dd>
<p><code>305</code></p>
</dd>
<dt class="hdlist1"><code>switch_proxy</code></dt>
<dd>
<p><code>306</code></p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
No longer used.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>temporary_redirect</code></dt>
<dd>
<p><code>307</code></p>
</dd>
<dt class="hdlist1"><code>permanent_redirect</code></dt>
<dd>
<p><code>308</code></p>
</dd>
<dt class="hdlist1"><code>bad_request</code></dt>
<dd>
<p><code>400</code></p>
</dd>
<dt class="hdlist1"><code>unauthorized</code></dt>
<dd>
<p><code>401</code></p>
</dd>
<dt class="hdlist1"><code>payment_required</code></dt>
<dd>
<p><code>402</code></p>
</dd>
<dt class="hdlist1"><code>forbidden</code></dt>
<dd>
<p><code>403</code></p>
</dd>
<dt class="hdlist1"><code>not_found</code></dt>
<dd>
<p><code>404</code></p>
</dd>
<dt class="hdlist1"><code>method_not_allowed</code></dt>
<dd>
<p><code>405</code></p>
</dd>
<dt class="hdlist1"><code>not_acceptable</code></dt>
<dd>
<p><code>406</code></p>
</dd>
<dt class="hdlist1"><code>proxy_authentication_required</code></dt>
<dd>
<p><code>407</code></p>
</dd>
<dt class="hdlist1"><code>request_timeout</code></dt>
<dd>
<p><code>408</code></p>
</dd>
<dt class="hdlist1"><code>conflict</code></dt>
<dd>
<p><code>409</code></p>
</dd>
<dt class="hdlist1"><code>gone</code></dt>
<dd>
<p><code>410</code></p>
</dd>
<dt class="hdlist1"><code>length_required</code></dt>
<dd>
<p><code>411</code></p>
</dd>
<dt class="hdlist1"><code>precondition_failed</code></dt>
<dd>
<p><code>412</code></p>
</dd>
<dt class="hdlist1"><code>payload_too_large</code></dt>
<dd>
<p><code>413</code></p>
</dd>
<dt class="hdlist1"><code>uri_too_long</code></dt>
<dd>
<p><code>414</code></p>
</dd>
<dt class="hdlist1"><code>unsupported_media_type</code></dt>
<dd>
<p><code>415</code></p>
</dd>
<dt class="hdlist1"><code>requested_range_not_satisfiable</code></dt>
<dd>
<p><code>416</code></p>
</dd>
<dt class="hdlist1"><code>expectation_failed</code></dt>
<dd>
<p><code>417</code></p>
</dd>
<dt class="hdlist1"><code>unprocessable_entity</code></dt>
<dd>
<p><code>422</code></p>
</dd>
<dt class="hdlist1"><code>locked</code></dt>
<dd>
<p><code>423</code></p>
</dd>
<dt class="hdlist1"><code>failed_dependency</code></dt>
<dd>
<p><code>424</code></p>
</dd>
<dt class="hdlist1"><code>upgrade_required</code></dt>
<dd>
<p><code>426</code></p>
</dd>
<dt class="hdlist1"><code>precondition_required</code></dt>
<dd>
<p><code>428</code></p>
</dd>
<dt class="hdlist1"><code>too_many_requests</code></dt>
<dd>
<p><code>429</code></p>
</dd>
<dt class="hdlist1"><code>request_header_fields_too_large</code></dt>
<dd>
<p><code>431</code></p>
</dd>
<dt class="hdlist1"><code>internal_server_error</code></dt>
<dd>
<p><code>500</code></p>
</dd>
<dt class="hdlist1"><code>not_implemented</code></dt>
<dd>
<p><code>501</code></p>
</dd>
<dt class="hdlist1"><code>bad_gateway</code></dt>
<dd>
<p><code>502</code></p>
</dd>
<dt class="hdlist1"><code>service_unavailable</code></dt>
<dd>
<p><code>503</code></p>
</dd>
<dt class="hdlist1"><code>gateway_timeout</code></dt>
<dd>
<p><code>504</code></p>
</dd>
<dt class="hdlist1"><code>http_version_not_supported</code></dt>
<dd>
<p><code>505</code></p>
</dd>
<dt class="hdlist1"><code>variant_also_negotiates</code></dt>
<dd>
<p><code>506</code></p>
</dd>
<dt class="hdlist1"><code>insufficient_storage</code></dt>
<dd>
<p><code>507</code></p>
</dd>
<dt class="hdlist1"><code>loop_detected</code></dt>
<dd>
<p><code>508</code></p>
</dd>
<dt class="hdlist1"><code>not_extended</code></dt>
<dd>
<p><code>510</code></p>
</dd>
<dt class="hdlist1"><code>network_authentication_required</code></dt>
<dd>
<p><code>511</code></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_non_member_functions">4.2.36.2. Non-member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>bool operator==(status_code lhs, std::uint_fast16_t rhs)</code></dt>
<dd>
<p>Tests if <em>lhs</em> and <em>rhs</em> are equal.</p>
</dd>
<dt class="hdlist1"><code>bool operator==(std::uint_fast16_t lhs, status_code rhs)</code></dt>
<dd>
<p>Tests if <em>lhs</em> and <em>rhs</em> are equal.</p>
</dd>
<dt class="hdlist1"><code>template&lt;class String&gt; String to_string(status_code sc)</code></dt>
<dd>
<p>Returns the textual representation (i.e. the reason phrase) of <em>sc</em>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_21">4.2.36.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#write_header"><code>&lt;boost/http/algorithm/write.hpp&gt;</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http_errc">4.2.37. <code>http_errc</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/http_errc.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-k">class</span> <span class="tok-nc">http_errc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This scoped enumeration defines the values for the standard error codes reported
by HTTP message producers and consumers. They are intended to be generic and
usable by a variety of HTTP producers.</p>
</div>
<div class="paragraph">
<p>They are designed to work together <a href="#http_errc_http_category"><code>http_category</code></a>.</p>
</div>
<div class="paragraph">
<p>The traits <code>boost::system::is_error_code_enum</code> and
<code>boost::system::is_error_condition_enum</code> are specialized to recognize
<code>http_errc</code>.</p>
</div>
<div class="sect4">
<h5 id="_member_constants_2">4.2.37.1. Member constants</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>out_of_order</code></dt>
<dd>
<p>Actions issued on the wrong order by the library user.</p>
<div class="paragraph">
<p>Make sure to check the examples and the return value from <code>socket.read_state()</code>
and <code>socket.write_state()</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>native_stream_unsupported</code></dt>
<dd>
<p>The issued action can only be used when the underlying channel supports native
stream, as defined in the <a href="#socket_concept"><code>Socket</code> concept page</a>.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If you&#8217;re using a type fulfilling the <a href="#server_socket_concept"><code>ServerSocket</code> concept</a>, you may be interested in the
<code>write_response_native_stream()</code> member function.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>parsing_error</code></dt>
<dd>
<p>The underlying communication channel sent an invalid message.</p>
</dd>
<dt class="hdlist1"><code>buffer_exhausted</code></dt>
<dd>
<p>This error should only happen if a poor parser is used.</p>
</dd>
<dt class="hdlist1"><code>wrong_direction</code></dt>
<dd>
<p>For flexible sockets that select the channel type upon the first use. It
happens if you started the socket operations behaving like an HTTP client and
later started to behave as an HTTP server, or vice versa, on the same channel.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_non_member_functions_2">4.2.37.2. Non-member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>boost::system::error_code make_error_code(http_errc e)</code></dt>
<dd>
<p>Creates an error code using <em>e</em> and <a href="#http_errc_http_category"><code>http_category</code></a>.</p>
</dd>
<dt class="hdlist1"><code>boost::system::error_condition make_error_condition(http_errc e)</code></dt>
<dd>
<p> Creates an error codition using <em>e</em> and <a href="#http_errc_http_category"><code>http_category</code></a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="http_errc_http_category">4.2.37.3. http_category</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_category</span><span class="tok-o">&amp;</span> <span class="tok-n">http_category</span><span class="tok-p">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obtains a reference to the static error category object for HTTP errors. The
object overrides the member function <code>name</code> to return <code>"http"</code> and overrides
<code>message</code> to support all values from <code>http_errc</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="file_server_errc">4.2.38. <code>file_server_errc</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/file_server.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">enum</span> <span class="tok-k">class</span> <span class="tok-nc">file_server_errc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This scoped enumeration defines the values for the error codes reported by HTTP
file server abstraction shipped with this library.</p>
</div>
<div class="paragraph">
<p>They&#8217;re designed to work with <a href="#file_server_errc_file_server_category">file_server_category</a>.</p>
</div>
<div class="paragraph">
<p>The traits <code>boost::system::is_error_code_enum</code> and
<code>boost::system::is_error_condition_enum</code> are specialized to recognize
<code>file_server_errc</code>.</p>
</div>
<div class="sect4">
<h5 id="_member_constants_3">4.2.38.1. Member constants</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>io_error</code></dt>
<dd>
<p>When any operation on the file stream fails or throws an exception.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
It&#8217;s guaranteed that no operations on the underlying socket were done when
this error happens.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>irrecoverable_io_error</code></dt>
<dd>
<p>When any operation on the file stream fails or throws an exception AFTER some
operation on the underlying socket already was issued.</p>
</dd>
<dt class="hdlist1"><code>write_state_not_supported</code></dt>
<dd>
<p>If some write operation already was issued before the call to the function
that raised this error code.</p>
</dd>
<dt class="hdlist1"><code>file_not_found</code></dt>
<dd>
<p>The requested file wasn&#8217;t found. The channel is left untouched to give the
user the opportunity to send a custom “404 response” or to further forward the
request.</p>
</dd>
<dt class="hdlist1"><code>file_type_not_supported</code></dt>
<dd>
<p>The requested file was found but it is not regular (e.g. directories, block
devices, links&#8230;&#8203;). Channel remains untouched.</p>
</dd>
<dt class="hdlist1"><code>filter_set</code></dt>
<dd>
<p>The user provided filter predicate returned <code>false</code> to cancel the
operation. Channel remains untouched.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_non_member_functions_3">4.2.38.2. Non-member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>boost::system::error_code make_error_code(file_server_errc e)</code></dt>
<dd>
<p>Creates an error code using <em>e</em> and <a href="#file_server_errc_file_server_category">file_server_category</a></p>
</dd>
<dt class="hdlist1"><code>boost::system::error_condition make_error_condition(file_server_errc e)</code></dt>
<dd>
<p>Creates an error code using <em>e</em> and <a href="#file_server_errc_file_server_category">file_server_category</a></p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="file_server_errc_file_server_category">4.2.38.3. file_server_category</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">const</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_category</span><span class="tok-o">&amp;</span> <span class="tok-n">file_server_category</span><span class="tok-p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Obtains a reference to the static error category object for the file server
errors. The object overrides the member function <code>name</code> to return
<code>"file_server"</code> and overrides <code>message</code> to support all values from
<code>file_server_errc</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_22">4.2.38.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a></p>
</li>
<li>
<p><a href="#async_response_transmit_dir"><code>async_response_transmit_dir</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="message_concept">4.2.39. <code>Message</code></h4>
<div class="paragraph">
<p>A container able to hold generic HTTP messages.</p>
</div>
<div class="sect4">
<h5 id="_definitions">4.2.39.1. Definitions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">HTTP field name</dt>
<dd>
<p>A string encoded with the <em>ISO-8859-1</em> charset whose contents are limited to
the chars listed below (case-sensitive):</p>
<div class="ulist">
<ul>
<li>
<p>A digit (i.e. <code>'0'</code>, <code>'1'</code>, <code>'2'</code>, <code>'3'</code>, <code>'4'</code>, <code>'5'</code>, <code>'6'</code>, <code>'7'</code>, <code>'8'</code> or
<code>'9'</code>).</p>
</li>
<li>
<p>A lowercase alphabetic (i.e. <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'d'</code>, <code>'e'</code>, <code>'f'</code>, <code>'g'</code>,
<code>'h'</code>, <code>'i'</code>, <code>'j'</code>, <code>'k'</code>, <code>'l'</code>, <code>'m'</code>, <code>'n'</code>, <code>'o'</code>, <code>'p'</code>, <code>'q'</code>, <code>'r'</code>,
<code>'s'</code>, <code>'t'</code>, <code>'u'</code>, <code>'v'</code>, <code>'w'</code>, <code>'x'</code>, <code>'y'</code> or <code>'z'</code>).</p>
</li>
<li>
<p>A few special characters: <code>'!'</code>, <code>'#'</code>, <code>'$'</code>, <code>'%'</code>, <code>'&amp;'</code>, <code>'\''</code>, <code>'*'</code>,
<code>'+'</code>, <code>'-'</code>, <code>'.'</code>, <code>'^'</code>, <code>'_'</code>, backtick (i.e. <code>'\x60'</code>), <code>'|'</code> or <code>'~'</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Any uppercase character received through the wire MUST be normalized
(i.e. converted to lowercase).
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">HTTP field value</dt>
<dd>
<p>A string encoded with the <em>ISO-8859-1</em> charset whose contents are limited to
the chars listed below (whether they&#8217;re case-sensitive or not is defined on a
header-by-header basis and, as such, they all are considered case-sensitive in
this layer of abstraction):</p>
<div class="ulist">
<ul>
<li>
<p>Any visible <em>USASCII</em> character.</p>
</li>
<li>
<p>Any character in the closed interval (i.e. both ends are inclusive) between
<code>'\x80'</code> and <code>'\xFF'</code>. The use of these characters within the <em>HTTP field
value</em> is obsolete and should be avoided.</p>
</li>
<li>
<p>Space (i.e. <code>'\x20'</code>) and horizontal tab (i.e. <code>'\t'</code>). These characters are
not allowed in the beginning or in the end of the <em>HTTP field value</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">HTTP field</dt>
<dd>
<p>A pair whose first element is an <em>HTTP field name</em> and second element is an
<em>HTTP field value</em>.</p>
</dd>
<dt class="hdlist1">HTTP header section</dt>
<dd>
<p>A set of <em>HTTP fields</em> received in the same chunk (e.g. the HTTP header
section defined in the RFC 7230).</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
For fields with equivalent field names, the relative order is preserved.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_notation">4.2.39.2. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>Message</code>.</p>
</dd>
<dt class="hdlist1"><code>Headers</code></dt>
<dd>
<p>A type fulfilling the following requirements:</p>
<div class="ulist">
<ul>
<li>
<p>The C++11 concept of associative containers (<em>associative.reqmts</em>)
<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>.</p>
</li>
<li>
<p>It supports equivalent keys.</p>
</li>
<li>
<p>Value type is equal to <code>pair&lt;const Key, T&gt;</code>.</p>
</li>
<li>
<p><code>mapped_type</code> is available with the same semantics for multimap.</p>
</li>
<li>
<p><code>Headers::key_type</code> MUST fulfill the requirements for the <code>String</code> concept
(i.e. <code>std::basic_string</code>).</p>
<div class="paragraph">
<p><code>Headers::key_type::value_type</code> MUST be able to represent all values in the
<em>ISO-8859-1</em> charset except for the upper case versions of the alphabetic
characters.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Inserting elements in <code>Headers</code> instances whose keys contains uppercase
char(s) invoke undefined behaviour.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>Headers::mapped_type</code> MUST fulfill the requirements for the <code>String</code> concept
(i.e. <code>std::basic_string</code>).</p>
<div class="paragraph">
<p><code>Headers::mapped_type::value_type</code> MUST be able to represent all values in the
<em>ISO-8859-1</em> charset.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>Body</code></dt>
<dd>
<p>A type fulfilling the C++ concept of sequence containers (<em>sequence.reqmts</em>)
whose <code>value_type</code> can represent byte octets.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_2">4.2.39.3. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_message&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::headers_type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Headers</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::body_type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Body</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.headers()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::headers_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the <em>HTTP header section</em> received/to-be-sent
before the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
<li>
<p>The returned object MUST <strong>NOT</strong> be shared with the one returned by
<code>a.trailers()</code>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.headers()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::headers_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the <em>HTTP header section</em> received/to-be-sent
before the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
<li>
<p>The returned object MUST <strong>NOT</strong> be shared with the one returned by
<code>a.trailers()</code>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.body()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::body_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent chunks of the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.body()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::body_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent chunks of the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.trailers()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::headers_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the <em>HTTP header section</em> received/to-be-sent
after the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
<li>
<p>The returned object MUST <strong>NOT</strong> be shared with the one returned by
<code>a.headers()</code>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.trailers()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::headers_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the <em>HTTP header section</em> received/to-be-sent
after the HTTP body data payload.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
<li>
<p>The returned object MUST <strong>NOT</strong> be shared with the one returned by
<code>a.headers()</code>.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Failing to comply with the “MUST” and “MUST <strong>NOT</strong>” conditions described
previously invokes undefined behaviour.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_23">4.2.39.4. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request_concept"><code>Request</code> concept</a>.</p>
</li>
<li>
<p><a href="#response_concept"><code>Response</code> concept</a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="request_concept">4.2.40. <code>Request</code></h4>
<div class="paragraph">
<p>A container able to hold HTTP request messages.</p>
</div>
<div class="sect4">
<h5 id="_refinement_of">4.2.40.1. Refinement of</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#message_concept"><code>Message</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_notation_2">4.2.40.2. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>Request</code>.</p>
</dd>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>A type that is a model of C++'s <code>String</code>.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_3">4.2.40.3. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_request_message&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::string_type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.method()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP request method.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.method()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP request method.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.target()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP request target.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.target()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP request target.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_models">4.2.40.4. Models</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request"><code>request</code></a></p>
</li>
<li>
<p><a href="#basic_request"><code>basic_request</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response_concept">4.2.41. <code>Response</code></h4>
<div class="paragraph">
<p>A container able to hold HTTP response messages.</p>
</div>
<div class="sect4">
<h5 id="_refinement_of_2">4.2.41.1. Refinement of</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#message_concept"><code>Message</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_notation_3">4.2.41.2. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>Response</code>.</p>
</dd>
<dt class="hdlist1"><code>String</code></dt>
<dd>
<p>A type that is a model of C++'s <code>String</code>.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_4">4.2.41.3. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_response_message&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::string_type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.status_code()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::uint_least16_t&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP response status code.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.status_code()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const std::uint_least16_t&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP response status code.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.reason_phrase()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP response reason phrase.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.reason_phrase()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const X::string_type&amp;</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>It should be used to represent the HTTP response reason phrase.</p>
</li>
<li>
<p>Always returns a reference to the same object.</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="_models_2">4.2.41.4. Models</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#response"><code>response</code></a></p>
</li>
<li>
<p><a href="#basic_response"><code>basic_response</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="socket_concept">4.2.42. <code>Socket</code></h4>
<div class="paragraph">
<p>Common operations between request and response that the underlying channel
should provide.</p>
</div>
<div class="sect4">
<h5 id="_definitions_2">4.2.42.1. Definitions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Types fulfilling the <code>Socket</code> concept and also possessing the <em>strict</em> property</dt>
<dd>
<p>Instances from this type will <strong>not</strong> insert illegal characters
<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup> in the HTTP fields.</p>
</dd>
<dt class="hdlist1">Native stream</dt>
<dd>
<p>The message size doesn&#8217;t need to be know prior to writing the response
message. The use of the streaming API can only be used when this property
holds. Buffering the body MUST <strong>NOT</strong> be done and the message parts MUST be
written as soon as convenient. If this property holds, the user MAY safely use
the socket to transmit a live video stream, for instance.</p>
</dd>
<dt class="hdlist1">Message metadata</dt>
<dd>
<p>The HTTP status line plus the header section.</p>
</dd>
<dt class="hdlist1">Atomic message</dt>
<dd>
<p>A message which is issued and fully know with a single API call.</p>
<div class="paragraph">
<p>Every message is either atomic or chunked.</p>
</div>
</dd>
<dt class="hdlist1">Chunked message</dt>
<dd>
<p>A message which is issued among several API calls.</p>
<div class="paragraph">
<p>Every message is either atomic or chunked.</p>
</div>
<div class="paragraph">
<p>Chunked messages are useful if you don&#8217;t know the message in advance (e.g. video
streaming). These messages can only be used if native stream is supported.</p>
</div>
<div class="paragraph">
<p>You always need to be prepared to receive chunked messages and it&#8217;s only useful
to differ operations which only apply to atomic messages or chunked messages
when you&#8217;re about to send a message.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_notation_4">4.2.42.2. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Message</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#message_concept"><code>Message</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>m</code></dt>
<dd>
<p>Object of type <code>Message</code>.</p>
</dd>
<dt class="hdlist1"><code>cm</code></dt>
<dd>
<p>Object of type <code>const Message</code>.</p>
</dd>
<dt class="hdlist1"><code>CompletionToken</code></dt>
<dd>
<p>A type fulfilling the concept of a completion token, as defined in
<a href="https://isocpp.org/files/papers/n4045.pdf">N4045: Library Foundations for
Asynchronous Operations, Revision 2</a>.</p>
</dd>
<dt class="hdlist1"><code>AsyncResultType</code></dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>token</code></dt>
<dd>
<p>An object of the type <code>CompletionToken</code>.</p>
</dd>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>Socket</code>.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_5">4.2.42.3. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_socket&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::executor_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of the executor associated with the object.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.get_executor()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::executor_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the executor associated with the object.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::message_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Socket</code> only supports operations involving a single type of message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must be a type fulfilling the <a href="#message_concept"><code>Message</code> concept</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.is_open()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determine whether the socket is open.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.read_state()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#read_state"><code>read_state</code></a></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the state associated with the <code>Socket</code> meaningful for reading
 operations.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.write_state()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#write_state"><code>write_state</code></a></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns the state associated with the <code>Socket</code> meaningful for writing
 operations.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_some(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::message_ready</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to read a part of the message body. Handler
 is called when at least one byte is read (called with no error set), when the
 end of message is reached (called with no error set) or when some error occurs.</p>
<p class="tableblock"> <code>m.body()</code> and <code>m.trailers()</code> are left in an unspecified state while the
 operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, the part of the message read (if any) is
 appended to <code>m.body()</code>, if no error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_some(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() != read_state::message_ready</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_trailers(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::body_ready</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to read the trailers. Handler is called when
 the rest of the message is fully received (called with no error set) or when
 some error occurs.</p>
<p class="tableblock"> <code>m.trailers()</code> is left in an unspecified state while the operation is in
 progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, if no error happened, the read trailers (if
 any) are inserted into <code>m.trailers()</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_trailers(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() != read_state::body_ready</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write a chunk of the HTTP body data
 payload (chunked message). Handler is called when the operation completes with
 an appropriate parameter.</p>
<p class="tableblock"> <code>cm.body()</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, the <code>cm.body()</code> data is considered
 delivered, if no error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_trailers(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write the trailer part of the message
 (chunked message). Handler is called when the operation completes with an
 appropriate parameter.</p>
<p class="tableblock"> <code>cm.trailers()</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the operation completes, the <code>cm.trailers()</code> data is considered
 delivered, if no error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_trailers(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_end_of_message (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to signalize the sent message is complete
 (chunked message). Handler is called when the operation completes with an
 appropriate parameter.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the operation completes, the message is considered complete, if no
 error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_end_of_message (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Failing to comply with the “MUST” and “MUST <strong>NOT</strong>” conditions described
previously invokes undefined behaviour.</p>
</li>
<li>
<p>Any HTTP field name received through the wire is normalized (i.e. uppercase
characters are converted to lowercase) before they&#8217;re inserted into objects of
type <code>Message::headers_type</code>.</p>
</li>
<li>
<p>The <code>Socket</code> object has the freedom to store information required to further
process the incoming message in the user-provided <code>message</code> object. Thus, the
library user MUST <strong>NOT</strong> use different <code>message</code> objects in the functions that
initiate <strong>read</strong> operations, in the context of the <strong>same</strong> message exchange
(i.e. the user can use a different <code>message</code> object to receive a different
message). This requirement is extended to refinements of this concept.</p>
</li>
<li>
<p>The <code>Socket</code> object MUST <strong>NOT</strong> insert HTTP headers with empty keys (i.e. <code>""</code>)
in message, request or response objects provided by the user.</p>
</li>
<li>
<p>You MUST <strong>NOT</strong> write messages with the <code>"transfer-encoding: chunked"</code> header.</p>
</li>
<li>
<p>You MUST <strong>NOT</strong> write <strong>atomic</strong> messages with the <code>"transfer-encoding"</code> header.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_models_3">4.2.42.4. Models</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a></p>
</li>
<li>
<p><a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
<li>
<p><a href="#server_socket_adaptor"><code>server_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#client_socket_adaptor"><code>client_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#socket_adaptor"><code>socket_adaptor</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_24">4.2.42.5. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#server_socket_concept"><code>ServerSocket</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="server_socket_concept">4.2.43. <code>ServerSocket</code></h4>
<div class="paragraph">
<p>Provides operations for HTTP servers.</p>
</div>
<div class="sect4">
<h5 id="_refinement_of_3">4.2.43.1. Refinement of</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#socket_concept"><code>Socket</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_definitions_3">4.2.43.2. Definitions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Types fulfilling the <code>ServerSocket</code> concept and also possessing the <em>strict</em> property</dt>
<dd>
<p>Instances from this type will <strong>not</strong> insert illegal characters
<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup> in the HTTP fields.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_notation_5">4.2.43.3. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#response_concept"><code>Response</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>im</code></dt>
<dd>
<p>Object of type <code>Request</code>.</p>
</dd>
<dt class="hdlist1"><code>om</code></dt>
<dd>
<p>Object of type <code>const Response</code>.</p>
</dd>
<dt class="hdlist1"><code>CompletionToken</code></dt>
<dd>
<p>A type fulfilling the concept of a completion token, as defined in
<a href="https://isocpp.org/files/papers/n4045.pdf">N4045: Library Foundations for
Asynchronous Operations, Revision 2</a>.</p>
</dd>
<dt class="hdlist1"><code>AsyncResultType</code></dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>token</code></dt>
<dd>
<p>An object of the type <code>CompletionToken</code>.</p>
</dd>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>ServerSocket</code>.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_6">4.2.43.4. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_server_socket&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::request_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerSocket</code> only supports operations involving a single type of request
 message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must be a type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
 concept</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::response_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerSocket</code> only supports operations involving a single type of response
 message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must be a type fulfilling the requirements for the
 <a href="#response_concept"><code>Response</code> concept</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ca.write_response_native_stream()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() != read_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns whether the current message exchange supports native stream.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The same value and property is maintained until the end of the current message
 exchange.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_request(im, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to read enough of the message to apply the
 request to a target resource (i.e. request line plus the header section).
 Handler is called when the operation completes with an appropriate parameter.</p>
<p class="tableblock"> <code>im</code> is left in a unspecified state while the operation is in progress.</p>
<p class="tableblock"> The <code>ServerSocket</code> object MUST prevent the user from issuing new replies while
 the request isn&#8217;t ready. The prevention MUST be done by changing the write
 state to <code>write_state::finished</code> while the read_request operation is in
 progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, <code>im.method()</code> value represents the read
 method, <code>im.target()</code> represents the read url and all headers for the current
 request are inserted into <code>m.headers()</code>, if no error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_request(im, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() != read_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_response(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty
  || a.write_state() == write_state::continue_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write the response message (atomic
 message). Handler is called with an appropriate argument when the operation
 completes.</p>
<p class="tableblock"> <code>om</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state ::finished</code></p>
</li>
<li>
<p><code>a.read_state() == read_state ::empty</code></p>
</li>
<li>
<p>By the time the handler is called, the <code>om</code> message is considered delivered,
if no error happened.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_response(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state::empty
 &amp;&amp; a.write_state() != write_state::continue_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_response_continue (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write a response with the semantics from
 a “100 (Continue) response” <sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup>. Handler is called when the operation completes with an appropriate
 parameter.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state ::continue_issued</code></p>
</li>
<li>
<p>By the time the handler is called, the “100 (Continue) response” is
considered delivered.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_response_continue (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a .async_write_response_metadata(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(a.write_state() == write_state::empty
   || a.write_state() == write_state::continue_issued)
  &amp;&amp; a.write_response_native_stream() == true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write the response metadata (chunked
 message). Handler is called with an appropriate argument when the operation
 completes.</p>
<p class="tableblock"> <code>om</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state ::metadata_issued</code></p>
</li>
<li>
<p>By the time the handler is called, the response metadata
(i.e. <code>om.status_code()</code>, <code>om.reason_phrase()</code> and <code>cm.headers()</code>) is
considered delivered, if no error happened.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a .async_write_response_metadata(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state::empty
  &amp;&amp; a.write_state() != write_state::continue_issued</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code> <sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a .async_write_response_metadata(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(a.write_state() == write_state::empty
   || a.write_state() == write_state::continue_issued)
  &amp;&amp; a.write_response_native_stream() == false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc ::native_stream_unsupported}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following <code>Socket</code> operations are refined with extra
semantics/postconditions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Extra semantics</th>
<th class="tableblock halign-left valign-top">Extra postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_trailers(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::body_ready</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, if no error happened, <code>a.read_state() ==
 http::read_state::finished</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_trailers(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state::finished</code></p>
</li>
<li>
<p><code>a.read_state() == read_state ::empty</code></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_end_of_message (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state::finished</code></p>
</li>
<li>
<p><code>a.read_state() == read_state ::empty</code></p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Failing to comply with the “MUST” and “MUST <strong>NOT</strong>” conditions described
previously invokes undefined behaviour.</p>
</li>
<li>
<p>Any HTTP field name received through the wire is normalized (i.e. uppercase
characters are converted to lowercase) before they&#8217;re inserted into objects of
type <code>Request::headers_type</code>.</p>
</li>
<li>
<p>If the user pass a <code>"connection: close"</code> header on the message object passed
as argument to the <code>async_write_response</code> or <code>async_write_response_metadata</code>
member-functions, the <code>ServerSocket</code> MUST change the state to closed (i.e.
<code>is_open()</code> will return <code>false</code>).</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ServerSocket</code> and can differ from the communication between the
<code>ServerSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>If the <code>ServerSocket</code> reads a message that expects a “100 (Continue)
response”, it MUST insert the <code>"expect: 100-continue"</code> header and only one
element with the HTTP field name <code>"expect"</code> MUST be present.</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ServerSocket</code> and can differ from the communication between the
<code>ServerSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>If the <code>ServerSocket</code> reads a message that does <strong>NOT</strong> expect a “100 (Continue)
response”, it MUST erase all the <code>"expect: 100-continue"</code> headers.</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ServerSocket</code> and can differ from the communication between the
<code>ServerSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>If the <code>ServerSocket</code> reads a message that represent a desire from the HTTP
client to initiate a protocol upgrade, the <code>ServerSocket</code> supports a protocol
upgrade and it&#8217;ll communicate the client desire to the user of this library,
it MUST communicate the desire ensuring all of the following conditions:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Ensuring that the <code>"upgrade"</code> (case-insensitive) string is present in the
comma-separated list of values from some <code>"connection"</code> header. This rule
implictly requires the presence of at least one <code>"connection"</code> header.</p>
</li>
<li>
<p>There is at least one <code>"upgrade"</code> header and all of the <code>"upgrade"</code> headers
respect the conditions established in the section 6.7 of the RFC7230.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ServerSocket</code> and can differ from the communication between the
<code>ServerSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>If the <code>ServerSocket</code> isn&#8217;t willing to provide a protocol upgrade, then no
<code>"upgrade"</code> headers can be present (in other words, all <code>"upgrade"</code> headers
MUST be erased before delivering the message to the user of this library).</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ServerSocket</code> and can differ from the communication between the
<code>ServerSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>If the <code>"content-length"</code> header is provided to <code>async_write_response</code>, then
the <code>ServerSocket</code> MUST ignore the message body (i.e. there is no data payload
in the reply message) and SHOULD use the user-provided header.</p>
<div class="paragraph">
<p>The <code>ServerSocket</code> MUST adopt a behaviour that is compatible with the behaviour
defined in the section 3.3.2 of the RFC 7230.</p>
</div>
</li>
<li>
<p>The <code>ServerSocket</code> object MUST <strong>NOT</strong> insert HTTP headers with empty keys
(i.e. <code>""</code>) in message, request or response objects provided by the user.</p>
</li>
<li>
<p>Informational responses (i.e. 1xx class of status code) indicates an interim
response and do not change <code>read_state</code> or <code>write_state</code>. Also, these
responses carry no body, so all body is ignored (and if the user tries to send
such responses using chunks/<code>async_write_response_metadata</code>, error
<code>http_errc::native_stream_unsupported</code> will be reported).</p>
</li>
<li>
<p>Some models of <code>ServerSocket</code> might discard informational responses (i.e. 1xx
class of status code) that you try to send.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_models_4">4.2.43.5. Models</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a></p>
</li>
<li>
<p><a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
<li>
<p><a href="#server_socket_adaptor"><code>server_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#socket_adaptor"><code>socket_adaptor</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="client_socket_concept">4.2.44. <code>ClientSocket</code></h4>
<div class="paragraph">
<p>Provides operations for HTTP clients.</p>
</div>
<div class="sect4">
<h5 id="_refinement_of_4">4.2.44.1. Refinement of</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#socket_concept"><code>Socket</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_definitions_4">4.2.44.2. Definitions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1">Types fulfilling the <code>ClientSocket</code> concept and also possessing the <em>strict</em> property</dt>
<dd>
<p>Instances from this type will <strong>not</strong> insert illegal characters
<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> in the HTTP fields.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_notation_6">4.2.44.3. Notation</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code></dt>
<dd>
<p>A type fulfilling the requirements for the <a href="#response_concept"><code>Response</code>
concept</a>.</p>
</dd>
<dt class="hdlist1"><code>im</code></dt>
<dd>
<p>Object of type <code>Response</code>.</p>
</dd>
<dt class="hdlist1"><code>om</code></dt>
<dd>
<p>Object of type <code>const Request</code>.</p>
</dd>
<dt class="hdlist1"><code>CompletionToken</code></dt>
<dd>
<p>A type fulfilling the concept of a completion token, as defined in
<a href="https://isocpp.org/files/papers/n4045.pdf">N4045: Library Foundations for
Asynchronous Operations, Revision 2</a>.</p>
</dd>
<dt class="hdlist1"><code>AsyncResultType</code></dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="tok-p">(</span><span class="tok-n">CompletionToken</span><span class="tok-p">,</span> <span class="tok-kt">void</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">system</span><span class="tok-o">::</span><span class="tok-n">error_code</span><span class="tok-p">))</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>token</code></dt>
<dd>
<p>An object of the type <code>CompletionToken</code>.</p>
</dd>
<dt class="hdlist1"><code>X</code></dt>
<dd>
<p>A type that is a model of <code>ClientSocket</code>.</p>
</dd>
<dt class="hdlist1"><code>a</code></dt>
<dd>
<p>Object of type <code>X</code>.</p>
</dd>
<dt class="hdlist1"><code>ca</code></dt>
<dd>
<p>Object of type <code>const X</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_requirements_7">4.2.44.4. Requirements</h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Semantics</th>
<th class="tableblock halign-left valign-top">Postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::is_base_of&lt;std::true_type, http::is_client_socket&lt;X&gt;&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::true_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::request_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClientSocket</code> only supports operations involving a single type of request
 message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must be a type fulfilling the requirements for the <a href="#request_concept"><code>Request</code>
 concept</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X::response_type</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClientSocket</code> only supports operations involving a single type of response
 message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Must be a type fulfilling the requirements for the
 <a href="#response_concept"><code>Response</code> concept</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_request(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write the request message (atomic
 message). Handler is called with an appropriate argument when the operation
 completes.</p>
<p class="tableblock"> <code>om</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, the <code>om</code> message is considered delivered, if
 no error happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_request(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a .async_write_request_metadata(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to write the request metadata (chunked
 message). Handler is called with an appropriate argument when the operation
 completes.</p>
<p class="tableblock"> <code>om</code> MUST <strong>NOT</strong> be modified while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>a.write_state() == write_state ::metadata_issued</code></p>
</li>
<li>
<p>By the time the handler is called, the request metadata
(i.e. <code>om.method()</code>, <code>om.target()</code> and <code>cm.headers()</code>) is considered
delivered, if no error happened.</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a .async_write_request_metadata(om, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() != write_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_response(im, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initiate an asynchronous operation to read enough of the message to fill the
 response metadata (i.e. status line plus the header section). Handler is
 called when the operation completes with an appropriate parameter.</p>
<p class="tableblock"> <code>im</code> is left in a unspecified state while the operation is in progress.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, <code>im.status_code()</code> value represents the read
 status code, <code>im.reason_phrase()</code> represents the read reason phrase and all
 headers for the current response are inserted into <code>im.headers()</code>, if no error
 happened.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_response(im, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AsyncResultType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() != read_state::empty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No actions are done and the handler from the completion token is called with
 <code>boost::system::error_code {http_errc::out_of_order}</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following <code>Socket</code> operations are refined with extra
semantics/postconditions:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Precondition</th>
<th class="tableblock halign-left valign-top">Extra semantics</th>
<th class="tableblock halign-left valign-top">Extra postcondition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_read_trailers(m, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.read_state() == read_state::body_ready</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By the time the handler is called, if no error happened, <code>a.read_state() ==
 http::read_state::empty</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_trailers(cm, token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.async_write_end_of_message (token)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state ::metadata_issued</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a.write_state() == write_state::empty</code></p></td>
</tr>
</tbody>
</table>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Failing to comply with the “MUST” and “MUST <strong>NOT</strong>” conditions described
previously invokes undefined behaviour.</p>
</li>
<li>
<p>Any HTTP field name received through the wire is normalized (i.e. uppercase
characters are converted to lowercase) before they&#8217;re inserted into objects of
type <code>Response::headers_type</code>.</p>
</li>
<li>
<p>Upon receiving a message (i.e. <code>async_read_response</code>, <code>async_read_some</code> or
<code>async_read_trailers</code>), if connection is gracefully closed in the
HTTP-equivalent layer (e.g. <code>"connection: close"</code> header), <code>ClientSocket</code> MUST
change the state to closed (i.e. <code>is_open()</code> will return <code>false</code>).</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ClientSocket</code> and can differ from the communication between the
<code>ClientSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>The user communicates the intent to wait for a “100 (Continue) response” by
inserting the <code>"expect: 100-continue"</code> header (and more than one element with
the HTTP field name <code>"expect"</code> MUST NOT be present in the sent request
metadata).</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ClientSocket</code> and can differ from the communication between the
<code>ClientSocket</code> and the underlying channel. For instance, if the <code>ClientSocket</code>
doesn&#8217;t intend to implement such semantics, it can omit this header from the
message sent to the underlying channel and fill a “100 (Continue) response” in
the next call the user does to <code>read_response</code> whether this response was
received from the underlying channel or not (i.e. fill a virtual response).</p>
</div>
</li>
<li>
<p>If the <code>ClientSocket</code> isn&#8217;t willing to provide support for protocol upgrade,
then no <code>"upgrade"</code> headers should be sent (in other words, all <code>"upgrade"</code>
headers MUST be skipped before delivering the message from the user of this
library — or a behaviour that is equivalent in the underlying channel).</p>
<div class="paragraph">
<p>This behaviour is intended for the communication between the user of this
library and the <code>ClientSocket</code> and can differ from the communication between the
<code>ClientSocket</code> and the underlying channel.</p>
</div>
</li>
<li>
<p>The <code>ClientSocket</code> object MUST <strong>NOT</strong> insert HTTP headers with empty keys
(i.e. <code>""</code>) in message, request or response objects provided by the user.</p>
</li>
<li>
<p>The user of this library MUST <strong>NOT</strong> insert <code>"content-length"</code> or
<code>"transfer-encoding"</code> headers in <code>om</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_models_5">4.2.44.5. Models</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a></p>
</li>
<li>
<p><a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
<li>
<p><a href="#client_socket_adaptor"><code>client_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#socket_adaptor"><code>socket_adaptor</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="algorithm_header">4.2.45. <code>&lt;boost/http/algorithm.hpp&gt;</code></h4>
<div class="paragraph">
<p>A shorthand to write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/header.hpp&gt;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/algorithm/query.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_25">4.2.45.1. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#header_header"><code>&lt;boost/http/algorithm/header.hpp&gt;</code></a></p>
</li>
<li>
<p><a href="#query_header"><code>&lt;boost/http/algorithm/query.hpp&gt;</code></a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="header_header">4.2.46. <code>&lt;boost/http/algorithm/header.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#header_to_ptime"><code>header_to_ptime</code></a></p>
</li>
<li>
<p><a href="#to_http_date"><code>to_http_date</code></a></p>
</li>
<li>
<p><a href="#header_value_all_of"><code>header_value_all_of</code></a></p>
</li>
<li>
<p><a href="#header_value_any_of"><code>header_value_any_of</code></a></p>
</li>
<li>
<p><a href="#header_value_none_of"><code>header_value_none_of</code></a></p>
</li>
<li>
<p><a href="#header_value_for_each"><code>header_value_for_each</code></a></p>
</li>
<li>
<p><a href="#etag_match_strong"><code>etag_match_strong</code></a></p>
</li>
<li>
<p><a href="#etag_match_weak"><code>etag_match_weak</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="query_header">4.2.47. <code>&lt;boost/http/algorithm/query.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#request_continue_required"><code>request_continue_required</code></a></p>
</li>
<li>
<p><a href="#request_upgrade_desired"><code>request_upgrade_desired</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="file_server_header">4.2.48. <code>&lt;boost/http/file_server.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#async_response_transmit_file"><code>async_response_transmit_file</code></a></p>
</li>
<li>
<p><a href="#async_response_transmit_dir"><code>async_response_transmit_dir</code></a></p>
</li>
<li>
<p><a href="#file_server_errc"><code>file_server_errc</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="headers_header">4.2.49. <code>&lt;boost/http/headers.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="http_category_header">4.2.50. <code>&lt;boost/http/http_category.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the <code>http_category</code> symbol documented at <a href="#http_errc_http_category"><code>http_errc</code> page</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="http_errc_header">4.2.51. <code>&lt;boost/http/http_errc.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import all the symbols documented at the <a href="#http_errc"><code>http_errc</code> page</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="request_header">4.2.52. <code>&lt;boost/http/request.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_request"><code>basic_request</code></a></p>
</li>
<li>
<p><a href="#request"><code>request</code></a></p>
</li>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="response_header">4.2.53. <code>&lt;boost/http/response.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_response"><code>basic_response</code></a></p>
</li>
<li>
<p><a href="#response"><code>response</code></a></p>
</li>
<li>
<p><a href="#headers"><code>headers</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="request_response_wrapper_header">4.2.54. <code>&lt;boost/http/request_response_wrapper.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#request_response_wrapper"><code>request_response_wrapper</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="poly_socket_header">4.2.55. <code>&lt;boost/http/poly_socket.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_socket"><code>basic_poly_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
<li>
<p><a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="poly_server_socket_header">4.2.56. <code>&lt;boost/http/poly_server_socket.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_server_socket"><code>basic_poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="poly_client_socket_header">4.2.57. <code>&lt;boost/http/poly_client_socket.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_client_socket"><code>basic_poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="poly_socket_base_header">4.2.58. <code>&lt;boost/http/poly_socket_base.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_poly_socket_base"><code>basic_poly_socket_base</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="read_state_header">4.2.59. <code>&lt;boost/http/read_state.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#read_state"><code>read_state</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="server_socket_adaptor_header">4.2.60. <code>&lt;boost/http/server_socket_adaptor.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#server_socket_adaptor"><code>server_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#poly_server_socket"><code>poly_server_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="client_socket_adaptor_header">4.2.61. <code>&lt;boost/http/client_socket_adaptor.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#client_socket_adaptor"><code>client_socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#poly_client_socket"><code>poly_client_socket</code></a></p>
</li>
<li>
<p><a href="#poly_socket_base"><code>poly_socket_base</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="socket_adaptor_header">4.2.62. <code>&lt;boost/http/socket_adaptor.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#socket_adaptor"><code>socket_adaptor</code></a></p>
</li>
<li>
<p><a href="#poly_socket"><code>poly_socket</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="socket_header">4.2.63. <code>&lt;boost/http/socket.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a></p>
</li>
<li>
<p><a href="#socket"><code>socket</code></a></p>
</li>
<li>
<p><a href="#read_state"><code>read_state</code></a></p>
</li>
<li>
<p><a href="#write_state"><code>write_state</code></a></p>
</li>
<li>
<p><a href="#http_errc"><code>http_errc</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="buffered_socket_header">4.2.64. <code>&lt;boost/http/buffered_socket.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_buffered_socket"><code>basic_buffered_socket</code></a></p>
</li>
<li>
<p><a href="#buffered_socket"><code>buffered_socket</code></a></p>
</li>
<li>
<p><a href="#read_state"><code>read_state</code></a></p>
</li>
<li>
<p><a href="#write_state"><code>write_state</code></a></p>
</li>
<li>
<p><a href="#http_errc"><code>http_errc</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="status_code_header">4.2.65. <code>&lt;boost/http/status_code.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#status_code"><code>status_code</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="write_state_header">4.2.66. <code>&lt;boost/http/write_state.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#write_state"><code>write_state</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="traits_header">4.2.67. <code>&lt;boost/http/traits.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#is_message"><code>is_message</code></a></p>
</li>
<li>
<p><a href="#is_request_message"><code>is_request_message</code></a></p>
</li>
<li>
<p><a href="#is_response_message"><code>is_response_message</code></a></p>
</li>
<li>
<p><a href="#is_socket"><code>is_socket</code></a></p>
</li>
<li>
<p><a href="#is_server_socket"><code>is_server_socket</code></a></p>
</li>
<li>
<p><a href="#is_client_socket"><code>is_client_socket</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="basic_router_header">4.2.68. <code>&lt;boost/http/basic_router.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_router"><code>basic_router</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="regex_router_header">4.2.69. <code>&lt;boost/http/regex_router.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#regex_router"><code>regex_router</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="is_message">4.2.70. <code>is_message</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#message_concept"><code>Message</code> concept</a>, this
template inherits <code>std::true_type</code>. For any other type, this template inherits
<code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#message_concept"><code>Message</code> objects</a>.</p>
</div>
<div class="paragraph">
<p>Initially, it was considered to create a trait that would automatically detect
if <code>T</code> is fullfilling the <a href="#message_concept"><code>Message</code> concept</a>, but the idea
was abandoned, because the <a href="#message_concept"><code>Message</code> concept</a> includes
behaviour that can only be detected at runtime.</p>
</div>
<div class="paragraph">
<p>The default definition follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">T</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-nl">is_message</span>
    <span class="tok-p">:</span> <span class="tok-k">public</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">integral_constant</span><span class="tok-o">&lt;</span><span class="tok-kt">bool</span><span class="tok-p">,</span>
                                    <span class="tok-n">is_request_message</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">&gt;::</span><span class="tok-n">value</span>
                                    <span class="tok-o">||</span> <span class="tok-n">is_response_message</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">&gt;::</span><span class="tok-n">value</span><span class="tok-o">&gt;</span>
<span class="tok-p">{};</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_template_parameters_25">4.2.70.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_26">4.2.70.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#message_concept"><code>Message</code> concept</a>.</p>
</li>
<li>
<p><a href="#is_request_message"><code>is_request_message</code></a>.</p>
</li>
<li>
<p><a href="#is_response_message"><code>is_response_message</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="is_request_message">4.2.71. <code>is_request_message</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#request_concept"><code>Request</code> concept</a>, this
template inherits <code>std::true_type</code>. For any other type, this template inherits
<code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#request_concept"><code>Request</code> objects</a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_26">4.2.71.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_27">4.2.71.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request_concept"><code>Request</code> concept</a>.</p>
</li>
<li>
<p><a href="#is_message"><code>is_message</code></a>.</p>
</li>
<li>
<p><a href="#is_response_message"><code>is_response_message</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="is_response_message">4.2.72. <code>is_response_message</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#response_concept"><code>Response</code> concept</a>, this
template inherits <code>std::true_type</code>. For any other type, this template inherits
<code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#response_concept"><code>Response</code>
objects</a>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_27">4.2.72.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_28">4.2.72.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#response_concept"><code>Response</code> concept</a>.</p>
</li>
<li>
<p><a href="#is_message"><code>is_message</code></a>.</p>
</li>
<li>
<p><a href="#is_request_message"><code>is_request_message</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="is_socket">4.2.73. <code>is_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#socket_concept"><code>Socket</code> concept</a>, this
template inherits <code>std::true_type</code>. For any other type, this template inherits
<code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#socket_concept"><code>Socket</code>
objects</a>. If your user-defined type already specializes <a href="#is_server_socket"><code>is_server_socket</code></a> or <a href="#is_client_socket"><code>is_client_socket</code></a>, there is no
need to also specialize this template, because this template will, by default,
inherit <code>std::true_type</code> if <code>is_server_socket&lt;T&gt;::value ||
is_client_socket&lt;T&gt;::value</code> evaluates to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Initially, it was considered to create a trait that would automatically detect
if <code>T</code> is fullfilling the <a href="#socket_concept"><code>Socket</code> concept</a>, but the idea was
abandoned, because the <a href="#socket_concept"><code>Socket</code> concept</a> includes behaviour
that can only be detected at runtime.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_28">4.2.73.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_29">4.2.73.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#socket_concept"><code>Socket</code> concept</a>.</p>
</li>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a>.</p>
</li>
<li>
<p><a href="#socket"><code>socket</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="is_server_socket">4.2.74. <code>is_server_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a>, this template inherits <code>std::true_type</code>. For any other type, this
template inherits <code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#server_socket_concept"><code>ServerSocket</code>
objects</a>.</p>
</div>
<div class="paragraph">
<p>Initially, it was considered to create a trait that would automatically detect
if <code>T</code> is fullfilling the <a href="#server_socket_concept"><code>ServerSocket</code> concept</a>, but
the idea was abandoned, because the <a href="#server_socket_concept"><code>ServerSocket</code>
concept</a> includes behaviour that can only be detected at runtime.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_29">4.2.74.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_30">4.2.74.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#server_socket_concept"><code>ServerSocket</code> concept</a>.</p>
</li>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a>.</p>
</li>
<li>
<p><a href="#socket"><code>socket</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="is_client_socket">4.2.75. <code>is_client_socket</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/traits.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>T</code> is an object fulfilling the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a>, this template inherits <code>std::true_type</code>. For any other type, this
template inherits <code>std::false_type</code>.</p>
</div>
<div class="paragraph">
<p>This template may be specialized for a user-defined type to indicate that the
type is eligible for operations involving <a href="#client_socket_concept"><code>ClientSocket</code>
objects</a>.</p>
</div>
<div class="paragraph">
<p>Initially, it was considered to create a trait that would automatically detect
if <code>T</code> is fullfilling the <a href="#client_socket_concept"><code>ClientSocket</code> concept</a>, but
the idea was abandoned, because the <a href="#client_socket_concept"><code>ClientSocket</code>
concept</a> includes behaviour that can only be detected at runtime.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_30">4.2.75.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>T</code></dt>
<dd>
<p>The type to query.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_31">4.2.75.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#client_socket_concept"><code>ClientSocket</code> concept</a>.</p>
</li>
<li>
<p><a href="#basic_socket"><code>basic_socket</code></a>.</p>
</li>
<li>
<p><a href="#socket"><code>socket</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic_router">4.2.76. <code>basic_router</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/basic_router.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Router based on simple test functions.  It is implemented as a vector of
<code>pairs&lt;test,router&gt;</code>.  Where <code>test</code> is a functor that tests a specific path
received by a connection, and if returns ture, calls the <code>router</code> function with
an arbitary number of arguments.</p>
</div>
<div class="paragraph">
<p>A <code>test</code> functor could be as simple as <code>bool test_path(string path) { return
path.empty(); }</code>.</p>
</div>
<div class="paragraph">
<p>The <code>router</code> is an arbitary function, that must match the call to the router
itself.  So if we call the route as <code>basic_router(path, arg1, arg2)</code> the <code>router</code>
function will be called with <code>router(arg1, arg2)</code>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_31">4.2.76.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>unary_predicate</code></dt>
<dd>
<p>Functor that recieves <code>std::string path</code> as an argument and returns true if
this route should be selected.</p>
</dd>
<dt class="hdlist1"><code>route_function_type</code></dt>
<dd>
<p>Functor of the route destination function.</p>
</dd>
<dt class="hdlist1"><code>typename&#8230;&#8203; arguments</code></dt>
<dd>
<p>List of argument type to be passed onto the route destination function.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_32">4.2.76.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#regex_router"><code>regex_router</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="regex_router">4.2.77. <code>regex_router</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/regex_router.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Router based on regular expressions.  It is implemented as a vector of
<code>pairs&lt;regex,router&gt;</code>.  Where <code>regex</code> is a std::regex that tests a specific path
received by a connection, and if matches, calls the <code>router</code> function with
an arbitary number of arguments.</p>
</div>
<div class="paragraph">
<p>The <code>router</code> is an arbitary function, that must match the call to the router
itself.  So if we call the route as <code>basic_router(path, arg1, arg2)</code> the <code>router</code>
function will be called with <code>router(arg1, arg2)</code>.</p>
</div>
<div class="sect4">
<h5 id="_template_parameters_32">4.2.77.1. Template parameters</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>route_function_type</code></dt>
<dd>
<p>Functor of the route destination function.</p>
</dd>
<dt class="hdlist1"><code>typename&#8230;&#8203; arguments</code></dt>
<dd>
<p>List of argument type to be passed onto the route destination function.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_33">4.2.77.2. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#basic_router"><code>basic_router</code></a>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_code_value">4.2.78. <code>token::code::value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">code</span>
<span class="tok-p">{</span>
    <span class="tok-k">enum</span> <span class="tok-n">value</span>
    <span class="tok-p">{</span>
        <span class="tok-n">error_insufficient_data</span><span class="tok-p">,</span>
        <span class="tok-n">error_set_method</span><span class="tok-p">,</span>
        <span class="tok-n">error_use_another_connection</span><span class="tok-p">,</span>
        <span class="tok-n">error_invalid_data</span><span class="tok-p">,</span>
        <span class="tok-n">error_no_host</span><span class="tok-p">,</span>
        <span class="tok-n">error_invalid_content_length</span><span class="tok-p">,</span>
        <span class="tok-n">error_content_length_overflow</span><span class="tok-p">,</span>
        <span class="tok-n">error_invalid_transfer_encoding</span><span class="tok-p">,</span>
        <span class="tok-n">error_chunk_size_overflow</span><span class="tok-p">,</span>
        <span class="tok-n">skip</span><span class="tok-p">,</span>
        <span class="tok-n">method</span><span class="tok-p">,</span>
        <span class="tok-n">request_target</span><span class="tok-p">,</span>
        <span class="tok-n">version</span><span class="tok-p">,</span>
        <span class="tok-n">status_code</span><span class="tok-p">,</span>
        <span class="tok-n">reason_phrase</span><span class="tok-p">,</span>
        <span class="tok-n">field_name</span><span class="tok-p">,</span>
        <span class="tok-n">field_value</span><span class="tok-p">,</span>
        <span class="tok-n">end_of_headers</span><span class="tok-p">,</span>
        <span class="tok-n">body_chunk</span><span class="tok-p">,</span>
        <span class="tok-n">end_of_body</span><span class="tok-p">,</span>
        <span class="tok-n">trailer_name</span><span class="tok-p">,</span>
        <span class="tok-n">trailer_value</span><span class="tok-p">,</span>
        <span class="tok-n">end_of_message</span>
    <span class="tok-p">};</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>error_insufficient_data</code></dt>
<dd>
<p><code>token_size()</code> of this token will always be zero.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="token_symbol_value">4.2.79. <code>token::symbol::value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">symbol</span>
<span class="tok-p">{</span>
    <span class="tok-k">enum</span> <span class="tok-n">value</span>
    <span class="tok-p">{</span>
        <span class="tok-n">error</span><span class="tok-p">,</span>

        <span class="tok-n">skip</span><span class="tok-p">,</span>

        <span class="tok-n">method</span><span class="tok-p">,</span>
        <span class="tok-n">request_target</span><span class="tok-p">,</span>
        <span class="tok-n">version</span><span class="tok-p">,</span>
        <span class="tok-n">status_code</span><span class="tok-p">,</span>
        <span class="tok-n">reason_phrase</span><span class="tok-p">,</span>
        <span class="tok-n">field_name</span><span class="tok-p">,</span>
        <span class="tok-n">field_value</span><span class="tok-p">,</span>

        <span class="tok-n">end_of_headers</span><span class="tok-p">,</span>

        <span class="tok-n">body_chunk</span><span class="tok-p">,</span>

        <span class="tok-n">end_of_body</span><span class="tok-p">,</span>

        <span class="tok-n">trailer_name</span><span class="tok-p">,</span>
        <span class="tok-n">trailer_value</span><span class="tok-p">,</span>

        <span class="tok-n">end_of_message</span>
    <span class="tok-p">};</span>

    <span class="tok-k">static</span> <span class="tok-n">value</span> <span class="tok-nf">convert</span><span class="tok-p">(</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_category_value">4.2.80. <code>token::category::value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">category</span>
<span class="tok-p">{</span>
    <span class="tok-k">enum</span> <span class="tok-n">value</span>
    <span class="tok-p">{</span>
        <span class="tok-n">status</span><span class="tok-p">,</span>
        <span class="tok-n">data</span><span class="tok-p">,</span>
        <span class="tok-n">structural</span>
    <span class="tok-p">};</span>

    <span class="tok-k">static</span> <span class="tok-n">value</span> <span class="tok-nf">convert</span><span class="tok-p">(</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span><span class="tok-p">);</span>
    <span class="tok-k">static</span> <span class="tok-n">value</span> <span class="tok-nf">convert</span><span class="tok-p">(</span><span class="tok-n">symbol</span><span class="tok-o">::</span><span class="tok-n">value</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_skip">4.2.81. <code>token::skip</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">skip</span>
<span class="tok-p">{</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">skip</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Used to skip unneeded bytes so user can keep buffer small when asking for more
data.</p>
</div>
</div>
<div class="sect3">
<h4 id="token_field_name">4.2.82. <code>token::field_name</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">field_name</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">field_name</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_field_value">4.2.83. <code>token::field_value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">field_value</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">field_value</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_body_chunk">4.2.84. <code>token::body_chunk</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">body_chunk</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">const_buffer</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">body_chunk</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_end_of_headers">4.2.85. <code>token::end_of_headers</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">end_of_headers</span>
<span class="tok-p">{</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_headers</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_end_of_body">4.2.86. <code>token::end_of_body</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">end_of_body</span>
<span class="tok-p">{</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_body</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_trailer_name">4.2.87. <code>token::trailer_name</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">trailer_name</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">trailer_name</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This token is “implicitly convertible” to <code>field_name</code>, so to speak. In other
words, you can treat it as <code>field_name</code> at value extraction time (i.e. the
<code>reader::{request,response}::value&lt;T&gt;()</code> function).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="token_trailer_value">4.2.88. <code>token::trailer_value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">trailer_value</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">trailer_value</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This token is “implicitly convertible” to <code>field_value</code>, so to speak. In other
words, you can treat it as <code>field_value</code> at value extraction time (i.e. the
<code>reader::{request,response}::value&lt;T&gt;()</code> function).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="token_end_of_message">4.2.89. <code>token::end_of_message</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">end_of_message</span>
<span class="tok-p">{</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">end_of_message</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_method">4.2.90. <code>token::method</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">method</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">method</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_request_target">4.2.91. <code>token::request_target</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">request_target</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">request_target</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_version">4.2.92. <code>token::version</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">version</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-kt">int</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">version</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_status_code">4.2.93. <code>token::status_code</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">status_code</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-kt">uint_least16_t</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">status_code</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_reason_phrase">4.2.94. <code>token::reason_phrase</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/token.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">token</span> <span class="tok-p">{</span>

<span class="tok-k">struct</span> <span class="tok-n">reason_phrase</span>
<span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">string_view</span> <span class="tok-n">type</span><span class="tok-p">;</span>
    <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">value</span> <span class="tok-n">code</span> <span class="tok-o">=</span> <span class="tok-n">token</span><span class="tok-o">::</span><span class="tok-n">code</span><span class="tok-o">::</span><span class="tok-n">reason_phrase</span><span class="tok-p">;</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace token</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reader_request">4.2.95. <code>reader::request</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/reader/request.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class represents an <code>HTTP/1.1</code> (and <code>HTTP/1.0</code>) incremental parser. It&#8217;ll
use the token definitions found in <a href="#token_code_value"><code>token::code::value</code></a>.
You may want to check the <a href="#parsing_tutorial1">basic parsing tutorial</a> to learn
the basics.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Once the parser enters in an error state (<strong>and</strong> the error is different than
<code>token::code::error_insufficient_data</code>), the internal buffer is said to be in an
invalidated state. Therefore, the parser won&#8217;t access the data anymore and the
user is free to invalidate the data (e.g. resize/free it) without calling
<code>set_buffer()</code> or <code>reset()</code> first.</p>
</div>
<div class="paragraph">
<p>If you want to reuse the same reader object to parse another stream, just call
<code>reset()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_member_types_13">4.2.95.1. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef std::size_t size_type</code></dt>
<dd>
<p>Type used to represent sizes.</p>
</dd>
<dt class="hdlist1"><code>typedef const char value_type</code></dt>
<dd>
<p>Type used to represent the value of a single element in the buffer.</p>
</dd>
<dt class="hdlist1"><code>typedef value_type *pointer</code></dt>
<dd>
<p>Pointer-to-value type.</p>
</dd>
<dt class="hdlist1"><code>typedef boost::string_view view_type</code></dt>
<dd>
<p>Type used to refer to non-owning string slices.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_12">4.2.95.2. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>request()</code></dt>
<dd>
<p>Constructor.</p>
</dd>
<dt class="hdlist1"><code>void reset()</code></dt>
<dd>
<p>After a call to this function, the object has the same internal state as an
object that was just constructed.</p>
</dd>
<dt class="hdlist1"><code>token::code::value code() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns code.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following values are <strong>never</strong> returned:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::code::error_set_method</code>.</p>
</li>
<li>
<p><code>token::code::error_use_another_connection</code>.</p>
</li>
<li>
<p><code>token::code::status_code</code>.</p>
</li>
<li>
<p><code>token::code::reason_phrase</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>token::symbol::value symbol() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns symbol.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following values are <strong>never</strong> returned:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::symbol::status_code</code>.</p>
</li>
<li>
<p><code>token::symbol::reason_phrase</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>token::category::value category() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns category.</p>
</dd>
<dt class="hdlist1"><code>size_type token_size() const</code></dt>
<dd>
<p>Returns the size of current token.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>After you call <code>next()</code>, you&#8217;re free to remove, from the buffer, the amount of
bytes equals to the value returned here.</p>
</div>
<div class="paragraph">
<p>If you do remove the parsed data from the buffer, the address of the data
shouldn&#8217;t change (i.e. you must not invalidate the pointers/iterators to old
unparsed data). If you do change the address of old unparsed data, call
<code>set_buffer</code> before using this object again.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
<span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Do <strong>not</strong> use <code>string_length(reader.value&lt;T&gt;())</code> to compute the token
size. <code>string_length(reader.value&lt;T&gt;())</code> and <code>reader.token_size()</code> may
differ. <a href="#parsing_tutorial2">Check the advanced parsing tutorial for more
details</a>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>template&lt;class T&gt; typename T::type value() const</code></dt>
<dd>
<p>Extracts the value of current token and returns it.</p>
<div class="paragraph">
<p><code>T</code> must be one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::method</code>.</p>
</li>
<li>
<p><code>token::request_target</code>.</p>
</li>
<li>
<p><code>token::version</code>.</p>
</li>
<li>
<p><code>token::field_name</code>.</p>
</li>
<li>
<p><code>token::field_value</code>.</p>
</li>
<li>
<p><code>token::body_chunk</code>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The <code>assert(code() == T::code)</code> precondition is assumed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This parser doesn&#8217;t buffer data. The value is extracted directly from
buffer.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>token::code::value expected_token() const</code></dt>
<dd>
<p>Returns the expected token code.</p>
<div class="paragraph">
<p>Useful when the buffer has been exhausted and <code>code() ==
token::code::error_insufficient_data</code>. Use it to respond with
“URL/HTTP-header/&#8230;&#8203; too long” or another error-handling strategy.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>The returned value is a <strong>heuristic</strong>, not a <em>truth</em>. If your buffer is too small,
the buffer will be exhausted with too little info to know which element is
expected for sure.</p>
</div>
<div class="paragraph">
<p>For instance, <code>expected_token()</code> might return <code>token::code::field_name</code>, but
when you have enough info in the buffer, the actual token happens to be
<code>token::code::end_of_headers</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>void next()</code></dt>
<dd>
<p>Consumes the current token and advances in the buffer.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Given the current token is complete (i.e. <code>code() !=
token::code::error_insufficient_data</code>), a call to this function <strong>always</strong>
consumes the current token.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>void set_buffer(asio::const_buffer inbuffer)</code></dt>
<dd>
<p>Sets buffer to <em>inbuffer</em>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><em>inbuffer</em> should hold the data at the same point of unparsed data from the
internal buffer from before this call.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>

<span class="tok-c1">// now unparsed data becomes ahead</span>
<span class="tok-c1">// of `buffer.begin()`</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>

<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span> <span class="tok-o">+</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The reader object follows the HTTP stream orchestrated by the
continuous flow of <code>set_buffer()</code> and <code>next()</code>. You should treat this region as
read-only. For instance, if I pass <code>"header-a: something"</code> to the reader and
then change the contents to <code>"header-a: another thing"</code>, there are no guarantees
about the reader object behaviour. You can safely change only the contents of
the buffer region not yet exposed to <code>reader</code> through
<code>reader.set_buffer(some_buffer)</code> (i.e. the region outside of <code>some_buffer</code> never
seen by <code>reader</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>You&#8217;re free to pass larger buffers at will.</p>
</div>
<div class="paragraph">
<p>You&#8217;re also free to pass a buffer just as big as current token
(i.e. <code>token_size()</code>). In other words, you&#8217;re free to shrink the buffer <strong>if</strong> the
new buffer is at least as big as current token.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to free the buffer while maintaining the reader object valid, just
set the buffer to current token size, call <code>next()</code> and then set buffer to an
empty buffer.</p>
</div>
<div class="paragraph">
<p>Do notice that this will consume current token as well. And as values are
decoded directly from the buffer, this strategy is the only choice.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">()));</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">const_buffer</span><span class="tok-p">());</span>
<span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>size_type parsed_count() const</code></dt>
<dd>
<p>Returns the number of bytes parsed <strong>since <code>set_buffer</code> was last called</strong>.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You can use it to go away with the <code>nparsed</code> variable shown in the
<a href="#parsing_tutorial1">principles on parsing tutorial</a>. I&#8217;m sorry about the “<em>you
must keep track of the number of discarded bytes</em>” lie I told you before, but as
<a href="https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">one
great explainer once told</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>As I look upon you&#8230;&#8203; it occurs to me that you may not have the necessary level
of maturity to handle the truth.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Scott Meyers<br>
<cite>C++ and Beyond 2012: Universal References in C++11</cite>
</div>
</div>
<div class="paragraph">
<p>That lie was useful to explain some core concepts behind this library.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_34">4.2.95.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request_response_diff">What are the differences between <code>reader::request</code> and
<code>reader::response</code>?</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reader_response">4.2.96. <code>reader::response</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/reader/response.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class represents an <code>HTTP/1.1</code> (and <code>HTTP/1.0</code>) incremental parser. It&#8217;ll
use the token definitions found in <a href="#token_code_value"><code>token::code::value</code></a>.
You may want to check the <a href="#parsing_tutorial1">basic parsing tutorial</a> to learn
the basics.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Once the parser enters in an error state (<strong>and</strong> the error is different than
<code>token::code::error_insufficient_data</code>), the internal buffer is said to be in an
invalidated state. Therefore, the parser won&#8217;t access the data anymore and the
user is free to invalidate the data (e.g. resize/free it) without calling
<code>set_buffer()</code> or <code>reset()</code> first.</p>
</div>
<div class="paragraph">
<p>If you want to reuse the same reader object to parse another stream, just call
<code>reset()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_member_types_14">4.2.96.1. Member types</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>typedef std::size_t size_type</code></dt>
<dd>
<p>Type used to represent sizes.</p>
</dd>
<dt class="hdlist1"><code>typedef const char value_type</code></dt>
<dd>
<p>Type used to represent the value of a single element in the buffer.</p>
</dd>
<dt class="hdlist1"><code>typedef value_type *pointer</code></dt>
<dd>
<p>Pointer-to-value type.</p>
</dd>
<dt class="hdlist1"><code>typedef boost::string_view view_type</code></dt>
<dd>
<p>Type used to refer to non-owning string slices.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_member_functions_13">4.2.96.2. Member functions</h5>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>response()</code></dt>
<dd>
<p>Constructor.</p>
</dd>
<dt class="hdlist1"><code>void set_method(view_type method)</code></dt>
<dd>
<p>Use it to inform the request method of the request message associated with
this response message. This is necessary internally to compute the body
size. If you do not call this function when <code>code() ==
token::code::status_code</code>, then <code>token::code::error_set_method</code> will be the
next token.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The <code>assert(code() == token::code::status_code)</code> precondition is
assumed.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>void reset()</code></dt>
<dd>
<p>After a call to this function, the object has the same internal state as an
object that was just constructed.</p>
</dd>
<dt class="hdlist1"><code>void puteof()</code></dt>
<dd>
<p>If the connection is closed, call this function. <code>HTTP/1.0</code> used this event to
signalize <code>token::code::end_of_body</code>.</p>
</dd>
<dt class="hdlist1"><code>token::code::value code() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns code.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following values are <strong>never</strong> returned:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::code::error_no_host</code>.</p>
</li>
<li>
<p><code>token::code::method</code>.</p>
</li>
<li>
<p><code>token::code::request_target</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>token::symbol::value symbol() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns symbol.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The following values are <strong>never</strong> returned:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::symbol::method</code>.</p>
</li>
<li>
<p><code>token::symbol::request_target</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>token::category::value category() const</code></dt>
<dd>
<p>Use it to inspect current token. Returns category.</p>
</dd>
<dt class="hdlist1"><code>size_type token_size() const</code></dt>
<dd>
<p>Returns the size of current token.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>After you call <code>next()</code>, you&#8217;re free to remove, from the buffer, the amount of
bytes equals to the value returned here.</p>
</div>
<div class="paragraph">
<p>If you do remove the parsed data from the buffer, the address of the data
shouldn&#8217;t change (i.e. you must not invalidate the pointers/iterators to old
unparsed data). If you do change the address of old unparsed data, call
<code>set_buffer</code> before using this object again.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
<span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">erase</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Do <strong>not</strong> use <code>string_length(reader.value&lt;T&gt;())</code> to compute the token
size. <code>string_length(reader.value&lt;T&gt;())</code> and <code>reader.token_size()</code> may
differ. <a href="#parsing_tutorial2">Check the advanced parsing tutorial for more
details</a>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>template&lt;class T&gt; typename T::type value() const</code></dt>
<dd>
<p>Extracts the value of current token and returns it.</p>
<div class="paragraph">
<p><code>T</code> must be one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>token::status_code</code>.</p>
</li>
<li>
<p><code>token::version</code>.</p>
</li>
<li>
<p><code>token::reason_phrase</code>.</p>
</li>
<li>
<p><code>token::field_name</code>.</p>
</li>
<li>
<p><code>token::field_value</code>.</p>
</li>
<li>
<p><code>token::body_chunk</code>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The <code>assert(code() == T::code)</code> precondition is assumed.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
This parser doesn&#8217;t buffer data. The value is extracted directly from
buffer.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>token::code::value expected_token() const</code></dt>
<dd>
<p>Returns the expected token code.</p>
<div class="paragraph">
<p>Useful when the buffer has been exhausted and <code>code() ==
token::code::error_insufficient_data</code>. Use it to log error to <em>cout</em> or another
error-handling strategy.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>The returned value is a <strong>heuristic</strong>, not a <em>truth</em>. If your buffer is too small,
the buffer will be exhausted with too little info to know which element is
expected for sure.</p>
</div>
<div class="paragraph">
<p>For instance, <code>expected_token()</code> might return <code>token::code::field_name</code>, but
when you have enough info in the buffer, the actual token happens to be
<code>token::code::end_of_headers</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>void next()</code></dt>
<dd>
<p>Consumes the current token and advances in the buffer.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Given the current token is complete (i.e. <code>code() !=
token::code::error_insufficient_data</code>), a call to this function <strong>always</strong>
consumes the current token.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>void set_buffer(asio::const_buffer inbuffer)</code></dt>
<dd>
<p>Sets buffer to <em>inbuffer</em>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><em>inbuffer</em> should hold the data at the same point of unparsed data from the
internal buffer from before this call.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">nparsed</span> <span class="tok-o">=</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">();</span>

<span class="tok-c1">// now unparsed data becomes ahead</span>
<span class="tok-c1">// of `buffer.begin()`</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>

<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span> <span class="tok-o">+</span> <span class="tok-n">nparsed</span><span class="tok-p">);</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The reader object follows the HTTP stream orchestrated by the
continuous flow of <code>set_buffer()</code> and <code>next()</code>. You should treat this region as
read-only. For instance, if I pass <code>"header-a: something"</code> to the reader and
then change the contents to <code>"header-a: another thing"</code>, there are no guarantees
about the reader object behaviour. You can safely change only the contents of
the buffer region not yet exposed to <code>reader</code> through
<code>reader.set_buffer(some_buffer)</code> (i.e. the region outside of <code>some_buffer</code> never
seen by <code>reader</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>You&#8217;re free to pass larger buffers at will.</p>
</div>
<div class="paragraph">
<p>You&#8217;re also free to pass a buffer just as big as current token
(i.e. <code>token_size()</code>). In other words, you&#8217;re free to shrink the buffer <strong>if</strong> the
new buffer is at least as big as current token.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to free the buffer while maintaining the reader object valid, just
set the buffer to current token size, call <code>next()</code> and then set buffer to an
empty buffer.</p>
</div>
<div class="paragraph">
<p>Do notice that this will consume current token as well. And as values are
decoded directly from the buffer, this strategy is the only choice.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">buffer</span><span class="tok-p">(</span><span class="tok-n">buffer</span><span class="tok-p">,</span> <span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">token_size</span><span class="tok-p">()));</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">next</span><span class="tok-p">();</span>
<span class="tok-n">reader</span><span class="tok-p">.</span><span class="tok-n">set_buffer</span><span class="tok-p">(</span><span class="tok-n">boost</span><span class="tok-o">::</span><span class="tok-n">asio</span><span class="tok-o">::</span><span class="tok-n">const_buffer</span><span class="tok-p">());</span>
<span class="tok-n">buffer</span><span class="tok-p">.</span><span class="tok-n">clear</span><span class="tok-p">();</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>size_type parsed_count() const</code></dt>
<dd>
<p>Returns the number of bytes parsed <strong>since <code>set_buffer</code> was last called</strong>.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<p>You can use it to go away with the <code>nparsed</code> variable shown in the
<a href="#parsing_tutorial1">principles on parsing tutorial</a>. I&#8217;m sorry about the “<em>you
must keep track of the number of discarded bytes</em>” lie I told you before, but as
<a href="https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">one
great explainer once told</a>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>As I look upon you&#8230;&#8203; it occurs to me that you may not have the necessary level
of maturity to handle the truth.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Scott Meyers<br>
<cite>C++ and Beyond 2012: Universal References in C++11</cite>
</div>
</div>
<div class="paragraph">
<p>That lie was useful to explain some core concepts behind this library.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_see_also_35">4.2.96.3. See also</h5>
<div class="ulist">
<ul>
<li>
<p><a href="#request_response_diff">What are the differences between <code>reader::request</code> and
<code>reader::response</code>?</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_chunk_size">4.2.97. <code>syntax::chunk_size</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/chunk_size.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">chunk_size</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_BEGIN</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">invalid</span><span class="tok-p">,</span>
        <span class="tok-n">ok</span><span class="tok-p">,</span>
        <span class="tok-n">overflow</span>
    <span class="tok-p">}</span>
    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_END</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>

    <span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Target</span><span class="tok-o">&gt;</span>
    <span class="tok-k">static</span> <span class="tok-n">result</span> <span class="tok-n">decode</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">in</span><span class="tok-p">,</span> <span class="tok-n">Target</span> <span class="tok-o">&amp;</span><span class="tok-n">out</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_content_length">4.2.98. <code>syntax::content_length</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/content_length.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">content_length</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_BEGIN</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">invalid</span><span class="tok-p">,</span>
        <span class="tok-n">ok</span><span class="tok-p">,</span>
        <span class="tok-n">overflow</span>
    <span class="tok-p">}</span>
    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_END</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>

    <span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">Target</span><span class="tok-o">&gt;</span>
    <span class="tok-k">static</span> <span class="tok-n">result</span> <span class="tok-n">decode</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">in</span><span class="tok-p">,</span> <span class="tok-n">Target</span> <span class="tok-o">&amp;</span><span class="tok-n">out</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_strict_crlf">4.2.99. <code>syntax::strict_crlf</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/crlf.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">strict_crlf</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_liberal_crlf">4.2.100. <code>syntax::liberal_crlf</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/crlf.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">liberal_crlf</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_BEGIN</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>
    <span class="tok-p">{</span>
        <span class="tok-n">crlf</span><span class="tok-p">,</span>
        <span class="tok-n">lf</span><span class="tok-p">,</span>
        <span class="tok-n">insufficient_data</span><span class="tok-p">,</span>
        <span class="tok-n">invalid_data</span><span class="tok-p">,</span>
    <span class="tok-p">}</span>
    <span class="tok-n">BOOST_SCOPED_ENUM_DECLARE_END</span><span class="tok-p">(</span><span class="tok-n">result</span><span class="tok-p">)</span>

    <span class="tok-k">static</span> <span class="tok-n">result</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_field_name">4.2.101. <code>syntax::field_name</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/field_name.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">field_name</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_left_trimmed_field_value">4.2.102. <code>syntax::left_trimmed_field_value</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/field_value.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">left_trimmed_field_value</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_ows">4.2.103. <code>syntax::ows</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/ows.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">ows</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_reason_phrase">4.2.104. <code>syntax::reason_phrase</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/reason_phrase.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">reason_phrase</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="syntax_status_code">4.2.105. <code>syntax::status_code</code></h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&lt;boost/http/syntax/status_code.hpp&gt;</span><span class="tok-cp"></span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">namespace</span> <span class="tok-n">syntax</span> <span class="tok-p">{</span>

<span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-k">class</span> <span class="tok-nc">CharT</span><span class="tok-o">&gt;</span>
<span class="tok-k">struct</span> <span class="tok-n">status_code</span> <span class="tok-p">{</span>
    <span class="tok-k">typedef</span> <span class="tok-n">basic_string_view</span><span class="tok-o">&lt;</span><span class="tok-n">CharT</span><span class="tok-o">&gt;</span> <span class="tok-n">view_type</span><span class="tok-p">;</span>

    <span class="tok-k">static</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-kt">size_t</span> <span class="tok-n">match</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>

    <span class="tok-k">static</span> <span class="tok-kt">uint_least16_t</span> <span class="tok-nf">decode</span><span class="tok-p">(</span><span class="tok-n">view_type</span> <span class="tok-n">view</span><span class="tok-p">);</span>
<span class="tok-p">};</span>

<span class="tok-p">}</span> <span class="tok-c1">// namespace syntax</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="token_header">4.2.106. <code>&lt;boost/http/token.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#token_code_value"><code>token::code::value</code></a></p>
</li>
<li>
<p><a href="#token_symbol_value"><code>token::symbol::value</code></a></p>
</li>
<li>
<p><a href="#token_category_value"><code>token::category::value</code></a></p>
</li>
<li>
<p><a href="#token_skip"><code>token::skip</code></a></p>
</li>
<li>
<p><a href="#token_field_name"><code>token::field_name</code></a></p>
</li>
<li>
<p><a href="#token_field_value"><code>token::field_value</code></a></p>
</li>
<li>
<p><a href="#token_body_chunk"><code>token::body_chunk</code></a></p>
</li>
<li>
<p><a href="#token_end_of_headers"><code>token::end_of_headers</code></a></p>
</li>
<li>
<p><a href="#token_end_of_body"><code>token::end_of_body</code></a></p>
</li>
<li>
<p><a href="#token_end_of_message"><code>token::end_of_message</code></a></p>
</li>
<li>
<p><a href="#token_method"><code>token::method</code></a></p>
</li>
<li>
<p><a href="#token_request_target"><code>token::request_target</code></a></p>
</li>
<li>
<p><a href="#token_version"><code>token::version</code></a></p>
</li>
<li>
<p><a href="#token_status_code"><code>token::status_code</code></a></p>
</li>
<li>
<p><a href="#token_reason_phrase"><code>token::reason_phrase</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="reader_request_header">4.2.107. <code>&lt;boost/http/reader/request.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#reader_request"><code>reader::request</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="reader_response_header">4.2.108. <code>&lt;boost/http/reader/response.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#reader_response"><code>reader::response</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_chunk_size_header">4.2.109. <code>&lt;boost/http/syntax/chunk_size.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_chunk_size"><code>syntax::chunk_size</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_content_length_header">4.2.110. <code>&lt;boost/http/syntax/content_length.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_content_length"><code>syntax::content_length</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_crlf_header">4.2.111. <code>&lt;boost/http/syntax/crlf.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_strict_crlf"><code>syntax::strict_crlf</code></a></p>
</li>
<li>
<p><a href="#syntax_liberal_crlf"><code>syntax::liberal_crlf</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_field_name_header">4.2.112. <code>&lt;boost/http/syntax/field_name.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_field_name"><code>syntax::field_name</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_field_value_header">4.2.113. <code>&lt;boost/http/syntax/field_value.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_left_trimmed_field_value"><code>syntax::left_trimmed_field_value</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_ows_header">4.2.114. <code>&lt;boost/http/syntax/ows.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_ows"><code>syntax::ows</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_reason_phrase_header">4.2.115. <code>&lt;boost/http/syntax/reason_phrase.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_reason_phrase"><code>syntax::reason_phrase</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="syntax_status_code_header">4.2.116. <code>&lt;boost/http/syntax/status_code.hpp&gt;</code></h4>
<div class="paragraph">
<p>Import the following symbols:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#syntax_status_code"><code>syntax::status_code</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. The larger explanation being: incomplete tokens are kept in buffer, so you are not required to allocate them on a secondary buffer, but you&#8217;re still allowed to mutate/move/grow the buffer (as opposed to&#8230;&#8203; say&#8230;&#8203; some C++ iterators that would get invalidated once the container changes).
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. parsing is done one token at a time no matter how much data is buffered
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Proper extraction of header fields (some popular parsers like NodeJS&#8217;s will force you to know protocol details and parser internals to manually remove leading and trailing whitespace from field values). This point is not only about header field extraction, but really about a parser that indeed abstract and understand the protocol and that is easy to use right by people that don&#8217;t know HTTP.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. Useful to avoid the gotchas of ASIO composed operations. See <a href="http://sourceforge.net/p/asio/mailman/message/32259256/" class="bare">http://sourceforge.net/p/asio/mailman/message/32259256/</a> for more information.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. See an example at <a href="http://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp" class="bare">http://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp</a>.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. for tests
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. Used in the core library.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. For tests.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. For the examples and tests.
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. For the <code>file_server</code>.
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. For the documentation.
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. Like <a href="https://sourceforge.net/p/axiomq/code/ci/master/tree/include/axiomq/basic_queue_socket.hpp">axiomq&#8217;s <code>basic_queue_socket</code></a>
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. If I continue to develop the Boost.Http&#8217;s message framework, that&#8217;s the solution that will be adopted to this particular problem.
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. Consult Occam&#8217;s razor.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. Defined in RFC 7231, section 7.1.1.1.
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. Defined in RFC 7232.
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. Defined in RFC 7232.
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. Defined in RFC 7231, section 5.1.1.
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. objects with contiguous storage of bytes.
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. The C++11 update gives extra guarantees about preserving the insertion ordering for elements with equivalent keys.
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. Defined in the <a href="#message_concept"><code>Message</code> concept&#8217;s “definitions” section</a>.
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. Defined in the <a href="#message_concept"><code>Message</code> concept&#8217;s “definitions” section</a>.
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. Defined in RFC 7231, section  5.1.1.
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. The  notification of the error <code>http_errc::out_of_order</code> has priority over  <code>http_errc::native_stream_unsupported</code> because these errors present a  programming logic error that always will happen (i.e. they aren&#8217;t tied to  specific runtime behaviour). If they aren&#8217;t fixed, the program won&#8217;t work  either way.
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. Defined in the <a href="#message_concept"><code>Message</code> concept&#8217;s “definitions” section</a>.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-10-14 15:51:32 -03
</div>
</div>
</body>
</html>